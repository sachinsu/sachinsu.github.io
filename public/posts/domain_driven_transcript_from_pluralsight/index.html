<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Domain driven Design: Learnings | Learnings in IT</title>
<meta name="keywords" content="HTTP, SOAP, REST, .NET, WCF, CoreWCF, ASMX, C#">
<meta name="description" content="Course Overview
Welcome to Pluralsight. My name is Julie Lerman, and this is Steve Smith. Together, we&rsquo;d like to welcome you to our course, Domain‑Driven Design Fundamentals. Steve is a trainer and architect with NimblePros and spends a lot of time helping teams write better code, faster. And Julie is well known in the DDD community for helping reluctant teams embrace domain‑driven design. In this course, we give you a strong foundation for learning how to build applications and microservices using domain‑driven design. DDD has proven to be a very effective approach for managing complex requirements. The original version of this course has helped many thousands of learners leverage domain‑driven design, and they have shared amazing feedback. Now, we&rsquo;ve updated the course and its sample application to reflect ideas and tools that have emerged since that first version. Some of the major topics that we&rsquo;ll cover include what are the essential ideas of domain‑driven design? What are the main patterns used in domain models? We&rsquo;ll also talk about how to break up concepts into smaller parts and how these smaller aggregates and contexts communicate with one another. By the end of this course, you&rsquo;ll know how to break down customer requirements into a maintainable domain model and structure a solution using domain‑driven design. Before beginning the course, you should at least be familiar with software development, ideally using C#. From here, you should feel comfortable diving into DDD and design patterns with courses on the DDD learning path and the design patterns learning path. We hope you&rsquo;ll join us on this journey to learn domain‑driven design with the Domain‑Driven Design Fundamentals course, at Pluralsight.">
<meta name="author" content="Sachin Sunkle">
<link rel="canonical" href="http://localhost:1313/posts/domain_driven_transcript_from_pluralsight/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/domain_driven_transcript_from_pluralsight/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://localhost:1313/posts/domain_driven_transcript_from_pluralsight/">
  <meta property="og:site_name" content="Learnings in IT">
  <meta property="og:title" content="Domain driven Design: Learnings">
  <meta property="og:description" content="Course Overview Welcome to Pluralsight. My name is Julie Lerman, and this is Steve Smith. Together, we’d like to welcome you to our course, Domain‑Driven Design Fundamentals. Steve is a trainer and architect with NimblePros and spends a lot of time helping teams write better code, faster. And Julie is well known in the DDD community for helping reluctant teams embrace domain‑driven design. In this course, we give you a strong foundation for learning how to build applications and microservices using domain‑driven design. DDD has proven to be a very effective approach for managing complex requirements. The original version of this course has helped many thousands of learners leverage domain‑driven design, and they have shared amazing feedback. Now, we’ve updated the course and its sample application to reflect ideas and tools that have emerged since that first version. Some of the major topics that we’ll cover include what are the essential ideas of domain‑driven design? What are the main patterns used in domain models? We’ll also talk about how to break up concepts into smaller parts and how these smaller aggregates and contexts communicate with one another. By the end of this course, you’ll know how to break down customer requirements into a maintainable domain model and structure a solution using domain‑driven design. Before beginning the course, you should at least be familiar with software development, ideally using C#. From here, you should feel comfortable diving into DDD and design patterns with courses on the DDD learning path and the design patterns learning path. We hope you’ll join us on this journey to learn domain‑driven design with the Domain‑Driven Design Fundamentals course, at Pluralsight.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-05-15T01:00:00+05:30">
    <meta property="article:modified_time" content="2021-05-15T01:00:00+05:30">
    <meta property="article:tag" content="HTTP">
    <meta property="article:tag" content="SOAP">
    <meta property="article:tag" content="REST">
    <meta property="article:tag" content=".NET">
    <meta property="article:tag" content="WCF">
    <meta property="article:tag" content="CoreWCF">
      <meta property="og:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:title" content="Domain driven Design: Learnings">
<meta name="twitter:description" content="Course Overview
Welcome to Pluralsight. My name is Julie Lerman, and this is Steve Smith. Together, we&rsquo;d like to welcome you to our course, Domain‑Driven Design Fundamentals. Steve is a trainer and architect with NimblePros and spends a lot of time helping teams write better code, faster. And Julie is well known in the DDD community for helping reluctant teams embrace domain‑driven design. In this course, we give you a strong foundation for learning how to build applications and microservices using domain‑driven design. DDD has proven to be a very effective approach for managing complex requirements. The original version of this course has helped many thousands of learners leverage domain‑driven design, and they have shared amazing feedback. Now, we&rsquo;ve updated the course and its sample application to reflect ideas and tools that have emerged since that first version. Some of the major topics that we&rsquo;ll cover include what are the essential ideas of domain‑driven design? What are the main patterns used in domain models? We&rsquo;ll also talk about how to break up concepts into smaller parts and how these smaller aggregates and contexts communicate with one another. By the end of this course, you&rsquo;ll know how to break down customer requirements into a maintainable domain model and structure a solution using domain‑driven design. Before beginning the course, you should at least be familiar with software development, ideally using C#. From here, you should feel comfortable diving into DDD and design patterns with courses on the DDD learning path and the design patterns learning path. We hope you&rsquo;ll join us on this journey to learn domain‑driven design with the Domain‑Driven Design Fundamentals course, at Pluralsight.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Domain driven Design: Learnings",
      "item": "http://localhost:1313/posts/domain_driven_transcript_from_pluralsight/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Domain driven Design: Learnings",
  "name": "Domain driven Design: Learnings",
  "description": "Course Overview Welcome to Pluralsight. My name is Julie Lerman, and this is Steve Smith. Together, we\u0026rsquo;d like to welcome you to our course, Domain‑Driven Design Fundamentals. Steve is a trainer and architect with NimblePros and spends a lot of time helping teams write better code, faster. And Julie is well known in the DDD community for helping reluctant teams embrace domain‑driven design. In this course, we give you a strong foundation for learning how to build applications and microservices using domain‑driven design. DDD has proven to be a very effective approach for managing complex requirements. The original version of this course has helped many thousands of learners leverage domain‑driven design, and they have shared amazing feedback. Now, we\u0026rsquo;ve updated the course and its sample application to reflect ideas and tools that have emerged since that first version. Some of the major topics that we\u0026rsquo;ll cover include what are the essential ideas of domain‑driven design? What are the main patterns used in domain models? We\u0026rsquo;ll also talk about how to break up concepts into smaller parts and how these smaller aggregates and contexts communicate with one another. By the end of this course, you\u0026rsquo;ll know how to break down customer requirements into a maintainable domain model and structure a solution using domain‑driven design. Before beginning the course, you should at least be familiar with software development, ideally using C#. From here, you should feel comfortable diving into DDD and design patterns with courses on the DDD learning path and the design patterns learning path. We hope you\u0026rsquo;ll join us on this journey to learn domain‑driven design with the Domain‑Driven Design Fundamentals course, at Pluralsight.\n",
  "keywords": [
    "HTTP", "SOAP", "REST", ".NET", "WCF", "CoreWCF", "ASMX", "C#"
  ],
  "articleBody": "Course Overview Welcome to Pluralsight. My name is Julie Lerman, and this is Steve Smith. Together, we’d like to welcome you to our course, Domain‑Driven Design Fundamentals. Steve is a trainer and architect with NimblePros and spends a lot of time helping teams write better code, faster. And Julie is well known in the DDD community for helping reluctant teams embrace domain‑driven design. In this course, we give you a strong foundation for learning how to build applications and microservices using domain‑driven design. DDD has proven to be a very effective approach for managing complex requirements. The original version of this course has helped many thousands of learners leverage domain‑driven design, and they have shared amazing feedback. Now, we’ve updated the course and its sample application to reflect ideas and tools that have emerged since that first version. Some of the major topics that we’ll cover include what are the essential ideas of domain‑driven design? What are the main patterns used in domain models? We’ll also talk about how to break up concepts into smaller parts and how these smaller aggregates and contexts communicate with one another. By the end of this course, you’ll know how to break down customer requirements into a maintainable domain model and structure a solution using domain‑driven design. Before beginning the course, you should at least be familiar with software development, ideally using C#. From here, you should feel comfortable diving into DDD and design patterns with courses on the DDD learning path and the design patterns learning path. We hope you’ll join us on this journey to learn domain‑driven design with the Domain‑Driven Design Fundamentals course, at Pluralsight.\nIntroducing Domain-Driven Design Introduction and Overview Hi, this is Steve Smith ‑and this is Julie Lerman. Welcome to our course, Domain‑Driven Design Fundamentals. ‑We’re looking forward to sharing our experience with DDD and how it’s helped us and our clients. You’re welcome to reach out to us online. ‑You can find me online at thedatafarm.com or on Twitter @julielerman. ‑And I’m online at ardalis.com or on Twitter as @ardalis. ‑Eric Evans coined the term Domain‑Driven Design in his groundbreaking book with the same title published in 2004. Since then, other titles have followed, including great books expanding on the subject by Jimmy Nilsson and Vaughn Vernon and so many who are now also great experts at DDD. And there are also now a number of fantastic DDD conferences and even a well‑established virtual meetup. ‑There’s definitely continued and renewed interest in Domain‑Driven Design as both the demand for and complexity of software continues to grow. Domain‑Driven Design is commonly referred to as DDD and even has its own Twitter hashtag, dddesign. Although DDD has been around for so long, it continues to be a great approach to building software that we both enjoy employing and sharing with others. And as more minds have gotten involved in DDD, it continues to evolve.\nWhat to Expect from This Course and This Module Domain‑Driven Design is a huge topic. Our focus will be on the developer perspective and the technical and coding aspects of DDD more so than architectural concerns. We’ll start by talking about why we think you should even be watching this course. Next, we’ll jump right into an existing solution so you can get a concept of what the code and the architecture of an application written using DDD practices looks like. Then we’ll start digging into the big DDD concepts like modeling problems of the domain, what the various technical components of DDD are, and how you can use DDD to manage complex projects. Throughout the course, we’ll use the existing solution so you can see how some of this process works. ‑With this in hand, we’ll walk through extending the sample based on a new request from the client. Since this is a fundamentals course, we certainly don’t expect to turn you into an expert by the end of it; however, you should be well on your way to understanding the value behind Domain‑Driven Design and how some of the practices can be employed to improve your success with complex software projects. Right now, if you’re new to DDD, you don’t even know what you don’t know yet. However, once you’re done with this course, you’ll know more about DDD, but of course, you’ll also realize how much more there is to learn. That’s one of the great things about our industry. The more you know, the more you realize how much more there is you don’t know. ‑In this module, we’ll focus on the value of Domain‑Driven Design. You’ll learn what the term represents and what problems DDD can help you with in your software building process. ‑Not only will we share the benefits of DDD, but we will be sure to highlight some of the potential drawbacks. Finally, you’ll get a look at a small application that we’ll be using throughout the course as you learn DDD.\nUnderstanding the Value of Domain-Driven Design Domain‑Driven Design focuses on the problems of the business domain that you’re attempting to solve. Its a critical shift from decades of focusing on how to store your data and then letting that drive how the software is designed. But that workflow added a lot of unnecessary complexity to the task of building software. So why should you watch this course? Why should you care about learning Domain‑Driven Design. Steve and I have both been designing and developing software for a very long time. Without giving away our ages, we’ve got over 40 years of experience between the two of us, and we’ve both been very inspired by Domain‑Driven Design. In many ways, it aligns very naturally with ideas that we’ve each come to from our own experience. It also takes these ideas and lays them out in a way that’s not only illuminating, but it’s repeatable. When Eric Evans wrote his book, his goal was to understand what was behind the successes he had achieved with large‑scale, complex software projects and what were the patterns. That’s what he laid out in the book. ‑This is why we care about DDD, and we hope that you can gain from our experience, which is why we put together this course. DDD provides principles and patterns to help us tackle difficult software problems and even business problems. These are patterns that are being used successfully to solve very complex problems. The more we’ve learned about DDD, the more we found these ideas aligned with the approaches we’ve learned from our many combined years of experience. DDD provides us with a clean representation of the problem in code that we can readily understand and verify through tests. We developers live to code. When starting on a new project, we’re eager to jump in and start coding so that we can build some software. But you can’t build software unless you truly understand the client’s needs. DDD places as much emphasis on not only comprehending what your client wants, but working with them as full partners through a project. The ultimate goal isn’t to write code, not even to build software, but to solve problems. ‑You need to realize that nobody really wants your program. They want what it can give them. There’s a famous saying in sales. Buy a quarter‑inch drill, they want to buy quarter‑inch holes. Your client’s not interested in building software, but in being successful at their mission. Software provides a more efficient means to this end.\nGaining a High-Level Understanding of DDD Domain‑driven design is for solving complex problems. Evans put a lot of thought into the subtitle of his DDD book and came up with Tackling Complexity in the Heart of Software. But DDD itself is a complex topic. To start with, we think it’s helpful to look at it from a very high level. We call it the 10,000 foot view here in the US, but that’s probably 3,048 meters to the rest of you. ‑One of the critical pieces of DDD is to encourage better interaction with domain experts. These are the people who live and breed the business or process or whatever you are targeting with the software you’re planning to write. You may be thinking, but we already talked to them. Perhaps, but probably you’re using your terms, not theirs, and maybe talking in the language of tables in a database rather than domain concepts. Or you may presume that after some standard requirements gathering, you can infer enough about the problem at hand to design the solution on your own. After our own history in the business of developing software, we know that that rarely ends well. DDD guides us to engage with the domain experts at much greater length and through much more of the process than many software teams are used to doing. ‑When talking with Eric Evans about this, he told us that you really need to cultivate your ability to communicate with business people in order to free up their creative modeling. Another core theme in DDD is to focus on a single subdomain at a time. Say you’re asked to build software for a spaceship manufacturer. They describe their business tasks such as purchasing materials, engineering, managing employees, advertising their spaceships and share with you their dreams about mass producing spaceships when the market’s ready. Each one of these tasks are in themselves a complex subdomain filled with their own specific tasks, terminology, and challenges, and those subdomains may have only minimal interaction between them. Many applications just try to do too many things at once, then adding additional behavior gets more and more difficult and expensive. With DDD, you’ll divide and conquer. By separating the problem into separate subdomains, each problem can be tackled independently, making the problem much easier to solve. This lets us focus on the problem of employee management separately from the problem of sourcing materials for producing the spaceships. The term modeling is important in DDD and refers to how you decipher and design each subdomain. You’ll learn much more about this as you progress through the course. ‑The final theme in our high‑level perspective of DDD is writing the code to implement each subdomain. The principle of separation of concerns not only plays a critical role in identifying the subdomains, but within each subdomain, we use it as well. Many applications spread the domain logic between the persistence layer and the user interface, making it much more difficult to test and to keep all of the business logic consistent. DDD applies separation of concerns to help steer you clear of this problem by focusing on the domain and not on details like how to persist data into a database or how to connect to a service in the cloud. Those become implementation details that you can worry about separately. While implementing these subdomains, the focus is on the subdomain, the problems of the subdomain you are trying to solve with your software. You don’t get bogged down worrying about infrastructure concerns.\nExploring the Benefits and Potential Drawbacks of DDD Domain‑Driven Design is a big commitment. While Steve and I have both chosen to leverage pieces of DDD as we learn more about the wider scope, one thing we’re both confident about is that it’s providing a lot of benefits to our work. Because DDD guides us to focus on small, individual, nearly autonomous pieces of our domain, our process and the resulting software is more flexible. We can easily move or modify the small parts with little or no side effects. It even lets us be more flexible with our project resources as we’re building the software. ‑The resulting software also tends to be more closely mapped to the customer’s understanding of the problem. DDD gives you a clear and manageable path through a very complex problem. When you look at the code, you can see that it’s generally well organized and easily tested, and the business logic all lives in one place. Even if you don’t use full DDD for a project, there are many patterns and practices that you can use by themselves to benefit your application. So keep watching, even if you don’t think you’ll need all of it. ‑We often describe DDD as a way to take big, messy problems and transform them into small, contained, solvable problems. But DDD is not a path for every project. It’s real benefit is for complex domains. Even Eric Evans explicitly states that DDD isn’t suitable for problems when there’s substantial technical complexity, but little business domain complexity. Using DDD is most beneficial when the complexity of the domain makes it challenging for the domain experts to communicate their needs to the software developers. By investing your time and effort into modeling the domain and coming up with a set of terminology that’s understood for each subdomain, the process of understanding and solving the problem becomes much simpler and smoother. ‑But all this comes at a cost. You’ll spend a lot of time talking about the domain and the problems that need to be solved, and you’ll spend plenty of time sorting out what is truly domain logic and what is just infrastructure. The easy example there is data persistence, or for the sake of our spaceship manufacturer, maybe it’s how to communicate with an external service that helps to verify that potential buyers are properly vetted for space travel. ‑You’ll have a big learning curve as you learn new principles, patterns, and processes. There’s no question about that. DDD is a big topic and gaining expertise from end to end is a big commitment. This course doesn’t aim to make you an end‑to‑end expert in DDD, but to give you a big step forward that will allow you to not only comprehend the concepts, but you’ll gain a lot of new tools that you can use right away, whether or not you choose to dig further. And it’s worth restating that DDD is not always the correct path for your applications. And it’s helpful to keep in mind some of the scenarios where DDD is just going to be overkill. For example, if you have an application or a subdomain that’s just a data‑driven app and doesn’t need much more than a lot of CRUD logic, there’s really no need to use DDD. It would be a waste of time and effort. ‑And be clear about the difference between complexity in your business domain and technical complexity. DDD is designed to help with complex domains. If your domain is simple, even if you have a lot of technical challenges to overcome, DDD still may not be the right path. For example, if you are writing a tic‑tac‑toe game for a touch screen with a new complex API, the complexity lies in the touch interactions of the two players on the screen. The domain itself is well known and just comes down to Xs and Os. Getting others to follow the DDD approach can also be a drawback. There may be some politics involved in this decision. It really depends on your team and your organization. We hope that another takeaway from this course will be to help you understand the concrete benefits of DDD, which you can show to your coworkers to help convince them.\nInspecting a Mind Map of Domain-Driven Design In his DDD book, Evans included a really useful diagram of how many of the concepts and patterns of DDD are interrelated. Let’s take a look at that mind map. ‑Evans refers to this as a navigation map, and it lays out all of the pieces of Domain‑Driven Design and how they relate to one another. We want you to see it so that you have a concept of the big picture, even though in this course we’ll spend most of our time on a subset. We will be defining many of these terms later on in the course, so don’t panic. We’ve mentioned modeling the domain and subdomains a few times. Modeling is an intense examination of the problem space. Key to this is working together with the subject matter experts to identify the core domain and other subdomains that you’ll be tackling. Another important aspect of modeling is identifying what’s called bounded contexts. And within each of these bounded contexts, you focus on modeling a particular subdomain. As a result of modeling a bounded context, you’ll identify entities, value objects, aggregates, domain events, repositories, and more and how they interact with each other. ‑In the image, there’s more than just these subdomains, however. For example, there is a concept of an anti‑corruption layer, which allows subdomains to communicate with one another from behind their boundaries. The model also has notes for each element, such as free teams to go separate ways. This is something that can be accomplished once you’ve identified the boundaries of each subdomain. Or avoid overinvesting in generic subdomains. That could be something like a credit card verification service that you could choose to use rather than building yourself. As you begin focusing on specific subdomains, another very important DDD concept surfaces, driven by the need for clear, concise communication. It’s called the ubiquitous language. A simple definition of a ubiquitous language is to come up with terms that’ll be commonly used when discussing a particular subdomain. And they will most likely be terms that come from the problem space, not the software world, but they have to be agreed upon so that as discussions move forward, there is no confusion or misunderstanding created by the terminology used by various members of the team. ‑We invite you to pause this video to look over this map and read the notes associated with the various elements and contemplate what they might mean. We’ll revisit this throughout the course, and we hope that the map will make more and more sense as you work through the course.\nIntroducing Our Sample Application Now we want to switch over and show you a relatively small DDD‑based solution that we’ll be working on for the rest of the course. This app represents an appointment scheduling system for a veterinary clinic. It’s “small”, but since DDD requires a certain amount of complexity to warrant its use, it’s bigger than most demos you’ll see in other courses or presentations. For this course, we decided that we would use a veterinary clinic management system because it has a decent amount of complexity, and that means that we can apply some of the DDD principles, but it also gives us an excuse to show off pictures of our pets. ‑And our friends pets too. We’ve got a whole bunch of pet pictures from other Pluralsight authors in here, and they’re all so cute. ‑We’ve got Ben Franklin here from Michael Jenkins. We’ve got Patrick Neborg’s dog here, Sugar. Aren’t these guys cute? And, of course, Julie’s got Sampson. ‑Oh, my handsome boy. ‑And I’ve got Darwin, the silly poodle. He was just a puppy when we recorded the first version of this course, and he’s got a new friend, Rosie. Rosie is just a puppy. I guess every time I get a puppy we have to update this course. ‑So the idea behind this application is that if you’re working at the front desk of a vet clinic and someone walks in, maybe they want to schedule an appointment, or the phone rings with someone who wants to schedule an appointment for their pet, the first thing you’re going to do is look that client up, the person, in the system. ‑So the user starts by looking up the client, and from there, they can choose which of the clients, animals or patients, they’re going to schedule. So here’s Julie with Sampson. Here’s Kim with Roxy. Next, the user is just going to click on an open slot in the schedule, which opens up the create appointment window. ‑Oh, Roxy, you’re such a cutie. We can set up Roxy for a wellness exam with Dr. Smith. ‑Now notice before we save this appointment, it isn’t yet confirmed. We’ll get to that in a minute. So we save, and the appointment shows up. Now the complexity in this system comes into play when we have to do some checks for certain things. We want to make sure, for instance, that Roxy isn’t already scheduled in one of the other rooms at this exact time. We also want to send an email notification to Kim to let her know that Roxy has this appointment scheduled. We’ll add a link in the email the client can click to confirm. And in a real system, perhaps it would add it to their calendar of choice. The idea is to cut down on no‑show appointments for the clinic. ‑Of course, there are other features of this application. We’re focused on the schedule right now, but we do need to be able to manage client data and manage their pet data, the clinic’s patients, and things like that. Admins need to be able to manage doctors and rooms and appointment type since these all might change over time or from one clinic to another that uses the same software. But those are mostly CRUD tasks, which means we’re just talking about adding and removing records and maybe making some edits without a whole lot of complexity. We’ll talk about those tasks in a different compartment of the application than the schedule, which, of course, has a lot more complexity.\nExploring the Sample App’s High-level Structure So why don’t we take a look at the structure of our app? This is a distributed application built with ASP.NET Core on .NET 5. It’s running Blazor WebAssembly in the front end, which is talking to APIs running on ASP.NET Core. There are three different web apps that the system uses. Two are used internally by client staff, and then there’s the public‑facing website for the clinic, which is needed for the confirmation links that users will click. The two clinic apps, Front Desk and Clinic Management, each have their own database, and all three apps communicate with one another using messages transported by RabbitMQ. Like I said, it’s maybe a little more complicated than most demos. We want the sample app to be something you spend some time with and extend as part of your experience with this course, so please be sure to check it out and run it locally. It should just work if you have Docker installed. ‑Now let’s take a quick look at how the code is organized. The full solution is hosted on Steve’s GitHub account. Here’s the URL, but we’ll definitely also have that URL in the resources slides at the end of this module. PLURALSIGHT DDD FUNDAMENTALS is the name of the root of our GitHub repository. In here, you can see the three web apps, ClinicManagement, FrontDesk, and the public‑facing website, VetClinicPublic. ‑There’s also a folder for SharedKernel, which we’ll talk about a little bit later. The first app we’re going to focus on though is the FrontDesk app. ‑Our main focus for this course is going to be the front desk application and its scheduling functionality. Looking at the solution, you can see it’s broken up into seven projects, which seems like a lot, but three of them are just there to support Blazor The server‑side code, where our domain model resides, is just three projects. ‑The most important project is FrontDesk.Core. That’s where the domain model is defined. All of the app’s infrastructure needs, like how it talks to its database or RabbitMQ, are kept in the FrontDesk.Infrastructure project. In the front end, in this case, ASP.NET Core and its API endpoints, is in the FrontDesk.Api project. This is the front end from the server’s perspective. The system is using a clean architecture design which you may also hear referred to as onion architecture or ports and adapters. I cover this in my N‑Tier Applications in C# course, and I have a popular GitHub solution template you can use to set up a new project using this approach. ‑With clean architecture, the project dependencies all point towards the domain model in the core project, so both the API and infrastructure projects have a dependency on Core. Core should never depend on infrastructure concerns, but it can leverage NuGet packages that don’t couple it to infrastructure concerns. ‑In this case, it’s using a couple of utility packages, as well as the SharedKernel package that’s shared by other apps. We’ll talk more about SharedKernel later. The ClinicManagement app uses the same kind of structure and also has a Blazor front end because why not? It’s pretty much just CRUD, so we don’t focus too much on its domain model, but it is a distinct app with its own database, and we do need to build into our design a way to propagate changes from it to the FrontDesk app. ‑Finally, there’s the public web app. It’s just one project, and it’s pretty simple. This is responsible for sending emails, which this demonstration fakes using a tool called PaperCut, and it hosts the link that clients click to confirm appointments. The public web app also needs to communicate with the front desk, but it doesn’t have a database of its own, nor does it access any of the other app’s databases. ‑That’s it in a nutshell. We’ll demonstrate the confirmation emails and more complex use cases later in the course. But for now, that should give you an idea of how the ideas we’re sharing are put into practice.\nReview and Resources So, as we’ve talked about, creating applications is not about writing code, even though often that’s a really, really fun part for us developers, but it’s about solving problems. And the more complex the problems are, the more difficult the whole project becomes. So Domain‑Driven Design gives us some great patterns and practices for attacking these more complex problems, and they get us to really focus on interacting with the domain experts, breaking apart our domain, and working on things in smaller units and in a very organized fashion. And in the end, it gives us a much more efficient and effective path to success in creating our solutions. ‑Yeah, we talked about some of the benefits that Domain‑Driven Design provides, as well as some of the drawbacks. Specifically, your team just needs to know Domain‑Driven Design, and your domain experts need to be available to work with you on these systems. Domain‑Driven Design is a big topic. We looked at some of the different concepts that are involved in DDD, and we’re going to look at a lot more of them in depth through this course. But remember that this is just an introduction to Domain‑Driven Design, so some of these aspects that are a little more advanced, we’re not going to be able to cover with a great deal of depth. ‑In the next module, we’ll start exploring the process of discovering and modeling domains. Here are some links to resources that we mentioned this module and others that we find relevant. ‑This is Steve Smith ‑and this is Julie Lerman, and thanks for watching Domain‑Driven Design Fundamentals.\nModeling Problems in Software Introduction and Overview Hi. This is Steve Smith. ‑And this is Julie Lerman. Welcome back to our Domain‑Driven Design Fundamentals course. This module will focus on modeling problems in software, and you’re welcome to reach out to us online. You can find me online at thedatafarm.com or on Twitter @julielerman. ‑And I’m at ardalis.dot com or on Twitter as @ardalis. In this module, we’re going to take a look at how we decompose the model for the veterinary office domain. We’ll talk about the importance of domain experts in DDD. ‑We’ll drive this point home with a play in which we’ll consider a few different scenarios for how the project might have gone, which should provide you with examples of ways to involve the domain expert in the design of the system. ‑Next, we’ll talk about the domain model and some of the elements that typically are found in this part of the application. It’s important to separate the core domain model from related subdomains, and we’ll talk about how bounded contexts can help us accomplish this separation. ‑And then we’ll wrap things up by talking about ubiquitous language and how this seemingly small thing with a big name can have a large impact on your model, your design, and, of course, your application. So let’s get started.\nIntroducing Our Domain Steve and I both have a love for animals. In fact, Steve’s wife, Michelle, is a veterinarian. In thinking about a sample application we could use for this course, we wanted to use something complex enough to justify the use of DDD. The veterinary clinic management domain made a lot of sense, allowing us to leverage our own experience as pet owners, as well as having a domain expert available in the form of Michelle, or Dr. Smith as we’ll be referring to her in the course. ‑There are many different pieces involved in managing a typical veterinary clinic. The staff needs to be able to schedule appointments. They likely need to schedule their own working shifts as well. They need to be able to invoice for their services and collect payments and, in many cases, send out bills. They’ll also need to be able to store and retrieve medical records, as well as work with external labs and specialty clinics. Most veterinary practices also have products for sale and may need to track inventory, as well as sales. And there are often follow‑ups and reminders that may need to be sent by mail, phone, or perhaps email. There is certainly sufficient complexity in this domain to merit the use of domain‑driven design.\nPlanning Ahead to Learn About the Domain Of course, it’s a good idea to speak with a domain expert about the systems requirements before diving in and beginning to code a solution. Whether you’re tasked with building a full system or just adding a new feature, an overall understanding of the client’s business is a critical start. Of course, it’s just the beginning. It’s also important that you have a continuous conversation with the domain expert throughout the development of the system. The simple system we showed in the last module needs some updates. So we’re going to share some conversations we had with the domain expert to help validate our initial assumptions. ‑An important part of this conversation is going to be identifying the things that aren’t included in the scope of the project or feature. To that end, we’ll try to identify subdomains within the overall problem domain and then determine whether or not we need to concern ourselves with these subdomains at the moment. If not, we can consciously remove them from the scope with the customer’s approval and avoid confusion and possible missed expectations later. To get started though, we do want to know a little bit about the big picture.\nConversation with a Domain Expert: Exploring the Domain and Its Subdomains As Julie already mentioned, my wife, Michelle, is a veterinarian. In addition, she has a deep understanding of software development processes, having successfully managed software teams at NimblePros and Teller. She has graciously agreed to play the role of domain expert for our course. In real life, she knows quite a bit about software and technology, but for the purposes of this course, she’s playing the more traditional role of a veterinarian with little background in software development. Hi Dr. Smith. Thanks for your time today. Julie and I would like to learn more about what goes on in your veterinary clinic. Can you share some of the big picture processes involved in the day‑to‑day operation of a clinic? ‑So the biggest thing is probably scheduling patients and keeping track of them once they arrive. Clients will usually call ahead unless it’s an emergency, and then we need to get them entered into our system. Of course, surgical procedures need to be scheduled in advance. And when they’re here, we need to record information about the patient, our observations, notes, and diagnoses. ‑Wow, that’s quite a list. Probably not what you were dreaming about when you started vet school. So many of these are all secondary to the core reason for being a vet, keeping pets healthy. And, I think it sets you apart from other businesses that have to manage clients and schedule appointments. But, you can’t run a business without it. Is that all? ‑So when the appointment is over, they also have to pay. So most of the time that’s done immediately, but we do have some billing that’s done after the fact, and when they’re checking out, they may need to buy some things for their pets, toys or prescriptions, or maybe some prescription food as well, and we need to track all of that as well. For some of the lab work, we need to send that out and get the results back, and some prescriptions go out to outside pharmacies as well. So we need to manage all of those through the system. ‑Okay, so payments, billing, point of sale, labs, prescriptions, anything else? ‑I think that’s about it. Oh, we also use the system to note which staff members are working when, and right now our website isn’t integrated into the system at all, but we were thinking it would be great if clients could view information about their pets, maybe schedule appointments, look up prescriptions, and we can make updates to the site without having to go through our computer contractor. ‑Okay, great. So, we’ll add staff scheduling and content management to the list. I don’t want to assume you know what a content management system is. We also call it a CMS, you might have heard of that. It’s a type of software system that lets the owner, that’s you, be in charge of the information that’s displayed. A blog is a really good example of a CMS that can be managed by its owner. ‑I have a blog, so I understand exactly what you mean. Something like that would be really great for us to have so we can make updates right in‑house. But it’s kind of like a blog, especially something that’s more professional than my personal blog. ‑Cool. So I think that’s probably enough of a big picture view for us to consider at the moment. Now let’s try and think about which of these are connected to the others so we can determine which ones we need to worry about for our application’s needs. ‑We started with this fairly complicated view of the overall problem domain, but now we’ve segregated these into different areas and we know which ones we need to focus on right now and which ones we can treat as external collaborators. ‑Determining where we can safely draw the line between what problem our immediate application needs to solve and what is outside of its area is certainly helpful. It’s also important that this be well understood and communicated among everyone involved in the project.\nConversation with a Domain Expert: Exploring the Scheduling Subdomain Now that we have a better understanding of the domain and the other subdomains around the scheduling system, it’s time to focus more on understanding the scheduling subdomain. We had another meeting with Dr. Smith, and you can listen in. ‑Hi guys, welcome back to the clinic. How are things going with the computer system? ‑We’re making good progress, and now we’re ready to look at another more complex feature. ‑We know there’s a lot that goes on here, but today we want to focus on appointment scheduling because we realize we’re still a little confused about it. ‑Since we’ve both owned pets for a long time, we figure we probably have a rough idea of what’s needed, but it’ll be good to talk through it with you. Do your patients usually schedule their appointments over the phone? ‑Okay, so yeah our patients aren’t usually involved in the scheduling. Usually, it’s the clients that call in for appointments for their pets. And yeah, usually it’s on the phone or in person when they’re checking out after an office visit. Julie and I talked about that earlier. ‑Yeah, so Steve, the patients are the animals, and the clients are the people or the pet owners. ‑Right, right, of course, that’ll be important to get right. ‑Remember, we talked about that. So the client needs to make an appointment for their pet. They’ll talk to a staff member who will schedule the appointment. What kind of information do they need in order to do that? ‑So that really depends on the type of appointment. It could be an office visit, or it could be a surgery. Why don’t we talk about the office visits first. If it’s just for a wellness exam, that’s pretty standard. They just need to choose an available time slot with one of the doctors. Some of the visits can be scheduled with just a technician though, so if they need just their toenails trimmed, for example. ‑Or painted, like Samson. He gets his toenails painted. ‑Does he really? ‑No, I’m joking. I just want to, pink. ‑I’m sure he’d love that. Okay, so office visits might be an exam requiring the doctor or another kind of appointment that only requires a technician. ‑Right. We also have to worry about our rooms too. We only have five exam rooms available, and we try not to overbook. We don’t like for our clients to have to wait too long in the reception area, especially if we have a lot of cats and big dogs out there at the same time. It makes them all really nervous. ‑What about other staff? ‑So our technicians will float between the exam rooms and other areas of the clinic as needed, except, of course, for those scheduled technician visits. We do have a schedule for the staff, but it’s separate from how we schedule our appointments. ‑Okay, so what about the surgeries? ‑Well, if it’s a surgery, those are only scheduled on certain days, and they require that the operating room be available, as well as some recovery space in the kennel area. It also depends on what kind of surgery or procedure we’re going to be doing. Something simple like a dental cleaning takes less time and fewer people than a caesarean section for a bulldog. ‑Okay, so an appointment is either an office visit or a surgery. Office visits happen in the exam room; surgeries require the operating room and recovery space. Is that right? ‑Right. And depending on the reason for the visit or the surgery, different staff might need to be involved. ‑So we’ll probably want to have separate classes for appointments and surgeries. ‑Classes? No, we refer our clients to obedience and puppy preschool classes at other facilities. We don’t actually schedule any of those in the clinic themselves. ‑I’m sorry. That’s a software term. In software, we have different classifications of concepts in the program, which are called classes. I’m just getting ahead of myself here. Sorry. ‑Don’t worry. We’re not going to make you learn our software terms. Steve and I will try to have a little bit more self control with that. We do want to make sure we’re all speaking the same language when it comes to concepts in the application though. ‑Okay, so I have another quick question. Do we have to worry about multiple staff members scheduling appointments at the same time? ‑No, there should only ever be one person doing the scheduling at a time, although I could see if we grew in the future that could change. But I don’t think that’ll happen in the next couple of years. Okay, then we don’t have to worry about the rare occurrence of two people creating a conflict if they’re trying to schedule an appointment for different patients in the same room or with the same doctor. That’ll keep things a lot simpler. And we need to know before an appointment if certain resources are available, like rooms and doctors. And then if they are and we want to schedule the appointment, then we need to be able to book the doctor, the room, and any other resources. Hey, is it okay if we refer to doctors as resources? ‑Sure, that makes sense. You know, I think it makes sense to use the term resources to refer to the doctors, the rooms, and the technicians since those are all things that can affect whether or not an appointment can be scheduled. But remember, sometimes it’ll be just a vet tech in a room, and other times it might be the doctor in the room, but sometimes you might need the doctor, the technician, and a room. ‑Wow, this is a lot more complicated than we’d realized, but it’s interesting. This is going to be cool to model in the application.\nReviewing Key Takeaways from Meeting with Domain Expert(s) Some of the things we learned in that initial high‑level discussion with the domain expert included the fact that patients and clients are not the same thing to a veterinarian. ‑Yeah, that’s pretty obvious in hindsight. But in most other medical professions, it is the patients who make appointments and pay the bills. It’s good we were able to get on the same page with the customer on that early on in the process. ‑I think it helped Dr. Smith put some of the processes she uses into explicit terms that we could program against also. A lot of times just describing the process to someone who is unfamiliar with it can really help improve the understanding of it. It’s like that idea that when you have to teach something to someone else, it makes you learn it a lot better. Listen to what Dr. Smith had to say at the end of our conversation about this. ‑Yeah, I never really thought about the details of how we do some of these things since it’s just something we do, and we don’t really think about it. Being more explicit about what the rules are that determine how we do are scheduling could help us avoid some of the occasional scheduling problems we’ve had. This is going to be great. ‑We also need to remember not to use too much programmer jargon, especially when there are programming terms that might have a different meaning in the customer’s domain. ‑I agree. It’s a little early for us to be worrying about how things might end up looking in the code anyway. At this stage, the main focus is on understanding the domain. We’ll get to building the software soon enough. But first, we want to make sure we know what problem it’s going to be solving. One of the most important things we can do as we explore the problem with the domain expert is to try and make their implicit knowledge about the process they use now explicit. Once we’re able to capture the process and its rules and exceptions with some detail, we can start to work on modeling a solution using this information. Building software is hard. One of my favorite sayings is as software developers, we fail in two ways. We build the thing wrong, or we build the wrong thing. By making sure we understand what the customer needs and, of course, working closely with the customer throughout the development process, we can dramatically reduce the likelihood of the second kind of failure, which is much harder to fix typically. ‑Hey, Steve. I like the way you quote yourself here, but it really is a great quote.\nTaking a First Pass at Modeling our Subdomain After talking to Dr. Smith about how appointments work, we’ve identified a few high‑level elements of our model. The central concept in this application seems to be the appointment itself. Typically, an appointment is scheduled by a client for a patient. Booking an appointment often requires an exam room and a doctor, but may involve other resources. Appointments might be for office visits or vaccinations, or they might be surgeries, which are a separate kind of thing entirely with their own rules which involved different kinds of procedures. Surgeries require different resources too, like operating rooms and recovery rooms. ‑That’s a pretty good high‑level view of the model we have so far for the appointment management part of our application. I think it’s worth noting that some of the concerns of this application are going to also play a part in other subdomains. For instance, I’m pretty sure we’re also going to be working with clients and patients in a lot of the different parts of this application. ‑Yeah, I think it’s time we introduce the idea of bounded contexts.\nUsing Bounded Contexts to Untangle Concepts that Appear to Be Shared As you develop your model, remember to identify its bounded context. That is, where is this model valid? If you don’t put boundaries around your model, eventually, pieces of it will be used where they don’t fit. Concepts that make sense in one part of the application may not make sense in another, even if they have the same name and sometimes even if they literally refer to the same thing. ‑For example, as we built out the appointment scheduling portion of this system, we needed to know some very basic information about clients. But in the context of appointment scheduling, these are very simple concepts with little behavior beyond their names. However, in the billing context, we’ll want to include contact and payment information for clients, but that’s information we don’t care about back in the appointment scheduling context. If we try to reuse the same exact client model in multiple places, it’s likely to cause inconsistent behavior in our system. ‑That’s right. For instance, we might decide to include some form of validation on clients to ensure we have enough information to bill them. If we’re not careful, that validation might inadvertently prevent us from being able to use clients to schedule appointments, which certainly isn’t the desired behavior. Maybe the billing system requires that clients have a valid credit card in order to save changes for them, but it wouldn’t make sense for a lack of a credit card to prevent us from saving an appointment for a client in the appointment scheduling system. In this example, we have two contexts, but the boundaries between them are blurred and overlapping. Eric Evans notes that models are only valid within specific contexts. Therefore, it’s best to explicitly define the context within which a model applies. We should be able to avoid compromising the model within this context, keeping it strictly consistent within these bounds and avoiding distractions or confusion from outside issues. ‑Once we explicitly define our bounded contexts, we can easily see whether or not we have elements of our model that are trying to span multiple contexts. In this example, we’d want to keep a simple view of a client in the appointment scheduling up and a richer version of the client with contact and billing information in the billing context. We would define these two views of a client in two separate classes, and they will most likely live in separate applications. In fact, Evans recommends that bounded contexts maintain their separation by giving each context its own team, codebase, and database schema. ‑While this is ideal, in many real‑world apps, we need to work on systems where this level of separation is not present, usually due to resource constraints or for political reasons within the organization. Remember though, if you have multiple contexts, you’ll want to keep them bounded. And one way to maintain this separation is to keep their data, code, and team members distinct from one another, although in real world, I’ve never seen something with that level of separation. ‑Yeah, but I think even if it’s not possible to literally do that with your company and your team, just having that concept in mind really helps in your brain have that idea of separation. ‑I agree. I know that just thinking about the fact that these things ought to be separated and trying to figure out a way to do it means that even if you can’t get to the ultimate level where everything is is completely separate, you can still introduce separations through things like namespaces, separate folders, separate projects, anything you can do to make it clear that these are different contexts that shouldn’t be sharing too much information. ‑You know, I think that’s also really important point about this course in general and DDD in general. For me, it’s really hard to think of all of these things we’re learning as hard and fast rules, like you have to do it this way or you’re not doing it right. I like to see all of this as really good guidance. So, you know, it helps me keep my eye on the prize, and when there’s places where I can’t truly achieve exactly what DDD kind of directs me to do, you know, I’m using my own experience, my own intelligence to make decisions about how to do things, and I’m letting DDD guide me in a lot of scenarios. ‑Sure. And some of these ideals, I think of like 100% test coverage. It’s almost impossible in most real‑world applications to achieve 100% test coverage. But just because that ideal is not something you can ever achieve doesn’t mean that you shouldn’t strive for more test coverage. ‑Yeah, yeah, totally, totally agree with that.\nConversation with Eric Evans on Subdomains and Bounded Contexts When learning about DDD, most of us have a hard time understanding how subdomains and bounded contexts are different. We asked Eric Evans about this and got some great insight. He explained that a subdomain is a view on the problem space, how you’ve chosen to break down the business or domain activity, whereas a bounded context represents the solution space, how the software and the development of that software has been organized. Quite often, these will match up perfectly, but not always. ‑Eric helped us understand this further with the example of a room that you want to cover with carpeting. The room is the problem space, so it’s like a subdomain. You could install a wall‑to‑wall carpet that matches the shape of the room perfectly. This would be like when the subdomain and the bounded context encompass the same thing. But other times you might just use some area rugs to cover the floor, and the area rugs solve the problem. They cover the part of the floor where you walk, and you don’t have to worry about cold feet in the winter. And that’s a scenario where the area rugs are like bounded contexts that don’t match the subdomain, but they solve the problem even though they’re not an exact match to the shape of the room.\nIntroducing Context Maps If your organization has multiple bounded contexts, and ideally these are separated, there can be confusion when the different teams are talking to one another. Again, DDD focuses at least as much on effective communication as it does on anything specifically related to the code we produce. Evans recommends using context maps to visualize and demonstrate to all teams where the boundaries between their context lie. ‑Think about a complex topographical map. It will frequently include a legend, like the one shown here, in order to explain what each of the lines and symbols on the map mean. However, this legend is only valid within the context of the map with which it appears. Trying to use this legend on another map would be confusing at best. ‑A good first step for an existing application is to create a map that shows how things are. Remember that the names of your contexts are also important as you’ll refer to them frequently when discussing different parts of the application. It may be that things are not as separate as they should be, and that’s worth noting. If you have separate teams responsible for different contexts that share resources, it’s important that each team understands which aspects of the application they can change on their own and which are shared dependencies they’ll need to coordinate with other teams to avoid breaking things. If we look at these two sets of concepts, we can see some obvious overlap. For one thing, Client appears in both contexts, but we know that for appointment scheduling we really only care about the client’s name, whereas in the billing system they’ll want additional information like address and payment details. However, although the details involved vary, we know that Mr. Jones, the client on the left, is the same actual person as Mr. Jones, the client on the right. However, we also have a concept of notifications on both sides, and in this case, they’re referring to different things. On the left, we’re talking about sending a notification when an appointment is booked as a reminder, and on the right, we’re talking about notifying the client that their payment was received or perhaps that it’s past due. ‑Especially in smaller organizations, it’s common to have one team responsible for several contexts of the same overall application. In such cases, it’s also common for the team to use a single codebase for the bounded context that they’re working with and store it in a single repository, such as GitHub. Usually, there will also be a shared database. As we’ve already noted, this is not ideal since it makes it much more difficult to maintain the boundaries between the separate contexts. ‑Part of creating a context map involves explicitly identifying its boundaries. If we try to draw the boundaries around these two bounded contexts, we can see there are now several resources that belong to each bounded context. This isn’t ideal if the two contexts really are meant to be kept separate. ‑In the ideal case for a large complex system, we would have bounded contexts like these, with their own teams, codebases, and database. For instance, on the left, we have an appointment scheduler application. It’s being worked on by Team Awesome, and they’re storing all of their code in their own repository called vet‑app‑sched. And, of course, this application has its own database. This team is free to change anything they want with their model or any other part of their system without worrying about breaking anything outside the boundaries for the team on the right, which is working on a billing system, and their team has decided to call themselves Team Ultimate, store their code in a repository called vet‑billing, and, of course, using their own database. By having this separation, this can greatly increase team velocity and reduce integration bugs. ‑Of course, you’re probably wondering how the two systems will interoperate. There are a number of patterns that can be applied to enable this kind of integration. We won’t be covering all of them in this course, but one question that frequently comes up is how to share cross‑cutting concerns like blogging and shared abstractions such as people names that are used by multiple bounded contexts. For this scenario, a common approach is to designate these shared concepts or resources as what we call a shared kernel. Team Awesome and Team Ultimate agreed to share the subset of the domain model. Since they’re sharing it, they also agree not to change it without coordinating with the other team first. Frequently, the shared kernel will either be a part of the customer’s core domain, or some set of generic subdomains, or even both, though it could be any part of the model that both teams require. Using a shared kernel is a tradeoff between code reuse and consistency and the overhead involved in integrating changes to the shared kernel across multiple teams and bounded contexts. It works best when the shared model is relatively stable.\nAddressing the Question of Separate Databases per Bounded Context The concept of having separate databases for each bounded context often throws people for a loop. But with the advent of microservices, which also, by definition, each have their own database, teams are beginning to get more accustomed to the idea. Here’s what Eric Evans said to us when we talked with him about the problems created by trying to share a database across teams. “If you’re in a company where you share your database and it gets updated by hundreds of different processes, it’s very hard to create the kind of models that we’re talking about and then write software that does anything interesting with those models.” Given that sharing a database across bounded contexts is really not a great idea, then we have another important question. ‑Another question that comes up often is how to sync data between the individual databases that are tied to each of the bounded contexts. Some different patterns you can use are publisher/subscriber, commonly referred to as pub/sub, and two‑way synchronization. Pub/sub is definitely simpler and preferable when you can manage it. You can use different implementations like message queues, database processes, batch jobs, or synchronous API calls. It’s really up to you how you want to design your synchronization between bounded contexts. The point is just that you don’t get the integration for free from using a shared database.\nSpecifying Bounded Contexts in our Application We talked with Eric again to get his perspective on defining context boundaries. Some of the key points he shared were that first, it’s important to understand that it’s never a simple task whether you’re new to it or not. And he’s seen stumbling blocks of all sorts. The most common is not having a clear enough context boundary, so the effort of applying DDD isn’t clearly separated from other tasks related to building software. ‑He also reminded us that the bounded context is such an essential ingredient that is probably the biggest stumbling block. And it’s not often one that an individual on a project can usually addressed by themselves. It kind of has to be dealt with at the team level or even the organizational level. In our application, we’ve organized the solution to make it clear where the boundaries are between our contexts. The main area that we are currently focused on is the appointment scheduling bounded context. ‑We’ve identified two other bounded contexts that are involved in the overall application or will be eventually. For instance, it’ll be important for users to be able to manage clients and their patients. The staff of the clinic also needs a way to manage their schedules so they know who’s working on different days. We’re referring to these two bounded contexts as client patient management and resource scheduling. ‑We also have a few parts of the application that are common to several bounded contexts. These are cross‑cutting concerns that we have consciously chosen to share. In DDD, we isolate such code into its own package referred to as a shared kernel, and it’s worth noting that a bounded context does not always mean a separate application, even though we’ve identified several different bounded contexts. ‑It’s also a great opportunity to consider packaging logic up into microservices. Do keep in mind, however, that there’s not always a 1:1 alignment between bounded contexts and microservices or applications. Also, let’s not forget that our application will definitely need a front end.\nUnderstanding the Ubiquitous Language of a Bounded Context We’ve mentioned already that an important part of DDD is an emphasis on effective communication among the stakeholders in the project. And remember, if you’re a programmer, count yourself as one of the stakeholders in whatever you’re working on since you certainly have a stake in its success. The language we use to describe the problem and how we choose to model it is key to the shared understanding we want to have with our domain experts in order to be successful. Having a single, shared, ubiquitous language helps avoid unnecessary confusion and translation within the team building the software and is one of the fundamental practices of Domain‑Driven Design. And when I talk about the team building the software, I don’t just mean the programmers. I mean the whole team, including the business people that are deriving what the software should do. The discovery of the Rosetta Stone allowed us to unlock several different languages by showing the same message in three different texts. We don’t want to have to have a Rosetta Stone or any other sort of tool to help us translate between what the business is talking about and what the programmers are talking about. We want to make sure that everyone is speaking the same language the whole time so that translation is unnecessary. ‑Think about if you’ve ever used an online translation tool to round trip a sentence. You can run into similar communication issues in your application if you’re constantly having to translate to and from the domain expert terms or the programmer’s terms. Here’s an example of a user story for a sample system about creating appointments. ‑We have a lot of developer friends in Nigeria, so I thought it would be fun to try out Igbo for our translation. We used a website to translate between English and Igbo a few times, and in the end, the user story has changed just enough to create confusion. Translation software is pretty good these days, and we were hoping for a more humorous result, but according to animal experts, it’s close, but not the same as a veterinary technician. ‑But the point here, of course, isn’t just relating to different international languages, but to the different languages spoken by business experts and programmers. ‑Incidentally, a great practice when you’re discussing your system requirements with customers is to always try and explain back to them what you think it is they want the system to do so they have an opportunity to correct your understanding of what they think they just told you. ‑Definitely. Remember, one of the key benefits of using a ubiquitous language is that all parties can understand it without having to perform any translation. This means when you show a test or some code to a domain expert, you don’t have to explain that in the system you call something an animal when the domain expert calls it a patient. ‑Evans cautions that a project faces serious problems when it’s language is fractured. When domain experts stick to using their jargon while the technical team members have their own language tuned to discussing the domain terms in the design, translation errors will manifest as software bugs. Neither the customers nor the developer’s language is sufficient for all parties to discuss the application effectively. What is needed is a shared common language that incorporates and uses terms defined in the domain model. The use of this language must be ubiquitous, and the more the language is used, the more will force deficiencies in the model into the open. ‑And by ubiquitous, we mean it must be used everywhere within the bounded context. The vocabulary of the language includes the names of model classes and prominent operations. The team should use these common terms in code, in diagrams, on the whiteboard, in design documents, and especially when discussing the system. ‑Yeah, pretty much ubiquitous means everywhere, all the time. Even in that one email you’re sending off to another developer, stick to using the terms that you’ve agreed makes sense for this bounded context.\nConversation with a Domain Expert: Working on our Ubiquitous Language You’ve heard some of our conversations that helped lead to a ubiquitous language for the scheduling app. There was another important one that happened early on between Michelle and me that we want to share with you now. ‑Pay attention to not only the clarification of the terms, but also to the fact that Julie and Michelle are equal partners in this conversation. Although Julie is trying to lead the conversation towards the goal of identifying the correct terms, she’s careful not to make assumptions about Michelle’s domain. ‑So Michelle, last time you and Steve and I got together to talk, Steve and I have been working on just kind of fleshing things out and planning things, and I realized that we had some confusion over some of the common terms, like things that, as real pet owners, we would kind of assume the terms are, but then when we’re thinking about business and software, we’re thinking of the terms a little differently. So I was wondering if we could just sort that out with you so that we’re all on the same page and using the same terms and using terms that none of us have to stop and think about what we’re talking about. We’ll always know what they mean. ‑Sure. ‑The first thing is we have these clients, those are the people who own the pet. So when thinking about the software and business, we think of them as clients, but kind of in the real world, and me, I have a pet, I go to the vet all the time. I think of myself as a pet owner. So what do you refer to those people who bring the pets, pay their bills, call and make the appointments, etc? ‑Most of the time, I mean those would be listed as as clients. ‑Okay, so you do call them clients. You don’t worry about calling them owners, and of course, it sounds kind of weird to say I own a dog, right? ‑He kind of owns you. ‑Yeah, that’s more like it. You’re the pro you know. So then what about that dog, like are they patients, are they pets, are they clients? What do you refer to the pets as? ‑So for the purpose of the medical record, we refer to them as the patient. ‑Okay. So it would be client and patient. ‑Exactly. And actually in veterinary medicine they talk a lot about this triad, the veterinary client/patient relationship, where all three are really important in that. ‑Okay. So those are actually terms that are commonly used in your industry. Industry, that sounds so weird, but with that. Cool. Alright, so the next one we were also going back and forth on was an appointment or an office visit. When somebody is scheduling a visit, scheduling to come in, how do you refer to that? ‑So there would be two big subsets of what they might be scheduling to come in for. They might schedule a surgery, which is an easy one to define. They’re going to come in, we’re going to do some sort of a procedure. Usually, there is going to be some anesthetic involved. That would be a surgery and that would be outside of our normal office hours. ‑Oh, okay. So what about when they just come in for regular stuff? ‑So when they come in for regular appointments, you could call those office visits or appointments, and there are a few different subsets of those. You may have an appointment that’s a wellness exam, and in that exam, we would be doing, of course, a physical examination and generally wellness treatments like vaccination, some blood work, generally your healthy pet who is coming in for a routine checkup. ‑So that’s an office visit and there is a couple other things that come under the umbrella of office visit, but if I, I’m also thinking about scheduling because that’s the thing we’re really going to be focused on is the scheduling portion of the app. So we’re always scheduling an appointment, an appointment for a surgery, an appointment for an office visit, whatever type of office visit that is, so is using the term appointment, does that make sense? Would you, if if I said appointment would you think that could be a surgery, that could be a checkup, that could be whatever. This thing to be scheduled is what I want to define. ‑Yeah, I mean I think you could call them all appointments, but I would differentiate between the surgery and something that’s done in the office, but then I would further differentiate in the office between a wellness exam, an exam for somebody that’s coming in with a problem, or an exam that doesn’t need to see a doctor, but could just be done by a technician like a toenail trim. ‑Oh good. Yeah, we always need those, clickety‑clack on the floors. Alright, so I think then we’ll use just the overall umbrella of we’ll schedule an appointment and then we’ll be more explicit about what type of an appointment that’s going to be. Would that feel okay to you? ‑Yeah, that makes sense to me. ‑Great. Excellent. Alright, so I’ll get back to Steve and then we’ve got another meeting set up I think in a few days to just hash out some more details after Steve and I’ve gotten some more of our ducks in a row. ‑Sounds great! ‑Excellent. Thanks Michelle. Bye bye. ‑Thank you. Bye. ‑Now we have a stake in the ground for our ubiquitous language. As we continue working with Michelle, not only will we learn more items for the bounded context, but there is also a chance that the ubiquitous language will evolve. Eric Evans guides us to pay attention to those changes because a change in the ubiquitous language is also likely to mean a change in the domain model. We have to update our design to accommodate what we’ve learned.\nReviewing Important Concepts from This Module We’ve covered quite a few concepts in this module. One of the most important ones is just understanding the problem domain and the overall thing that your software is working within. ‑‑And breaking things apart. I know that when I started out, I had a really hard time really understanding differences between the core domain, the subdomains, and the bounded context, especially the subdomains and the bounded context because at first glance, they looked like the same thing to me. ‑‑Sure, it’s really easy to have an application where you have some kind of a concept, like a customer that you know is used by every system that your organization uses. And it ends up becoming this like God object in your database and in your different applications where any given application might only care about a tiny subset of that concept. ‑‑Yeah. So, for me, I think the most important thing is really focusing on the bounded context. Getting down to that and understanding about the boundaries. One thing that helps me a lot is just stating within the context of this and then suddenly like, oh right, that’s what a context is. It’s not like some mysterious new term that Eric Evans invented. He just is leveraging what makes sense. Within the context of appointment scheduling, this is what a client looks like. Within the context of billing, this is what a client looks like. ‑‑Sure, I think that makes a lot of sense. And it’s valuable, even when you have an application, like a legacy application that wasn’t built with domain‑driven design. Let’s go ahead and look at some more terms here. For instance, we’ve got what you were just talking about, I think of as context mapping. And even in a legacy application, it can be valuable to kind of map out what are all the concepts in this application and where are the overlaps with different subdomains that maybe we haven’t even defined in this legacy application. ‑‑Yeah. Even if you’re not planning on making huge changes to it, it’s still really, really helpful to just kind of update your perspective on things. Sometimes it just leads to new understandings. ‑‑I think the shared kernel is a really important part of this, too, because in almost every real‑world organization I’ve worked with, there are different types of cross‑cutting concerns, and we talked about one of them being the authentication piece, and that’s definitely a really common one. But there are usually others too that you want to share. ‑‑Yeah, and, again, it’s another one of those things that sounds like it might be a big, scary, mysterious thing because you haven’t referred to it that way, but if you really just start out thinking of it as the common stuff, but then‑‑‑I think one of the important things, though, is even within the context of domain‑driven design, we have a ubiquitous language because if I say common, you might have a different idea of what I mean by common, but if I say shared kernel, we’ve got an agreed‑upon understanding of what we’re talking about there. So at first, I really kind of pushed back against using these terms because I felt like a lot of the DDD experts were just throwing them around all the time. And then I started really getting a better understanding of why it’s important to use those terms. It’s about‑‑‑it’s the ubiquitous language of domain‑driven design so everybody’s on the same page. ‑‑Yeah, I do agree that that’s an important part of learning about DDD and other areas of software development, like, for instance, design patterns. These things give us these terms that we can use that are very, very dense. If we talk about shared kernel, it would take me three or four sentences to describe what I meant by that. But in these two words, you know exactly what I mean, just like if I talk about using a strategy design pattern, that is much easier to convey than if I were to try and describe it with words and have to draw a UML diagrams to say what I mean. ‑‑And it’s the same, again, with the ubiquitous language because now I really have a better understanding of the fact that what it means is the language is ubiquitous throughout a particular bounded context. When we’re talking about a scheduling app, we’re going to use these terms all the way through, like you were saying before, we use it not just when we’re talking to the domain expert but in our class names, in our methods, it’s just ubiquitous throughout all of the pieces of the things that are involved in that bounded context from one end all the way to the other of it. ‑‑And I think as we’ll see when we look at the code again, some of the constructs in .NET, like namespaces, are really appropriate to ubiquitous language because when you prefix that same term in your code with a particular namespace, that tells all the other programmers that if I say SchedulingApp.notification, we know that that has a different meaning that if I’m talking about EmailReminder.notification. ‑‑Or SchedulingApp.client versus Billing.client. ‑‑Exactly.\nReview and Resources In this module, we learned about our domain, in this case, a veterinary practice. We talked about it at length with a real live domain expert and identified the core elements of our domain model. We identified a variety of subdomains and focused in on the key area that we would be addressing first with our application. ‑We spent some time designing the system based on our conversations with Michelle, identifying boundaries between different contexts, and noting how sometimes the same object with the same name might mean something different within a different context. ‑Finally, we talked about the importance of communication in general and in particular having a ubiquitous language. We know that Domain‑Driven Design can help us avoid many design errors and wasted time miscommunicating as we work on a complex project. ‑Steve and I are so grateful to Eric Evans for spending time with us while we were creating this course in order to share his luminous advice and insights. In the next module, we’ll drill into the domain model so you can have a good understanding of its critical elements. ‑This is Steve smith, ‑and this is Julie Lerman. Thanks again for watching Domain‑Driven Design Fundamentals.\nElements of a Domain Model Introduction and Overview Hello, this is Julie Lerman, ‑and this is Steve Smith. ‑In this module, we’re going to focus on the elements of a domain model which are in our bounded context. ‑You’ve seen these in the mind map. It’s patterns like entities and aggregates and more. ‑You can find me online at ardalis.com or on Twitter as @ardalis. ‑And you can find me online at thedatafarm.com or on Twitter at @julielerman. ‑In this module, we’ll focus on the technical aspects involved when modeling a bounded context. We use these terms while modeling, and these same terms refer to patterns we’ll use when we code. The concepts flow through the entire process, which is great. You don’t have to keep switching hats or mindsets. ‑We’ll start by grounding ourselves in the domain and understand why it’s important to stay focused there. DDD models are driven by behaviors, not classes and properties. This is another very cool shift in thinking for those of us who have always focused on objects. Then you’ll learn about some terms used to describe domain models, rich and anemic. You learn what the terms mean at a conceptual level and what the code that they’re describing looks like. ‑Entities are the key types in your system, but not every type in your system is an entity. ‑You’ll learn how entities fit into DDD, how to differentiate entities that have complex needs from simpler entities that might only need some basic CRUD logic, and you’ll be able to see how we’re implementing all of these concepts in our code.\nThe Importance of Understanding DDD Terms Domain‑Driven Design is filled with lots of specific terms. Much like the ubiquitous language that we use to make it easier to communicate while working within a bounded context, understanding and using the terms of DDD makes it easier to talk about the process. We’ll spend the bulk of this module focusing on some of the concepts behind modeling bounded contexts, concepts that are critical to this process, but, unfortunately, often misunderstood. ‑I’ve definitely had my challenges with some of the DDD concepts. Some of my issues were because the terms overlap with other technologies I use. For example, I do a lot of work with Microsoft’s ORM called Entity Framework. Entities are a key element in Entity Framework, and they’re also a key element in DDD. So I thought my understanding of entities from Entity Framework was enough to translate to DDD entities, but it really wasn’t, and my less than solid grasp on DDD entities caused problems when I was trying to model domains and implement the model and code. We also have the concept of a context in Entity Framework. While the real goal of that context is to provide interaction with the database, it also does provide a boundary around a model. But it’s very different than the concept of a bounded context, and that definitely confused me for a while. Another important element in a DDD model is value objects. These got me pretty confused at first, and my ego was saved by discovering that others have also been confused by value objects. But I’ve worked on my DDD education and sorted these problems out, so in this module, it’s really important to both Steve and I that you start off on the right foot with a proper understanding of entities, value objects, and some of the other DDD puzzle pieces so that Domain‑Driven Design can help you with your complex problems, not complicate them even more.\nFocusing on the Domain It’s important to remember that first D in DDD stands for Domain, and yeah, the other two Ds, Driven and Design. But we really want to focus on Domain here. ‑By now, you’ve probably heard us talk about this plenty, but both Julie and I find that we constantly have to remind ourselves to focus on the domain. We hear ourselves begin to talk about the user interaction with the app and have to ask, well, what part of the vet clinic domain is this user? Yeah, obviously we care about the user and how the actual application will work from their perspective, but that’s for another conversation, and we have to draw ourselves back to focusing on modeling the domain. ‑I have quite a long history with data access, and I catch myself worrying about how our domain model will translate to the database so that things definitely get persisted correctly. That’s when Steve needs to give me that look, you’re doing it again, Julie, and I have to bring my focus back to the domain of the vet clinic again. So while it may seem redundant to harp on domain, domain, domain, this diligent focus will help you avoid the complications and distractions that come from thinking outside of the domain or the subdomain that you’re focused on. ‑Here’s an important quote from Eric Evans’ book about this focus on the domain. “The Domain Layer is responsible for representing concepts of the business, information about the business situation, and business rules. State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure. This layer of the domain is the heart of business software.” ‑Just to reiterate, the domain model is the heart of the business software. This is the whole point behind Domain‑Driven Design. Focus on the domain, not the technical details of how the software will work. ‑In a typical database‑driven app, we’re used to focusing on properties or attributes of classes. Our apps sometimes become all about editing property values and the state of our objects. However, when we are modeling a domain, we need to focus on the behaviors of that domain, not simply about changing the state of objects. ‑Michelle didn’t talk to us about setting the name of a dog or editing the time of an appointment. She told us that she needs to schedule an appointment, and when she does that, she needs to book a room and create a schedule item on a doctor’s calendar as well. So scheduling appointment is a lot more than setting the attributes of the objects involved, the appointment time and identity of the pet we’re making the appointment for. We’re talking instead about how the system behaves. In response to scheduling an appointment, the system should also book a room and do something to the calendars of the doctor and any vet techs that might be involved.\nIdentifying Events Leads to Understanding Behaviors An important way to identify behaviors in your system is by focusing on events. Doing so gives you a great path to understanding the behaviors of your domain. Alberto Brandolini devised a great way to brainstorm with clients, which is referred to as event storming. It begins by having a somewhat chaotic brainstorming session with a good number of domain experts writing events on Post‑its and sticking them on a wall. The format of what they write is in the past tense. For example, an appointment was booked, a client contacted the office, or a dog was weighed in. I facilitated quite a few event storming workshops with clients, and I’m a big fan of using this process to help get a picture of the domain, discover bounded contexts, and even discover key problems that should be addressed. Another interesting methodology for modeling a system based on events is called Event Modeling. Adam Dymitruk came up with this workflow and has had great success using it to help teams collaborate on learning about the domain and designing the flow of software. I was fortunate to participate in a three‑day workshop with Adam to learn about Event Modeling. We won’t be teaching you about event storming or Event Modeling in this course, those are beyond the scope of our goals here, but we did want to be sure you were aware of them. You’ll find links for more information about event storming and Event Modeling at the end of this module.\nComparing Anemic and Rich Domain Models In order to understand the difference between design that’s focused on attributes versus design focused on behaviors, it will help to understand two commonly‑used terms in domain‑driven design, anemic domain models and rich domain models. An anemic domain model is a domain model that is focused on the state of its objects, which is the antithesis of DDD. While the term is somewhat negative indicating a deficiency, you don’t need to perceive it that way. There is nothing wrong with anemic classes when all you need to do is some CRUD logic, but if you are creating a domain model, you’ve already made the decision that your domain is too complex for simple CRUD. So anemia in a domain model is considered an anti‑pattern. ‑Martin Fowler writes about anemic domain models with such drama that you may never mistakenly use them in your domain model. He says the basic symptom of an anemic domain model is that at first blush it looks like the real thing. There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have. The catch comes when you look at the behavior and you realize that there is hardly any behavior on these objects making them little more than bags of getters and setters. Indeed, often these models come with design rules that say you are not to put any domain logic in the domain objects. Instead, there are a set of service objects would capture all the domain logic. These services live on top of the domain model and use the domain model for data. ‑What we aim for then is rich domain models, not anemic domain models when we are modelling our domain. Rich domain models will represent the behaviors and business logic of your domain. Classes that simply affect state are considered an anti‑pattern in a domain model, and therefore, get the nasty label of anemic, even though they are perfectly fine in a CRUD model. Martin Fowler doesn’t mince words when it comes to anemic domain models saying the fundamental horror of this anti‑pattern is that it’s so contrary to the basic idea of object‑oriented design, which is to combine data and process together. I have to say I agree and I’ve worked with many teams who have had to deal with the self‑inflicted pain of treating their domain entities like DTOs lacking any encapsulation or behavior. That can work for simple CRUD apps, but it’s often a disaster in a DDD model. ‑While Martin Fowler and other DDDers have strong words to say about anemic domain models, we’d like to share a gentler message, which is to strive for rich domain models and have an awareness of the strengths and weaknesses of those that are not so rich.\nUnderstanding Entities Even though a DDD app is driven by behavior, we still need objects. DDD expresses two types of objects, those which are defined by an identity and those which are defined by their values. We’ll focus first on the objects that are defined by their identity. These objects are called entities. ‑An entity is something we need to be able to track, locate, retrieve, and store, and we do that with an identity key. Its properties may change, so we can’t use its properties to identify the object. If you’ve done any type of data persistence in software, you’re probably pretty familiar with entities and their keys. When we are modeling a problem, we can talk about entities without having to think about how they are implemented in the resulting software. But when it is time to start coding, there are patterns to follow to ensure that these objects have the technical attributes of Domain‑Driven Design entities. ‑As you can see from this section of the DDD navigation map, entities are pretty integral to our software. So, before we can learn about these other elements, domain events, repositories, factories, and more, you should have a very good understanding of an entity. ‑The most important entity in our model is Appointment. This is what we will be creating, editing, and retrieving in the context of scheduling appointments. Appointment inherits from a base class we’ve created called Entity. We’ll look at that more in just a bit. Notice that all of the classes shown here are inheriting from the identity base class. However, although the other classes are entities, after our discussions with Michelle, we came to the conclusion that we would like to have a separate utility for managing client and patient information and to manage information about staff and staff scheduling. Thus, we don’t need very much information or behavior related to these collaborating entities within the bounded context of appointment scheduling.\nDifferentiating CRUD from Complex Problems that Benefit from DDD ‑Let’s take a closer look at that data that supports scheduling appointments in our system. ‑We determined that managing the client, patient, and staff information, which is external to this model, was well‑suited to just simple CRUD. We didn’t identify complex rules or behaviors for creating and editing that data. Thus, the concepts of doctors, rooms, clients, and patients are managed outside of the scheduling bounded context. ‑For comparison, look at the CRUD classes for Patient and Client in the other bounded context. They’re very simple. They don’t inherit from our entity base class, and most interestingly, their ID properties are integers. We’ll let the database assign the IDs when we create these classes. So these classes are not designed using domain‑driven design. Now let’s go back to the appointment scheduling context. The client, patient, doctor, and room classes here are completely different from the CRUD classes we just saw. However, they do have a subset of the same fields from those CRUD classes. All we need to know about these objects when we’re scheduling is their IDs, their names, and maybe a few other details. But here, they’re simply used as look‑up data, and they’reread‑only.\nSwitching Between Contexts in a UI Even though our domain is split up into a number of bounded context, the user interface can be designed in a way that moving from one context to another is seamless to the end users, they don’t need to know that these things are in separate bounded contexts. While maintaining client and patient data is a completely separate task from scheduling appointments, Michelle wanted to be sure that anyone working at the front desk is able to easily move between these tasks in the software without disrupting their workflow. So let’s say the person at the clinic who does the scheduling is on the phone with Kim and about to make an appointment for Roxy to come in, but then the other line rings, they put Kim on hold, and it’s me. And in the nicest way possible, I’ve called to just let her know they’ve got my last name spelled wrong. That happens all the time. People just want to put that h in there. Even though they’re in the middle of scheduling and scheduling has its own backend, its own bounded context, and is totally separate from client management, they can still drive the app right over to the Client Management area and very quickly fix my name and save that. Then they can just flip back to the schedule. Notice that Kim is still the active scheduling client that’s showing up in the left‑hand corner and the change to the spelling of my last name is already visible on the schedule. And so now that person can go ahead and finish up with Kim scheduling the very adorable Roxy for a wellness exam. To the user, there is no real difference between doing the scheduling and doing the client management, it’s just a nice smooth flow between the two, it doesn’t feel like, oh, now we have to open up a different application in order to do this other thing and doesn’t break everything they’re in the middle of, but for the purposes of designing our application, everything is bound within its own individual context. And when designing this context, we don’t have to worry about switching from one context to another. ‑So remember, we’re talking about what makes these all entities. An appointment object needs to be located and tracked and we need to be able to edit them easily. Using a unique identity allows us to persist and retrieve an appointment even if some of its values change. Appointment is definitely an entity in our system. We actually had to think a little more about client, patient, doctor, and room in this particular context. Our discussions highlighted the fact that when creating appointments, we only need access to some of the high‑level information about the client, patient, doctor, and room, but these objects won’t be edited. So we wanted these stripped down read‑only types that give us minimal amount of detail for each. We do still need to be able to uniquely identify them though, they do have some identity. If the client’s name changes, a change we would make in the client management system, that new name will need to be reflected when we look at the appointment scheduling for that client. There should only ever be one record to represent a particular client in this bounded context. So client and the other types that are reference types in this context are still entities. We triple checked our decision with another kind of domain expert, Vaughn Vernon, a DDD expert, and we were happy to get his thumbs up on this particular decision. So Julie, Michelle, and I also talked about how to name the types that are simply reference types in this particular bounded context. At first, we were worried that we might get confused by having different definitions of client, patient, doctor, and room. We wanted to call them client details or client view or something like that, but thanks to the ubiquitous language, the fact that we are in the scheduling context drives our comprehension of what a client means in this particular space. ‑A client in scheduling is still a client, so we use the same name, even though it’s a differently defined pipe than the client we work with in the Client/Patient Management app. ‑Right, and thanks to namespaces in our code, we’re able to keep it clear which ones are which in the code.\nUsing GUIDs or Ints for Identity Values So, all these types inherit from our base entity class. However, notice that those reference types use int for their base entity’s ID and not the GUID that’s used by appointment. That’s because all of the management of those other types happens to be done using CRUD, and with CRUD, it’s easy to just use database‑generated ints. Appointment is built using DDD principles, and you’ll see that it’s much easier to use GUIDs when building DDD entities and their related logic rather than relying on the database to provide the identity values. Not only is it easier, but it follows DDD principals more clearly, since we will build all of our domain logic around appointments without involving the database. We would have a hard time working with appointments in our model and in our unit tests as we develop the application if we always needed a database to assign their IDs. ‑So that’s not to say that you can’t use integer IDs If you’re going to use a DDD style of application; it just makes it a little harder. Wouldn’t you say, Julie? ‑Yeah, yeah, and I’ve definitely come up against that. With the stuff that I do with Entity Framework, I’ve made sure that I show patterns for continuing to use the database‑generated ints because I didn’t want to give people the impression that they had to throw away, like, for me like 25 years of this dependency. And like all of a sudden I have to go cold turkey and move over to GUIDs. ‑Sure, I mean, there’s trade‑offs in what you choose to use for your ID, but having an ID that we can generate in the client and just in our code has a lot of value. ‑Every time we’ve been working on some of our different unit tests and we needed as part of the test to instantiate something that was an int, we were like, ugh, now we have to find another way to get that in there because we were protecting it and it was a problem. As our own experience grew, we realized there’s another way to bridge this conflict by using both GUIDs and database‑generated ints in an entity. This way, while creating objects, you’ve got the control over key generation with the GUIDs, and they’re not depending on the database. However, once the data has been created in the database and int keys exist for it, then you can benefit from those when adding indexes and performing queries in the database.\nTalking with Eric Evans About the Responsibility of Entities We talked with Eric Evans to gain some additional insight into entities. Specifically, I asked him how entities align with the single responsibility principle. ‑‑If you’re not familiar with this object‑oriented programming principle, you can learn more about it in Steve’s SOLID course right here, on Pluralsight. ‑‑One of the questions that I’ve heard is, What is the single responsibility for an entity? Or to put it another way, does having an entity that has a lot of business logic in it violate the single responsibility principle? ‑‑Eric told us that entities are very central, and so it’s natural that they get heaped up with lots of functionality. ‑‑But there’s a downside to this. As you build out the system, there are more and more conflicting demands for these central entities, so they end up being huge. Evans said that the main responsibility is the identity and the lifecycle. ‑‑Eric also told us that single responsibility is a good principle to apply to entities, and it points you towards the sort of responsibility that an entity should retain. Anything that doesn’t fall into that category, we ought to put somewhere else.\nImplementing Entities in Code Let’s take a look at an entity in our veterinary appointment scheduling application, FrontDesk. We’re going to look at the Appointment class, which defines all the information that we need to schedule an appointment for a particular animal or patient. It associates the patient with the doctor, room, and appointment type, and also includes the start and end time for the appointment. Now, the Appointment class inherits from BaseEntity, which is a generic base class. In this case, it’s BaseEntity, as you can see here. The GUID is defining the type of our identity property, our ID. ‑Right. And we talked about that earlier when we were looking at the structure of the different entities in this model. We wanted Appointment to have a GUID because we’re creating new appointments on the fly. So, let’s take a look at that BaseEntity class. First of all, it’s an abstract class. So we can’t just create a BaseEntity object, we have to create something that is a BaseEntity, such as an appointment. And using generics, we’re saying that the BaseEntity is going to use whatever type we ask it to, and that type is for defining the ID. So for Appointment, we said BaseEntity is going to be using a GUID as its identity. I mentioned this earlier, why I would need GUID for appointment in this context because I need to be able to create new appointments in this context, and I’m not going to be waiting for the database to generate the ID for me. So using a GUID lets me create that ID right up front as I’m creating that new appointment. So I’m giving it its ID. The BaseEntity class also has a property to hold a list of domain events that will define explicitly for each of the types that inherit from this base entity. You’ll learn more about domain events further on in this course. ‑All right, so let’s take a look back at the rest of Appointment. Now, since Appointment has more behavior than just state, we don’t want to have it just be a bag of properties that our application can get and set however they would like. ‑Because that would be an anemic domain model. ‑Yes, because that would tend to lead us toward a more anemic domain model. ‑And we want a rich one. ‑Now, in particular, we’re also constraining how we create this appointment. We want to ensure we create appointments in a valid state, so that means passing in the minimum necessary elements an appointment needs to have. Sometimes we’ll want to update an appointment. Remember, these aren’t value objects. They’re not immutable, so we can change them. When we need to modify an appointment, we’re going to do that through methods. And so, for instance, if we decide we want to modify what room an appointment is scheduled in, we’re going to do that through a method rather than just a setter. We do this because there’s additional behavior we may want to do. In this case, we have some guards, again to ensure a valid value is being passed. ‑These guards are a set of reusable functions that you’ll find in the shared kernel of our solution. ‑And we also want to raise an appointmentUpdatedEvent, that we might handle and send a notification or perform some other action as a result of what happened. ‑And that also gives us the flexibility in the future to change what type of logic we want to trigger. ‑And that’s something we can’t do very easily If we just let anybody in the application set the value. ‑Right. ‑By providing a method to use to update room explicitly and otherwise making the setter private, we force all interaction with the model to use this method, which gives us just one place to model behavior that should be associated with this operation. It’s the same as with the constructor, we need to do our best to keep our domain model in a consistent state so the rest of the application can count on it being correct. ‑Right, because otherwise somebody could satisfy the requirement that they pass in the room ID, but they might pass it in as 0, which would be invalid. So, we’re further constraining that they don’t do that either. The appointment would be invalid if it had a room ID that didn’t correspond to an actual room entity. And in any case, the database wouldn’t let that fly since there’s a foreign key relationship between appointment and room. ‑Yes, but we want to make at least some effort to catch such problems in our code, rather than relying on the persistent store to inform us of a user error. Overall, using guard clauses, like the ones you’ve seen here, help us ensure our entities aren’t partially constructed and inconsistent. Once we’ve created an appointment, we need to record it as part of the clinic schedule, which involves some additional rich behavior. So, if we scroll down to the bottom, we have this method called Schedule. And this is where we’re going to do the additional work involved with actually saving an appointment and ensuring it fits in with other appointments that have already been scheduled. We’re not going to worry about the code at the moment, but the idea is that this method would query the database for other appointments that might be near this one and make sure there is an available slot in the schedule that this one fits into. Then it will save the appointment and raise an event, letting the rest of the app know that a new appointment has been scheduled. In the next module, we’ll investigate this design further and revise it a little bit. Now, let’s look at one more simple entity that this bounded context needs, the Doctor class. You can see that Doctor inherits from BaseEntity as well, but in this case it’s using an int for its key. The only other property it has is a string Name property. ‑This is a minimal implementation of the Doctor type that satisfies the scheduling bounded context. It’s essentially no more than a reference type. Doctor and the other similar types, Patient, Room, etc., are all organized into this folder called SyncedAggregates.\nSynchronizing Data Across Bounded Contexts Let’s dig a little more into how these reference types in the scheduling bounded context are getting their data from the Clinic Management app, especially if the two BCs aren’t sharing a database. If you recall from seeing the class descriptions of all of these classes, the AppointmentType, Client, Doctor, Patient, and Room, we had explicitly decided that these are reference entities where we’re actually doing their maintenance elsewhere so they’re not adding any unneeded complexity to the Front Desk application. ‑‑Right. And they’re just READONLY. So we’re never having to create or modify them. ‑‑And we’re using the ints that were created by the database when we persisted these with a CRUD context in a different application, but there are still entities here, just entities of type integer. The Clinic Management bounded context is responsible for updating these types. When changes are made, application events are published by Clinic Management, and this Front Desk bounded context subscribes to those events and updates its copies of the entities. ‑‑One of the questions we get all the time when we describe how bounded contexts have separate databases is, How do we synchronize changes between these two apps? This is one of the simplest and most common approaches. One app is responsible for updates, and the other apps just subscribe to the changes and are notified when they occur. ‑‑This is an example of eventual consistency. The two systems aren’t immediately kept in sync using a transaction or something similar, but through message queues, eventually the different bounded contexts are updated to the new state when a change is made.\nReview and Resources We’ve covered a lot of ground in this module and you’ve learned a lot of new terms, so we just want to review some of them with you before we move onto the next module. The first is a pair of terms that often go hand in hand, anemic domain models versus rich domain models. And remember the anemic domain models, while often looked down upon from the perspective of DDD, they’re perfectly fine for CRUD. These are models that look a lot more like a database schema than a class that has lots of methods and rich behavior in it. On the other side of that is a rich domain model, which is what we strive for in domain‑driven design, and that’s a model that really is focused on behavior, not just changing the values of properties. ‑Then we talked about entities and entities tend to be one of the core pieces of our domain model. The key thing that distinguishes an entity from other types in our model is that it has some kind of identity that we can use to track it over time and to bring it in and out of persistence. This module provided you with your first look at implementing a bounded context in code, an important part of tactical design. You learned about the difference between anemic models and rich models, and that while anemic models have their place, focusing on behavior with rich domain models is how DDD lets us solve complex problems. Entities are the classes in our domain models that are tracked by an identifier allowing us to build graphs and eventually persist and retrieve that data. ‑Sometimes we are working with entities whose behavior and rules are critical to the bounded context in which we’re working. Other entities may only provide supporting or reference data. You learned how to help identify the differences between them. Then you got to look at the appointment class in our scheduling app to see how we have applied rules and behaviors in that entity. You also looked at one of the reference entities and learned how we use message queues to ensure the reference and the data that is maintained in the clinic management app is made available to the scheduling bounded context, even though they do not share a database. ‑In the next module, we’ll focus on some more important elements of a domain model, value objects and domain services. We’ve referenced a lot of interesting and helpful resources in this module and here are two pages of links for you to follow up with if you want to dig in a little further, including Steve’s Pluralsight course on SOLID principles of object‑oriented design and information on event storming and event modeling. This is Julie Lerman ‑and this is Steve Smith, and thanks for watching our course, Domain‑Driven Design Fundamentals.\nUnderstanding Value Objects \u0026 Services in the Model Introduction and Overview Hello! I’m Julie Lerman. ‑And I’m Steve Smith. Welcome back to Domain‑Driven Design Fundamentals. In this module, we’ll continue exploring the elements of a domain model as we dig into value objects and domain services. ‑Value objects are a confusing concept. So we’ll begin by looking at where they fit into the mind map and introducing what makes an object a value object, and how they relate to entities in a model. ‑We’ll share some more guidance from Eric Evans and Vaughn Vernon, and then show how we’ve implemented value objects in our code. ‑Next, you’ll gain a high‑level understanding of domain services, and solidify that by exploring their features, and then some examples of domain services.\nGetting Acquainted with Value Objects When introducing entities, Steve and I talked about objects that were defined by a thread of continuity and identity, not defined by their values. So, what about objects that are defined by their values? These are called value objects, and they play an equally important role in a domain model, as entity objects do. ‑A value object has very specific characteristics. It is an object that is used to measure, quantify, or describe something in your domain. Rather than having an identity key, its identity is based on the composition of the values of all of its properties. Because the property values define a value object, it should be immutable. In other words, you shouldn’t be able to change any of the properties once you’ve created one of these objects. Instead, you would simply create another instance with the new values. If you need to compare two value objects to determine if they are equal, you should do so by comparing all of the values. Value objects may have methods and behavior, but they should never have side effects. Any methods on the value objects should only compute things; they shouldn’t change the state of the value object, since it’s immutable, or the system. If a new value is needed, a new value object should be returned. Don’t confuse the value object’s pattern with C# and .NET support for value types and reference types. Custom value types in C# are defined with structs, while reference types are defined as classes. In DDD, both entities and value objects are typically defined as classes. Classes have advantages over structs when it comes to encapsulation and support for inheritance‑based extension and reuse.\nRecognizing Commonly Used Value Objects To help you better understand the basics of value objects, let’s take a look at some value objects that you probably use all the time as a developer. The most commonly employed value object is a string. In .NET and many other languages, a string type is immutable, and you now know that immutability is one of the key attributes of a value object. A string is a collection of characters, and the combination of all those characters give that string meaning. For example, C‑A‑R in English, a car. If a string were mutable, we could change the R to T. Now the string is C‑A‑T, a cat, which has a very different meaning than a car. Or we could add a letter, maybe put an S in front of it, turning CAR to SCAR, also completely changing the meaning of car. But it’s not just the array of characters that gives a string its meaning, the order of them is also critical. Just think of the word dog, d‑o‑g. Shifting its letters around gives us something with a very different meaning. ‑So one of the things that .NET makes it really easy to do is to modify strings, like you can change the length of it or make one all upper case. But when you call, for example, ToUpper on a string, it doesn’t just change that string object, it gives you a new instance of a string that now has all uppercase characters. ‑Many developers say that monetary values in financial systems have been perfect candidates for value objects in their system. And Ward Cunningham provides us with a really helpful example, a company’s worth. If a company is worth 50 million dollars, that means something, 50 million dollars. It’s a very specific measurement. Fifty million on its own is not a measurement, it has no meaning without the unit, which in this case is dollars. But dollars alone doesn’t describe worth either. In fact, dollars doesn’t really help, does it, because is it US dollars or Canadian dollars, Australian dollars? It only makes sense when you put the two together as 50 million US dollars. There’s actually one more factor to take into account, is the point in time of this 50 million dollars because of the way financial systems work and the fluidity of monetary values. ‑We could still just have the two properties in this Company class, but by creating a value object you also protect and constrain the measurement. For instance, we might have a class called Company. It might have one decimal property that represents the worth amount and another string property that represents the worth unit. The problem with this approach is that it doesn’t tie these properties together in any way. These two properties appear to be independent of one another, but they’re obviously closely related. If an update is made just to the Worth Unit string, it could obviously have a tremendous impact on the company’s worth as a combination of these two concepts. Fifty million rupees has a very different worth than 50 million US dollars. To ensure nobody can set the unit without also specifying the amount, a separate value object can be introduced to represent the entire worth concept. This ensures the entire object must be updated as a whole. Since the worth type is immutable, the only way to make updates to the Worth property on the Company class is by replacing the whole instance with a new one, not just changing an isolated field. ‑A value object is not always for a measurement though. It can be another type of description. Eric Evans calls out dates as a great example for value objects. I’ve used this one often, DateTimeRange, and it was perfect for the vet appointment scheduling app. We usually set a start and an end time together and can’t really set one without the other. Also, we often need to pass the two values, start and end time, around from one method to another. So we’ve encapsulated them in a value object called DateTimeRange. The properties have private setters, which makes the object immutable since we can’t change them. We aren’t showing the full logic of the class here, but when we look at the value objects in our application you’ll see more of how we implement a value object in our software to ensure that it meets all of the attributes, not just immutability, but how we handle equality, comparison, and other logic.\nGetting More Insight from Eric Evans and Vaughn Vernon In his book, Implementing Domain‑Driven Design, Vaughn Vernon recommends that we should try to use value objects, instead of entities, wherever possible. He says, it may surprise you to learn that we should strive to model using value objects instead of entities wherever possible. Even when a domain concept must be modeled as an entity, the entity’s design should be biased towards serving as a value container rather than a child entity container. What this means is that you’ll find that your design will have a number of entities who have very little logic of their own or very few primitives as their properties, but instead will have a number of properties that each are themselves a value object. ‑So he’s not saying everything should be value objects, but that it’s probably our natural instinct to start by thinking of things as entities and then maybe once in a while go, oh, maybe that should be a value object. So what Vaughn is suggesting is really start by thinking every time should this be a value object and you will surprise yourself at how many times something that you originally might have thought of as an entity really does make a lot more sense as a value object. ‑Or sometimes when you’re looking at an entity, there might be a couple of properties that seem to always go together, you might be able to bundle these properties into a single value object. It’s interesting to note that identity values can be treated as value objects as well. In many systems, entities have a primitive type, usually int or GUID as their ID, but this means that it’s easy to substitute a client ID for a patient ID if developers are not careful. By creating actual value objects for client ID and patient ID, which can still be stored as ints or GUIDs, it can eliminate this kind of error from our design. ‑Here is an example of a Client class that’s inheriting from base entity, but specifying that the type will be ClientIdValueObject rather than a scalar type like int or GUID, that’s followed by a service class that has a CreateAppointmentFor method which takes a clientId and a patientId. If those IDs were both GUIDs, the runtime code would allow you to accidentally pass them in in the wrong order because the signature is only constraining that you pass in two GUIDs and that could create a big problem when you’re trying to build an appointment. But with the specialized value objects, you can tightly constrain the parameters to avoid this problem rather than adding a lot of extra logic elsewhere to protect you from making that mistake. For me, this highlights the beauty of DDD thinking. With this little bit of upfront work, you’re removing the complexity of solving the kind of problem that could be created by accidentally transposing the client id and patient id. In our conversations with Eric Evans, we asked him for his thoughts on putting logic into value objects. He told us that he thinks value objects are a really good place to put methods and logic because we can do our reasoning without side effects and especially the complications that identity brings along, all those things that make logic tricky. We can put functions on those value objects and then do the pure reasoning right there in the value object. ‑Eric also called out date libraries as a good example of a value object. They perform common functions on dates so we don’t have to keep coding them ourselves in our entities or services. For example, a date library could be used for calculating a person’s age from their birth date. As long as the library causes no side effects to the date in question, it can work well as a value object.\nImplementing Value Objects in Code Our primary demo involves scheduling appointments. Appointments have a start and an end time. These two things always go together, so they make sense to extract as a value object. Here’s a closer look at the DateTimeRange ValueObject we created for the course’s demo. We also have a DateTimeOffsetRange, which is identical, but includes support for time zones. Because DateTimeRange is a pretty low‑level concept that could be useful in a number of different applications, it’s implemented in the shared kernel package. The class inherits from a ValueObject base class that provides flexible equality checking behavior, so we don’t need to clutter our class with overloads for Equals, GetHashCode, et cetera. It was written by fellow author and DDD expert, Vladimir Khorikov. ‑Because this is a ValueObject, you can see that all of its properties are read only. Recent versions of C# and Entity Framework Core do allow us to avoid even having a setter in there when we want to define read‑only properties, and we also now have the use of records in C#. EF Core can comprehend read‑only properties that don’t have any setters at all, and it takes advantage of fields. But here we’ve written our value objects in a more generalized way that’s not taking advantage of any specific or specialized features. However, you can adapt these samples to benefit from those specific APIs and language versions that you’re working with. The important goal here, though, however you implement it, is that the state of the value object should not be changed once it’s been created and as part of the domain model. ‑Right. Value objects should get all of their state through their constructor, and any invariants that need to be checked should happen in a constructor as well. In this case, the date time range is guarding against having a start time that exceeds its end time. If it does, an exception will be thrown. The second constructor that takes a timespan calls the first one using constructor chaining, so in either case, the guard will always be enforced. Since the DateTimeRange is immutable and cannot be created in an invalid state, the rest of the domain model can count on it being valid. ‑Our DateTimeRange type does have some additional methods that let us create new DateTimeRange instances from existing ones, much like the DateTime type provides options to create new date times by adding time to an existing instance. In our type, for example, to change an appointment set to end at 10:30 instead of ending at 11:00, a new instance of DateTimeRange can be created using the newEnd method. Finally, the base ValueObject class requires overriding a GetEqualityComponents method. This is used when comparing two instances of the ValueObject, and it’s up to you to decide which properties should or shouldn’t be included. In the case of DateTimeRange, the start and end times are sufficient. If two DateTimeRange instances have the same start and end values, they should be considered equal. ‑Custom logic needed to determine whether one appointment overlaps with another is another area where the ValueObject can help. The whole appointment isn’t needed to determine if there is an overlap in appointments. Only the DateTimeRange is used in such a calculation. Thus, the Overlaps method, shown here, has been moved out of the Schedule and Appointment classes and into the ValueObject, where it is more reusable, and it reduces the complexity and responsibilities of the other domain types. ‑We asked Eric to share his thoughts on moving logic out of entities into value objects. He agreed that it’s a good idea. What he said was if there’s logic that’s really the classic software logic, I like to add that in value objects. You can really test value objects much easier than entities, and you can use them much more freely. So your entity becomes this critical piece of glue, an orchestrator among different value objects. But that doesn’t mean that you won’t have some logic in the entity. It’ll just be very concise. ‑Eric also said that it’s a nice way to work towards the ubiquitous language to the point where you look in the methods of the entity and you see higher‑level things. They read like use case level communication, rather than nitty gritty detail. My personal takeaway from this is to keep an eye on the properties of your entities, and specifically, their types. If you find that they’re all primitive types, like ints and strings, think about if any of those primitive things could be grouped together as value objects instead. Another value object that we can point out here is the AnimalType. This is just to give you an idea that our value objects can be extremely simple. In this case, AnimalType is just a combination of the species and the breed of a particular pet or patient that we’re dealing with at the vet clinic. And there’s not a whole lot of other behavior here. But it does provide us with a container by encapsulating these two related properties together as a single value object.\nUnderstanding Domain Services When an operation is important to the model but doesn’t necessarily belong on any one entity or value object, a service is often appropriate. But don’t be too quick to give up on finding a natural home for the operation on an existing entity or value object or you may end up with a very procedural anemic model. Frequently, domain services serve as orchestrators for operations that require several different collaborating entities or value objects. Evans notes that good domain services must first and foremost not be a natural part of an existing entity or value object. Again, we don’t want to shift all of our rich behavior from our entities and value objects to our services. Services should also have a defined interface that’s comprised of domain model elements. And finally, domain services should be stateless, though they may have side effects. What this means is we should always be able to simply create a new instance of a service to perform an operation, rather than having to rely on any previous history that might have occurred within a particular service instance. But of course, the result of calling a method on a service might result in changes to the state of the system itself. These rules apply specifically to domain services which belong in the core of our application. Your software will likely also use services to perform work related to infrastructure or as part of the front end of the application. ‑Here are some examples of the kinds of services we might find in different layers of a DDD application. The UI layer represents the front end of the system and should have as little business logic as possible. It is frequently combined with the application layer, which should be concerned with behavior necessary for the application, but unrelated to the customer’s problem domain. For example, the application may need to work with file formats or parse some XML, and it might have services for these purposes, but these are unrelated to the domain. In the core of the application where we store our core model and domain objects, we will define any domain services for operations that don’t belong somewhere else. These services will frequently involve operations on multiple domain elements or may be responsible for orchestrating some kind of workflow. For instance, processing an order might involve a series of steps and multiple domain elements as the system checks inventory, verifies customer information, maybe charges a credit card, and then sends messages to ship the order, notify the customer, and reduce inventory. Finally, we have infrastructure‑level services. These will usually implement interfaces that are defined in the core of the domain, such as I send email. But since they require access to external dependencies, like file systems, databases, or network resources, they live in the infrastructure layer of the system. With respect to our domain, you may find infrastructure not very interesting, ‑although the people who create the internal workings of those services might find them quite fascinating. We’ll look at implementing services in our application later on in the course.\nReview and Resources Let’s review some of the important terms you learned in this module. You heard us talk about immutability, which is a really critical attribute for value objects. And immutability just means once an object has been instantiated, you can’t change the value of any of its properties. ‑Another important term we learned about is the value object. A value object is an immutable class that is defined by the sum of the different properties that it has. We don’t need an identity for a particular value object. In fact, a value object doesn’t have any identity outside of the individual properties that it has. And in order for us to compare value objects, we simply compare all of its properties, and if they all match, then we can consider these two value objects to be equal. We also learned about domain services and these are interesting because domain services give you a place to put logic and behavior that you can’t find a home for in the entities and value objects in your domain. ‑And the last term that we want to review is side effects. Side effects are changes that occur in your application or any kind of interaction with the outside world. Now, technically any change to the state of the application can be considered a side effect, but generally when we’re talking about them, we’re talking about things that changed other than the main intent of the operation that you’re performing. For instance, it’s often a good idea to keep operations that query information separate from those that change state, and if you follow this practice, then any queries that you make, that result in changes to state would be said to have side effects. That brings us to this module’s key takeaways. Most of this module was focused on value objects, which are used in your domain model to measure quantify or describe something in the domain. Value objects typically don’t exist alone, they’re usually applied to an entity to describe something about it. ‑Value objects should be compared using only their values. They don’t have an identity. Any two value objects that share the same values should be considered equal. And value objects in our domain should be designed to be immutable taking all of their needed values in their constructor and they shouldn’t have any side effects. ‑We looked at a few examples of value objects in this module. We mentioned the .NET Framework string type that you’ve no doubt used. Strings and datetimes are value objects that are available to any .NET application and can be used as a model for how you should design your own value objects. We also looked at a couple of custom value objects we used in our sample application, the datetime range and the animal type objects. ‑Finally, we wrapped up the module by introducing domain services, which are used to orchestrate operations between different parts of your domain model. Remember that domain services should generally only be used if you don’t have an entity or value object where the behavior makes sense. Overuse of domain services can lead to an anemic domain model. In the next module, you’ll learn how to build aggregates from entities and value objects while respecting their relationships. Here are some links and resources relevant to the topics of value objects and domain services that we discussed in this module. Thanks for watching Domain‑Driven Design Fundamentals.\nTackling Complexity with Aggregates Introduction and Overview Hello, this is Julie Lerman. ‑And this is Steve Smith. ‑Welcome back to Domain‑Driven Design Fundamentals. In this module, you’ll learn more about aggregates and the associations between entities. ‑We’ve talked about the domain model and the need to have effective communication in order to ensure the model is a useful representation of the customer’s problem space. However, most problems that weren’t using domain‑driven design can be quite complex. So now we’re going to specifically look at some patterns and techniques that can be used to manage this complexity. ‑We’ll cover several new terms along the way, including aggregates and aggregate roots. You’ll learn about invariants and the aggregate roots’ responsibility for them. Aggregates often contain related data, so we will explore how to model relationships, often referred to as associations in DDD. ‑Then, we’ll look at our application and see how thinking about the aggregate roots pattern helps us revise and simplify our model. ‑And finally, we’ll walk through how we’ve implemented this pattern in our code.\nTackling Data Complexity Let’s start by considering data complexity. If you’ve ever worked on a relatively large or mature application, you’ve probably seen some fairly complex data models. One way to reduce the complexity that we already talked about is using aggregates and aggregate roots, which you’ve seen in the DDD mind map. Another is by limiting how many bidirectional relationships you have in that data model. ‑If your design doesn’t have any clear notion of aggregates, the dependencies between your entities may grow out of control, resulting in a model like this one. And if your object model reflects a data model like this one, trying to populate all of the dependent objects of one object might result in trying to load the entire database into memory. And the same problem exists when it comes time to save changes. With a model like this, there’s just no limit to which areas of the data model might be affected. ‑Even though in the real world at the highest levels of your system all of these things really do interrelate, we need to be able to separate them to keep the complexity of the system in check. ‑I’ve gone into a lot of clients where their entity data model looks like this, and they’re using this one big, huge single model throughout their entire system. So, one of the things that I work on with them is breaking this down and using the whole concept of bounded contexts to start looking at what makes sense for smaller models. ‑Yeah, a system that’s designed like this is what we tend to call a big ball of mud because everything is just kind of slapped together, and it collapses under its own weight once it gets to a certain level of complexity. ‑Great. So, let’s see how we can use aggregates to help solve the problem.\nIntroducing Aggregates and Aggregate Roots Aggregates consist of one or more entities and value objects that change together. We need to treat them as a unit for data changes, and we need to consider the entire aggregate’s consistency before we apply changes. In the examples shown here, the address is part of the customer and the component is quite literally a part of the product. We can treat a set of changes to a customer and their address as a single transaction. Every aggregate must have an aggregate root, which is the parent object of all members of the aggregate, and it’s possible to have an aggregate that consists of just one object, in which case that object would still be the aggregate root. ‑In some cases, the aggregate may have rules that enforce data consistency that apply across multiple objects. For instance, maybe our product consists of a collection of components, but in order to be in a valid state, it needs to have a specific set of such components. As an example, if the product is a Lego minifig, the collection of parts won’t be a valid product unless it includes a head, an upper torso, a lower torso, two arms, two hands, and two legs. If we allowed the collection of components to be modified independently of the product it was associated with, we could easily end up with consistency problems. If we want to modify the composition of a product, in this example, we should do so as a transaction, so that we start and end with a valid product. Data changes to the aggregate should follow ACID, that is they should be atomic, consistent, isolated, and durable. It’s also the responsibility of the aggregate root to maintain its invariants, such as the number and type of components it requires in the example. An invariant is a condition that should always be true for the system to be in a consistent state. When considering whether particular objects should be treated as an aggregate root, you should think about whether deleting it should cascade, in other words, if you need to also delete the other objects in its aggregate hierarchy. If so, it’s likely the object in question should be considered an aggregate root. ‑Another way to think about whether it makes sense to have an object as an aggregate root is to ask, does it make sense to have just this object detached from its parent? In the example shown here, if you’re deleting the minifig, then you have to delete all of its parts. Conversely, if you have to delete a head, maybe it got broken, you don’t need to delete the rest of the parts. Therefore it doesn’t make sense for the head to be the root of this aggregate. ‑In the Domain‑Driven Design book, Eric Evans states this pretty simply, he says, an aggregate is a cluster of associated objects that we treat as a unit for the purpose of data changes.\nConsidering Associations in Aggregates When considering aggregates, which, as Evan says is a cluster of associated objects, it’s also important to think about relationships between those associated objects, especially those which exist within the aggregate. Before diving into how related entities participate in an aggregate, it’s important to learn some important concepts that DDD brings to us when considering relationships among entities. ‑Many developers, myself included, tend to define relationships between classes in both directions. For example, an order has a line item and a line item has an order, a pet owner has pets and a pet has an owner. Many of us tend to think in bidirectional relationships by default. Because domain‑driven design aims for simplicity in the model, we start recognizing more quickly that the bidirectional relationships can often make things overly complex. For instance, I’ve often found this to be true when it comes to adding in my persistence layer, and I happen to mostly use an ORM Entity Framework, which brings along its own behavior and assumptions about how relationships are managed. Sometimes the fact that my model includes navigation properties that may not be totally necessary can be the cause of some grief that’s led me to take some time to consider if I really need that navigation or not. ‑Domain‑driven design guides you to default to one way, or unidirectional relationships. That’s not to say that you shouldn’t ever have bidirectional relationships, but that because of the extra complexity involved, you should spend some time considering if that complexity is justified. ‑A relationship, also known as an association, should be part of a type’s definition, and we do that using properties that allow us to traverse from one end of the relationship to the other. In this example, we have a client type with a Patients property, and in a patient type, we have a Client property; not just an ID value, but a property that leads to a complete object or set of objects. If you introduce a bidirectional relationship, as shown in this code, using properties that let you traverse in both directions, you should only do so when neither object can be defined without the other. If that’s not the case, then you need to be specific about the direction of the relationship, also called the traversal direction, to keep your model design simple. ‑Eric Evans puts it this way, “A bidirectional association means that both objects can be understood only together. When application requirements do not call for traversal in both directions, adding a traversal direction reduces interdependence and simplifies the design.” ‑So with a DDDI, we can look at our model and ask, can we define a client without identifying their pets? Can we define a pet without identifying the client who’s responsible for them? ‑This may sound like a simple set of questions, but it could lead to a whole lot of debate. For example, why would a person be scheduling an appointment if they didn’t have a pet? So in the context of scheduling appointments, a client doesn’t make a whole lot of sense without one or more pets or patients. ‑Or from another perspective, a cat can’t pay a bill or call to make an appointment, so how can we define a pet without a client? These are both pretty reasonable arguments, but neither one gets us anywhere. ‑So, let’s start again with defaulting to a one‑way relationship. A client would need a patient to schedule an appointment. A client would not need a patient to pay a bill. ‑Okay, and if we started from the patient end, a patient doesn’t schedule an appointment, so that becomes a moot point. Nor does a patient pay the bill. And, you know, because my dog doesn’t have a credit card. He can’t use the phone very well, either. So, when would you start with a patient and need to know something about the client responsible for that patient? That’s an interesting question. So, in the context of scheduling an appointment, one could argue that we should define the traversal from client to patient and that we gain nothing by having a way to traverse from a patient back to a client. You may balk at that notion, but remember that all we care about right now is scheduling an appointment, not all the other possible scenarios where it might make sense to traverse from patient to client. ‑Sure. It’s another example of YAGNI, you’re not going to need it. In fact, we originally had owner as a property on patient in this context, but we realized it wasn’t necessary, so we removed it. However, we kept the ID because we had some scenarios where it was useful. ‑So in the end, we chose to define relationships that traverse from appointment to doctor, patient, and client, and to define one that traverses from client to patients or their pets, but not the other way. ‑You may have experienced another type of bidirectional relationship problem if you’ve seen related data gets serialized in your applications. When objects are serialized, the serializer typically traverses all of the object’s properties recursively, If there is a bidirectional relationship, it can create a loop that will cause serialization to fail. You can think of saving aggregates in much the same way, and in fact, depending on how your persistence layer is implemented, serialization may actually be required as part of how your app persists its aggregates. In our aggregates, the single direction that we would use would go from the root to its dependents, and never the other way around.\nHandling Relationships that Span Aggregates Aggregates serve as boundaries between logical groupings within our application. We enforce these boundaries by prohibiting direct references to objects within an aggregate that aren’t the root of the aggregate. Consider the customer with the address. It’s perfectly okay for customer to reference address. Address might be an entity, or it might be a value object; it doesn’t really matter in this scenario. What’s important, though, is that the only way to get to the address in this aggregate is through the customer. We won’t be referencing an address by some identity outside of this aggregate, but that’s not the case for customer. Since the customer is the aggregate root, it can be referenced from other aggregates. ‑In this common example, an order might reference a customer. Depending on our context, it might make sense for a customer to reference an order. In this case, let’s assume it only makes sense for the order to be central to the application’s design. What’s not okay is for the order to reference a customer’s address directly. This violates the integrity of the customer aggregate. ‑Remember that aggregates and aggregate roots only apply to objects, not data. And when we’re talking about references, we’re talking about object references, properties that use an object directly. This is especially important with ORMs. For example, if you were to save an address that had a customer object attached to the customer property, there are scenarios in which Entity Framework would involve the customer in the database INSERT or UPDATE, possibly even a DELETE. And this behavior leads to a lot of confusion. I frequently advise developers to just remove the navigation property and use the foreign key ID instead. It’s a little more work, but removing some of the ORM magic results in more control over the behavior. And this aligns perfectly with the fact that one common way to enforce aggregates is to replace direct navigation properties in the model’s non‑root types with key references, and this reduces the number of dependency relationships within the model.\nEvolving the Appointments Aggregate Since we’re dealing with appointment scheduling, our initial design might look something like this. An appointment involves bringing together a patient and a doctor in an exam room for a particular type of exam, and since we’ll typically need to know the owner’s information when we deal with the scheduling, it’s important to have a reference to the client from the patient also. So if we model our system this way, any time we saved an appointment, it’s going to scan all of these objects for changes and save them as well. So modeling it this way, the scope of our domain for appointment scheduling is much greater than it needs to be since, in our case, we don’t expect to modify any of the other objects when we’re creating an appointment. ‑Right, an appointment is basically just a list of resources tied to a particular timespan, it models who, what, when, and where, but it doesn’t ever need to change any of these associated concepts. As a result, we can simplify our design by eliminating most of these object relationships from the appointment classes designed. Recall that for an object to be a good candidate for being an aggregate root, it should be the case that deleting an object should also delete the other objects within the aggregate. In the design shown here, if a customer cancels an appointment and we delete it from the system, it doesn’t make sense that this should delete all of the associated objects. ‑So here is another perspective on that same model. By simply including the IDs of the related concepts rather than object references, we’re able to ensure that creating and changing appointments has a minimal impact on our system when we persist the appointment. This relationship works because an appointment in the real world is really just a note that includes a place, time, and additional details. Adding and removing appointments shouldn’t impact the people and places involved, and this revised design reflects this.\nUsing Invariants to Better Understand Our Aggregate We do still have a bit more learning to do with this model though. Somewhere in our design, we need to enforce certain invariants about appointments like that they shouldn’t be double booked. Our current thinking is that appointments need to include this rich behavior with regard to how they’re scheduled. It’s the aggregate roots responsibility to verify any invariance the aggregate may have, and in this case, the appointment is still acting as an aggregate root, even if we have eliminated the navigation properties to the other objects that it might be working with. Let’s make sure we’re clear on invariants and then we’ll see how invariants in our application impact our design. An example of an invariant in the real world is the speed of light, which is a constant that you just can’t break in terms of the physics of the universe as we know it. Some things in your system must be true in order for the model to be consistent or valid. Other examples of invariants might be that the total of the items on a purchase order do not exceed the PO amount, or that appointments do not overlap, or that an end date on an object must follow the begin date on that object. Sometimes an invariant only involves a single object, maybe a particular property or field such as name is required. In this case, we may model the system such that one can’t even create the object without the required information. Our value objects are like this. For example, you can’t create an instance of a datetime range object without defining both the start and end time. However, sometimes the invariants involved how multiple objects relate to one another. ‑In the example here, the purchase order and the individual line items would most likely be modeled as separate objects, however, the purchase order would be the aggregate root, and as such, it would be responsible for verifying this invariant. The individual line items on the purchase order probably don’t know anything about one another nor should they, so it wouldn’t make sense to put the responsibility for enforcing this invariant in the line item object. What about appointments? How does one appointment know whether it overlaps another?\nModeling Breakthroughs and Refactoring As we focused on these invariants and where they belong in our design, it became clear to us that the appointment didn’t really make sense as an aggregate root. If you apply this thinking to our appointment scheduling context, it follows that one appointment doesn’t really know anything about other appointments, but the schedule knows about such things. Let’s evolve our domain model to follow this pattern and see where that leads us. ‑This feels like a big change to the model, and these kind of epiphanies happen when you’re working on the model. But that’s not a bad thing. It’s not like you’ve wasted a lot of time focusing on appointment as an aggregate root. This is the beauty of modeling your domain, having conversations with different people, with the domain experts, because ideas like this bubble up, and suddenly, something big like this becomes clear. So, you’re not going to get it 100% right the first time. Your understanding will evolve as you learn more about the domain. And from time to time, you’ll realize there are big changes that can dramatically improve your design. In the Domain‑Driven Design book, Eric Evans talks about these breakthroughs in his section about refactoring toward deeper insight. This is really an important part of domain‑driven design, and about a quarter of the book is dedicated to it.\nRecognizing Signs of a Misidentified Aggregate Let’s take a look at the signs that Steve and I eventually recognized in our domain, which led us to shift our appointment aggregate to a schedule aggregate. ‑Originally, our solution had the appointment as the central focus of the design. I had figured it would be its own aggregate with appointment at the root and its various properties as its children. As we’ve just discussed, that doesn’t really work as well as I’d hoped, so now we’re refactoring the design to introduce a new type, the schedule. Before we show that, though, let’s review the original structure and some of the reasons it didn’t work as well as an aggregate in our solution. ‑You can see the original structure had appointment in its own folder and marked with the IAggregateRoot interface, which is required for it to be accessible from our repository methods. It has essentially the same properties as the later version, except for ScheduleId, since there’s no schedule type yet. And it has the same basic set of methods for modifying its room, doctor, time, and other properties. None of that really changed since all of those operations only had to deal with this single appointment instance. ‑However, when the appointment tried to enforce the invariant that appointments whose times overlap for the same pet should be marked as potentially conflicting, things were a bit messier. You see, this appointment doesn’t actually have any association with any other appointments, so the only way to enforce this is to use a repository to get those other appointments for the same date as this one. Since entities don’t support dependency injection through their constructor, this means an instance of the repository needs to be passed into this method. Creating this repository instance was the responsibility of the calling code, which may not otherwise have needed it. Note also that because the repository’s interface is async, this method must now be async as well, even though no other methods on the appointment entity are async. ‑The real problem here, from a DDD perspective, is that cross‑aggregate invariants should not be enforced by any one aggregate. In the case of something like a unique constraint between all aggregates, you might need to use a domain service, or another approach. However, in other cases, the need to do this may indicate that you’ve missed an important part of your model. ‑Right. In this case, the whole thing that the user is interacting with is the clinic schedule, but nothing in our original model referred to the schedule itself. Since some of our business rules, like what to do with appointments that conflict, only make sense at this higher level, it made sense to introduce a change to our model, the schedule aggregate.\nConsidering Schedule as Our New Aggregate So, even though the initial design we had was about scheduling, the schedule itself was never part of our model. Once we include schedule as its own explicit object in our model, it makes the design much simpler. Appointments no longer need to know anything about other appointments. The responsibility for ensuring that appointments are not double booked and similar invariants can be performed by the schedule, which is the aggregate root. ‑So, let’s see if this passes our other tests about defining aggregate roots. A schedule will certainly help us ensure that appointments don’t overlap one another. When we save changes to a schedule, does it make sense to update any changed appointments? Yes, it does make sense. And if we were to delete an entire schedule, would it make sense to delete all of its appointments? Yeah, I think that would make sense also. ‑Yeah, I think this is the schedule for a particular clinic. At the moment, we only have one clinic, but if we imagine a scenario in which multiple clinics each have their own schedule, it wouldn’t make sense to delete a clinic’s schedule but then keep its appointments floating around. So I think that works. ‑Great. And if a schedule exists for each clinic, then it makes sense to persist the schedule, which means that it needs an ID, and therefore is truly an entity. And when we retrieve a schedule, we’ll most likely be filtering which related appointments we want to look at, for example today’s schedule or this week’s schedule. That would mean we want all of today’s or all of this week’s appointments from a particular clinic’s schedule. It really does make a lot more sense to me to tie the appointments to a schedule than directly to a clinic. Now, let’s see how this effects our design.\nExploring the Schedule Aggregate in Our Application Now I’ll show you the new schedule aggregate implementation in our application. In the refactored solution, we’ve renamed the folder so that now it’s ScheduleAggregate. This folder only includes schedule and appointment, as well as related guards and specifications. In larger applications, it can help to organize your domain model by grouping everything related to a particular aggregate in its folder. Looking at the ScheduleAggregate’s code, you can see that it inherits from our common BaseEntity type and uses a GUID for its id key, just like appointment. This lets us set the key ourselves, rather than relying on a database to do it for us. The class is also marked as an aggregate root with an interface. In the next module, you’ll see how we use that to protect the integrity of our aggregates. ‑Right. We’ll see how that works when we look at our repository and specification implementations. ‑Next, the Schedule’s constructor just takes in its id, its dateRange, and its associated clinicId. In our sample, the clinicId is always hard‑coded but in a real application, there might be several clinics using the same software, and they would each have their own ids. The constructor is responsible for ensuring that the incoming values are valid so that it’s always created in a consistent state. Schedule has just a few properties. There is the ClinicId, the associated set of appointments, and the DateRange. We’re careful to only expose a read‑only IEnumerable of appointments because our aggregate must encapsulate its internal state. We don’t want other parts of our application to add or delete appointments without going through the schedule’s explicit methods designed for this purpose. Also, the date range isn’t persisted since it can vary with any given instantiate ation of the schedule. ‑Yeah, and for performance reasons, you wouldn’t really want to load the ScheduleAggregate with every appointment that had ever been made included in it. By using a property like this, we make it clear to the rest of the domain what set of dates this instance of the aggregate holds. The actual population of the appointments that match this range is left as a responsibility of the specification and repository classes that are used to retrieve the schedule from the database. ‑Yes. And the configuration of the aggregate’s persistent details is done in the infrastructure project’s Data Config folder. This is where every entity’s EF Core‑specific mappings and configuration is performed, which keeps these details out of our domain model. You can see here that we’re also letting EF Core know that we don’t want the database to supply an id when we create a new schedule. We’ve marked that property as ValueGeneratedNever. ‑Getting back to the schedule, let’s have a look at its methods. The first method is for adding new appointments. Our design forces all new appointments to come through this method, so we don’t have to have duplicate behavior anywhere else in the application to take care of whatever should happen when a new appointment is added. It’s all right here in one place, easy to understand, and easy to test. The method validates the inputs to ensure we’re not adding bad data to our aggregate, and then it adds the appointment. When a new appointment is added, the schedule is responsible for marking any appointments that might be conflicting. It’s the right place for this behavior to live, since the schedule knows about all the appointments and knows anytime appointments are added or removed. After marking any conflicts, an appointmentScheduledEvent is added to the aggregate’s event collection. We’ll see how this works in the module on domain events. The DeleteAppointment method is similar. After deleting an appointment, the schedule needs to once more mark any appointments that might be conflicting. There’s also a TODO comment here. These are left as exercises for you to learn more about how to work with the patterns introduced in this course. You’ll find a number of TODO exercises scattered throughout the sample. ‑We hope you’ll take some time to download the code, run it locally, and try implementing some of the TODO tasks using the existing functionality as a guide. There are a couple more in the MarkConflictingAppointments method, which, remember, was originally on the appointment type when we started out with that as its own aggregate. This method is responsible for detecting and marking appointments that might conflict. The basic rule, shown here, just checks whether the patient has two appointments that overlap. If any such appointments are found, they are updated to set their conflicting property to true. Then, the current appointment’s property is set based on whether there are any other appointments that conflict with it. ‑This is an important part of the business logic for this application, and it’s encapsulated right in our schedule aggregate. In a lot of data‑driven applications, this kind of logic might be in a stored procedure, or perhaps just implemented in the user interface. But in a domain‑driven application, we want these rules to be explicit and defined in our domain model. ‑The last method on schedule provides a hook for its appointments to use to notify it when changes are made to one of them. Because we don’t have navigation properties from appointment back to schedule, we can’t directly call methods on the aggregate root from appointment methods. There are a few different patterns we can use to accomplish this task. For this sample, we chose this one because it’s simple and easy to follow. This handler simply calls MarkConflictingAppointments, but it’s exposed as its own separate method because it could do other things as well, and we don’t want to expose the internal behavior of the schedule to the rest of the app. To see how it’s used, let’s look at the appointment class’s UpdateStartTime method. When the application needs to update the start time for an appointment, it will call this method. Because appointment is part of a scheduling aggregate, we know the app will already have loaded the schedule before calling this method. So the second parameter in the method asks for the handler on the schedule that will be called. The call to update the schedule is made after updating the TimeRange property on the appointment, so when mark conflicting appointments is called, it will use the new value for the time range. There are a lot of other ways you can set up this communication, using C# events, static domain events, or some kind of double dispatch approach. They all have trade‑offs, and when you need to do this in your apps, you should choose the one that works best for your app and your team. ‑Let’s see the final result in the application. This change to our model of adding in a schedule aggregate made a big difference to how the domain model is organized. It gave us a much better place to put the logic of enforcing business rules around combinations of appointments and business logic that needs to run when appointments are added or removed. ‑Right. Without the schedule, we would have had to use a domain service or something to add behavior around the newly added or removed appointments. But with this design, we can go into the schedule, add a new appointment for Rosie, and then add another one, and you can see the notifications being triggered by the events, as well as the red outline representing the conflict in these two appointments. Not only is our domain model clean and easy to test, but even more important, it actually works! ‑And notice that as we move one of those conflicting appointments to another spot, the red alerts disappear. Good job, Steve! I am so grateful that you let me off the hook for working on the front‑end of this application. You know I’m more of a back‑end developer.\nSharing Our Tips for Aggregate Design So let’s step back a moment and review some of the things we’ve just learned about designing aggregates. First of all, aggregates exist to reduce complexity. You might not always need an aggregate. Don’t add complexity just for the sake of using an aggregate. Another is that entities with an aggregate can only reference the root entity of another aggregate. ‑But you can always use foreign key values as a reference to entities inside another aggregate. It’s perfectly okay to use this, and it will avoid the need for when you go to save that aggregate for it to cascade its persistence into other aggregates. If you find you’re needing to use a lot of foreign key references to aggregate children often, you may need to reconsider the design of your aggregate in your domain model. ‑Another pointer was don’t be afraid to have an aggregate of one, in other words, an aggregate that only has one object in it. ‑And finally, don’t forget the rule of cascading deletes. Remember, one test for whether or not a particular object makes sense as an aggregate root is to consider whether deleting that object should also delete all of the other child objects in that object’s hierarchy. If it doesn’t, then you have probably chosen the wrong structure for your aggregate.\nReview and Resources Once again, we have covered quite a bit in this module. Let’s review some of the terms that you learned in this video. The first thing we talked about was an aggregate. An aggregate is a group of related objects that work together in a transaction. The root becomes the entry point through which you do any work with the aggregate, and the root also is what’s in charge of making sure that all of the rules that apply to that graph of objects are met. ‑Each of the rules that describes the state that the system must be in in order to be valid is called an invariant. Within our aggregates, we have objects that are related to one another. In DDD, we refer to these relationships as associations. If you use an ORM, you may hear the term navigation properties, which refers to those properties that reference the related objects in the model. And we talked about the importance of defaulting to one‑way relationships, which we also refer to as unidirectional relationships. ‑In addition to these important terms, Steve and I shared a lot of guidance around creating aggregates and roots in your domain models. Nobody wants to work with a big ball of mud. We use aggregates to organize our model. An aggregate is a set of related objects that live in a single transaction while encapsulating the rules and enforcing invariance of that transaction, making sure that the system is in a consistent state. When designing how related objects work together, your job will be easier with one‑way relationships. Use those as a default, and only introduce bidirectional navigation if you really need to. ‑And most importantly, don’t resist updating your model as you and your team of domain experts learn more about the domain. Hopefully, most of this will happen early on, and then just once in a while you might have a big breakthrough, like we did when we realized that the schedule made more sense as an aggregate root than trying to have each appointment be its own aggregate. Up next, you’ll learn about repositories which are a critical pattern in domain‑driven design. This is Steve Smith, ‑and I’m Julie Lerman. Thanks for watching Domain‑Driven Design Fundamentals.\nWorking with Repositories Introduction and Overview ‑Hello. I’m Julie Lerman. ‑And this is Steve Smith. ‑In this module of Domain‑Driven Design Fundamentals, you’ll learn about repositories, another critical pattern for Domain‑Driven Design. ‑We’ll start by defining what repositories are, and then we’ll provide some tips for working with them, as well as talking about some of their benefits. There are different ways to define repositories and plenty of debate around their use. We’ll address some of these points. ‑Next, we’ll introduce you to the specification pattern and how it can be really helpful when you’re implementing repositories. Then we’ll open up Visual Studio again and show you how we’ve implemented some repositories in the scheduling app.\nIntroducing Repositories ‑Now, Julie, if this were an in‑person class, I’d definitely ask for a show of hands who has heard of the repository design pattern. I would expect most hands to go up. ‑I hope so too. I think the repository pattern is by far the most popular element of DDD to be practiced outside of Domain‑Driven Design. They can be valuable in so many applications as a way to simplify data access and enforce separation of concerns. When I began learning about repositories and implementing them in my own software design, it had a huge impact on my application architecture. Along with automated testing practices, it really forced me to consider separation of concerns with each method and behavior added to my software. ‑Personally, I love the pattern, and I find it makes it much easier for me to write good, testable code. We’re going to talk about using repositories within a DDD application, but if you want to learn more about the pattern itself, you can look in the design patterns library, and I know Julie also discusses using them with Entity Framework in her Entity Framework in the Enterprise course. ‑You can see the repositories are part of the DDD mind map, as they’re used to access entities and aggregates. Any system that needs to persist between restarts has some kind of persistent storage for the state of the system, like a database. Many applications focus a great deal of effort on the mechanics of querying, fetching, and translating data to and from objects to the point where it distracts from the model that these objects are meant to represent. And having ad hoc access to the data source also promotes having developers query for any bit of data they want anytime they want, rather than using aggregates. This makes it pretty difficult to manage the consistency of aggregates by enforcing their invariants. At best, the logic for enforcing the integrity of the model becomes scattered among many queries, and at worst, it’s not done at all. ‑Applying Model‑First design and separation of concerns means pushing persistence behavior into its own set of abstractions, which we refer to as repositories. Only certain objects, like specifically aggregate roots, should be available via global requests. Repositories provide this access, and through omission, prevent access to non‑aggregate objects, except through their aggregate roots. They give you the ability to constrain the data access, so you avoid lots of random data access code throughout your application. ‑When you think about the life cycle of an object in your application, you should consider two cases. In the first case, you have objects that are not persisted. These objects are created, perform some work, and then they’re destroyed. In the second case, you have objects that are persisted. These objects have a slightly more involved lifecycle since after the object is created, it must be reconstituted with whatever state it had when it was last saved. Then it can perform whatever work the application needs it to do, after which it may need to save its state to some persistent storage before finally being destroyed. You can use repositories to manage the lifecycle of your persistent objects without the objects having to know anything about their persistence. We call these objects persistence ignorant because they’re ignorant of how they’re stored into and retrieve from a data store. ‑In his book, Domain‑Driven Design, Eric Evans speaks quite a bit about repositories. They can be summed up by saying that a repository represents all objects of a certain type as a conceptual set, like a collection with more elaborate querying capability.\nRepository Benefits ‑Repositories can add a number of benefits to our application. First of all, they provide a common abstraction for all of our persistence concerns, which provides a means for clients to very simply obtain model objects and to manage their lifecycle. They also promote separation of concerns. The domain logic and the user interface can both vary independently from the data in the back‑end data source that is used by the application. ‑The public interface of a repository very clearly communicates our design decisions. Only certain objects should be accessed directly, so repositories provide and control this access. Another important benefit is that repositories make it easier to test our code. They reduce tight coupling to external resources like database, which would normally make unit testing difficult. Having a repository separate from client code and domain logic means that we can easily make improvements to optimize data access for this application, tuning for performance, adding caching behavior, etc. is all much easier and safer when the code for data access is all encapsulated in one or more well‑known classes. All of this makes your code easier to maintain.\nRepository Tips ‑Here’s some basic guidance you should keep in mind when designing repositories. First, a repository should have the illusion of a collection of a specific type of object. You’ll be adding the objects to the collection, removing them, and retrieving objects from the collection, but that it is an illusion of a collection is important to keep in mind. When you interact with the repository, these are the types of methods you’ll be calling, add, remove, and retrieve. Your calling code doesn’t care how the repository performs those actions. So in the repository, you might have code that responds to a retrieve method, goes out to a database and gets data, but it could be getting data that’s already in memory, or it might be grabbing data from a text file on your computer. ‑Another important recommendation for repositories is to set up access through a well‑known global interface. That way, developers that need to interact with the repository will be familiar with a common pattern for using it. ‑Here’s a simple repository interface example. Depending on the size and complexity of your software, you may have a few layers of interfaces. ‑For example, if you anticipate having a number of repositories for a schedule aggregate used in different bounded contexts, you might want an IScheduleRepository interface that not only implements the lower‑level interface, but defines some other methods or properties that every schedule repository is required to have regardless of the bounded context it might reside in. Because a repository acts like a collection, you’ll want methods to add and remove objects to encapsulate the underlying data insertion and deletion operations. We’ve got these defined in our IRepository. It is up to each concrete implementation to define how add and remove will actually work. ‑It’s not unusual to need to add specific query methods to individual repositories. Whether you need a custom subset of entities or a specific way to load entities’ relationships, custom methods are a simple way to achieve this. For example, if we wanted to fetch a schedule instance with all the appointments for a given day, we could add a method to the ScheduleRepository that might have an EF Core implementation like this one. ‑Likewise, if we just wanted to be able to fetch a client with their patients, we could add a method like this one, which will eager load the patients when it loads the client. Be careful with this approach though, as it can grow out of hand, and your repositories may end up with many different query methods. A simple way to address this is to use specifications instead, which we’ll cover later in this module. In addition to these specific tips for implementing repositories, you should also keep in mind these more overarching tips. First, be sure to provide repositories only for aggregate roots that require direct access. And next, keep the clients focused on the model, while delegating all of the object storage and access concerns to the repositories.\nAvoiding Repository Blunders We’re not always going to land on the happy path, so we do want to share with you some common problems that you might run into, how to recognize them, and most importantly, how to avoid them. ‑Remember your client code can be ignorant of the implementation of your repositories, ‑but developers cannot. ‑It’s important that developers understand how your specific repository is implemented, otherwise, they can run into a number of different problems. ‑So we’re talking about not just the developers who are implementing the repository, but also the developers who are using the repository. ‑One of the common repository problems the developers working with repositories often encounter is called an N+1 query error. This is where in order to display a list of rows from the database, you end up calling one query to get the list and then a number of queries equal to the count of that list to fetch each item individually. ‑Another one that I see a lot is when people are fetching related data. With Entity Framework, they’re either using eager loading or lazy loading, and especially with lazy loading, there are a lot of developers who don’t really know what to expect from it and just because it’s easy and it just works, they use it and then run into all kinds of problems because of it. ‑And depending on how your data is structured, sometimes if you’re trying to fetch just one or two properties that are represented in a particular column in a data table, you might end up fetching more data than required if you pull back the entire row which might include dozens of columns and a lot of actual data there. These are things that knowing how your underlying data is persisted and how your repository is implemented, how those things work, can make a huge difference in your application. ‑Most of these blunders impact how data is accessed in a data store and that means that one of the best tools you have for surfacing these problems is profiling your data store. Many of the IDEs we use for managing databases have profilers built in, some examples are SQL Server Profiler, Jetbrains DataGrip, and Azure Data Studio. Many of the APIs we use also have logging capabilities that can relate database activity. As a .NET developer, I often use the .NET Core logging API or some of the features built into Entity Framework Core, but most any language you use can do this and all of the cloud providers have ways to trace activity in their various data stores. There are even third‑party tools dedicated to database profiling. The suite of profilers from Hibernating Rhinos is a great example. They have profilers for RavenDB, Azure CosmosDB, and the EF Core, and Hibernate ORMs.\nAddressing the Debates Around Using Repositories Many developers have strong opinions about the use, and some might say overuse, of the repository design pattern. Let’s consider some of the common arguments made about repositories. It’s worth remembering that like Bjarne Stroustrup’s famous quote about programming languages, there are two kinds of design patterns, too. It’s no surprise, really, that as the repository pattern grew in popularity, that there would be many complaints about when and how to implement it. ‑Here’s one that really gets me. EF Core, the .NET ORM which we’re using this course, has a built‑in repository for its data access. It’s called the DbContext. I’ve heard and read comments from so many people who say never use a repository on top of EF Core because it already has a repository built in. And then I hear others who say you should always use a repository to interact with EF Core. I am not a fan of the words always and never. Maybe it’s because I’m a libra, who knows. So, these strongly held opinions really frustrate me. What Steve and I want to do here is give you the information you need so that you can make educated decisions about when to use repository and when to opt for something else. ‑Let’s remember for a moment what repositories are and where they live in a domain‑driven application. Repositories are abstractions. They’re part of your domain model. They define the persistence operations the model will use. That’s it. There’s nothing in the domain model patterns produced through model‑driven design espousing the use of Entity Framework, or NHibernate, or any other specific vendor tool for doing persistence. It doesn’t even know if you’re doing Java or .NET. It’s meant to be totally abstract and just types. ‑The domain model should be persistence ignorant, and it shouldn’t depend on implementation details. ‑Right. One of the things I really appreciate about DDD and the way it isolates domain expressions within a layered architecture is that it aligns perfectly with SOLID design principles, like the dependency inversion principle. ‑You are a big fan of SOLID, Steve. ‑Guilty! In this case, in terms of SOLID, using an abstraction for persistence enables us to follow dependency inversion because we can define an abstraction in our domain model and then implement it in another project that depends on the domain model. We can also write our application and its user interface so that it depends on our persistence abstraction, too, rather than on the implementation details. That’s the heart of dependency inversion. ‑And that makes it easier to follow the interface segregation principle, which I also learned about from your SOLID course. This principle prefers smaller interfaces, so if your app is using a DbContext directly, that is not a small interface. Along with DbContext repository features, it exposes a lot of other functionality. Using an abstraction that limits what your app needs to do with regard to persistence makes for a much simpler design in our model, reducing complexity. ‑Right. In that way, it’s similar to the facade pattern because it lets us work with a much simpler view of what could otherwise be a potentially very complex and powerful persistence library. ‑So, when we’re following DDD, our domain model shouldn’t know anything about EF Core, or whatever APIs you’re using for your data persistence. If our model requires persistence, like most do, we should define abstractions in the model that describe what our needs are without specifying how they’re done. ‑Exactly. The abstraction defines what needs done, the specific implementation is all about how to do it. ‑And one really popular and powerful way to do persistence in .NET is with Entity Framework Core. And because it implements methods that map pretty closely to most common persistence abstractions, it’s usually pretty easy to implement a particular abstraction with a class that calls into EF Core. ‑Definitely. ‑EF Core works great for this in most of the apps I work on, but we should never couple it tightly to our domain model. ‑Exactly. The whole point of DDD is that we shouldn’t be coupling our domain problems with our persistence problems.\nReturning IQueryables: Pros and Cons Another question I get all the time, and which I’ve discussed in some of my other Entity Framework courses, is whether repositories should return IQueryable, and yes, I do have my opinions on that. ‑Yes, this is another source of some debate. On the face of it, it sounds like it would be a great idea. Your most basic repository abstraction might not provide much in the way of complex filtering options and you can avoid having to think about that sort of thing if you just return an IQueryable. ‑Right, because then any code that consumes an IQueryable can extend the expression adding additional filters or projections to the query before it’s actually executed. On the surface, it sounds pretty good, right? ‑Well, it turns out that a lot of query logic is actually business logic, and if you return an IQueryable, it has two not‑so‑good effects. It can leak a lot of the implementation details so your application code’s behavior changes significantly based on the implementation of the repository and it tends to put the business rules for querying all over the application. ‑Let’s say we have an MVC application with a controller so that’s the server‑side logic of the UI layer and it returns a view to the UI. The controller calls into a service to get its list of customers and the service contains a customer repository interface. That repository calls into an infrastructure project and the infrastructure project is where we’re using EF Core and it’s DBContext, but to limit what’s exposed outside of the infrastructure project, there is a repository there as well. The repository and the service makes its calls to the repository in the infrastructure layer. It sounds like a lot of layers, but that’s not a problem because we have reduced coupling and made a maintainable solution. The real problem here is where can we put our query logic in this example? ‑Well obviously the repository, and it wouldn’t be unusual for the method in the service to further modify the query, but since it’s also returning an IQueryable, the controller action could further modify that same expression tree, and assuming the controller just passes that same IQueryable to the view, which we’ve both seen teams do, even the view could further refine the query. So is this a good thing or a bad thing? ‑Well on the plus side, we get a lot of flexibility without having to write a lot of code for our repository. We’re also able to tailor the data we need to the specific place it’s used and even modify the query from multiple steps in the app. At the same time, we get to reuse a simple repository interface everywhere in our app. ‑Right, but on the other hand, that query logic is now spread out everywhere. Every class that’s adding query logic, in addition to whatever else it’s doing, is now violating the single responsibility principle. Then there is separation of concerns. Query logic should be separate from other concerns in most of these classes. ‑And another problem I see a lot with this approach is confusion about when the actual query is executed and what runs on the database server versus in‑memory in the application. ‑Many developers will assume the query runs inside the repository and the result they get back is from the data store. And of course that’s true for most calls, but not necessarily for those that return IQueryable. ‑Right, the query will execute the first time any code tries to enumerate the result. That could happen inside the repository, but it could also happen in the service, or in the controller, or even in the view. ‑Yeah, I see that a lot. a related issue is that developers at any step of this process can add additional logic that may compile just fine, but then at runtime when EF tries to interpret it, it blows up. ‑Anything you add to the query expression that Entity Framework doesn’t know how to translate into SQL is likely to cause an exception, at least with recent versions of EF Core. ‑And it may be redundant at this point, but it’s probably worth adding here that there is no encapsulation when you use this approach. ‑There is a way we can fix at least some of these issues though. For example, instead of returning IQueryable, we can still create flexible repository methods by passing in predicates. Then in the implementation, this predicate can be passed along to the DBContext as its Where expression providing the necessary filter. If you’re not familiar with the term predicate, but you’ve used the link where method, that’s what the method takes as its parameter, which is why we’re able to pass it right to the WHERE clause. ‑That does help part of the problem. Where before the query could have been executed at any of these points, at least now we know that whatever comes back from the repository will be the in‑memory result. The actual query is always executed in the repository itself. Of course, if the service takes in a predicate, it still means that any code anywhere in the system could be responsible for creating the query logic with the possible exception of the view if it’s just being passed an IEnumerable at this point. ‑Okay, so with predicates, they’re still very flexible, but they’re not as easy to build up from multiple locations in your application, especially compared to IQueryable. The rest of the good points still hold though. ‑The only thing we’ve really changed on the bad side is confusion about when the query actually executes. Being a fan of solid and encapsulation and knowing some other patterns we’ll share later in this module, I’m usually going to vote against this approach too. ‑Well another way we tend to solve this conundrum is going the custom query route. We even suggested this as a tip earlier, but you can definitely take it too far. Every little change to a query means another method, customer with orders, customers by shoe size, by shoe size, customers by favorite Netflix show. Hey, you never know what problems your domain experts are going to share with you. ‑The problem with this approach if it goes beyond one or two methods, is that you really start to feel the pain of the open/closed principle violation. Every time another custom query requirement comes in, you have to change the repository abstraction and all of its implementations, and the bigger the type gets, the more it violates the interface segregation principle, too. The more complex your problem is, the more query methods you’ll be adding to your solution. This can surely be an untenable situation, and we will show you some better alternatives a little later in this module.\nConsidering Generic Repositories and Interfaces Using generic interfaces for persistence is great from a code‑reuse point of view. With just one simple interface, any entity can be persisted using a standard set of operations. If you’re using aggregates, you can use generic constraints in this simple marker interface to ensure that only aggregate roots can be persisted using your interface. It can work really well. ‑But there are trade‑offs. What if you have certain aggregates that should never be deleted, but your generic repository includes a delete method? Does it make sense to have operations defined in your domain model that should never be used? This is where you need to make a judgment call. Is the convenience of having a single consistent way of dealing with persistence throughout your model more valuable than having only the necessary and appropriate persistence operations exposed? There’s no one right answer. Pick what makes sense for your app, your model, and your team. ‑In our demo, partially for the sake of simplicity, we are using a single generic repository for all of our operations, even though, yes, this means there are operations on some aggregates that are never called and some that never should be called, for example, deleting the entire schedule. ‑If we didn’t go that route, our model would need to include separate repository interfaces for each of the aggregates in our model, including schedule, doctor, room, client, and appointment type. Each would define only the operations that were actually needed by the application. For a larger model, this could result in quite a few interfaces, and possibly implementations, but would provide a more pure representation of the domain model. ‑If you do choose to create a generic repository interface, that doesn’t necessarily mean you’ll implement it generically. You might only choose to create implementations for each aggregate root, which would comply with DDD recommendations. However, it can be convenient to create a generic Repository of T implementation class that you can then use with any entity. ‑This is what we’re using in our sample, both for the front desk app and for the clinic management app. In both cases, if you review the sample, you’ll see there’s very little persistence‑specific code in either solution. ‑If you really like the code reuse you get from having a generic repository implementation, one way to keep it from allowing too much access to the internals of your aggregates would be to use a marker interface, perhaps one that simply extends the entity interface to identify your aggregate roots. Then you can update your generic repository to require this interface, rather than working with any entity. ‑At that point, code that uses the repository won’t be able to instantiate the generic repository with non‑root entities, so we’re able to use our repository to restrict access to non‑root entities from client‑server model. Using marker interfaces to identify aggregate roots is one way you can enforce your design decisions in your model using the compiler rather than relying on code reviews or other less effective practices. ‑Repository abstractions, especially generic ones, can sometimes get to be pretty large. Large interfaces violate the interface segregation principle, one of the solid principles that I cover in my Solid Principles for C# Developers course. One way to keep these interfaces smaller and more focused is to split them into read and write operations. This is related to the concept of Command Query Responsibility Segregation, or CQRS. Read operations are queries, write operations are commands. There are many benefits to leveraging CQRS that we don’t have time to cover in this course, but one area where you may immediately benefit is with modifying behavior related to these kinds of operations. Queries often benefit from data caching, and it’s very easy to add data caching to just the read operations. ‑Commands often benefit from being performed asynchronously using a queue, and having a separate interface for commands makes it easy to implement this behavior. These are just two ways you can quickly leverage splitting up your repository definitions between reads and writes. Of course, if you have a lot of different read methods, this can make it more and more difficult to implement custom caching logic, since every new method will also need to be added to the caching layer. Fortunately, this is easily solved by using the specification pattern.\nExploring Repositories in our Application Steve is going to give you a guided tour of how data access and persistence are handled in the FrontDesk application using repository abstractions. Because he’s been fine tuning versions of this demo application for many years, it’s quite impressive, and he truly is the best guide for walking you through this implementation. ‑We’ll start from the front end of the application, which is our Blazor client. Let’s take a look at editing an appointment. Here’s an appointment for Julie’s dog, Samson. You can see that on the edit screen, in addition to showing the details for the appointment, it also provides us with a list of the doctors and appointment types. When we hit the drop‑down list, we can see all of the different doctors who are available that we could schedule to work with this particular appointment. That’s actually accomplished through a back end API that’s coming from a different project. Let’s take a look at that. We’ll start by examining the API using our Swagger endpoint. Looking at Swagger for DoctorEndpoints, you can see that there are two endpoints, one to get a specific doctor by ID and another one that returns a list of doctors. We just saw the list of doctors in action. Let’s go ahead and run it again from Swagger. Here you can see the resulting set of three doctors, just like we saw in the drop‑down list. You’ll find the code for this particular endpoint inside the FrontDesk.Api project. Within there, there’s an Endpoints folder with subfolders for each of the different types of entities that we expose API endpoints for. Inside of Doctor, you can see there’s a GetById and a List, and we’re looking at the List endpoint here. When we define an endpoint, we simply inherit from BaseAsyncEndpoint, and specify the request type, if any, and the response type, if any. We can also do dependency injection through the constructor, just as you would with a controller. Each endpoint has a single Handle or HandleAsync method, and this is where the actual work of the endpoint is done. You can see in this example that we are simply awaiting on the repository’s ListAsync method in order to get our list of doctors. Once we have the list, we map it to our DTO that we’re going to actually return, and pass that back as part of that response type. The response, as we just saw in Swagger, includes the Doctors as JSON, as well as a Count property that includes the total number of those doctors. Now let’s look a little bit more closely at that repository. You can see in the dependency injection that’s occurring in the constructor that we’re depending on an IReadRepository, but where is that defined? For that, we need to look at our SharedKernel project. Inside the separate SharedKernel project, which FrontDesk references as a NuGet package, you can see that we have defined an IReadRepository interface. This inherits from IReadRepositoryBase, which is actually itself defined in another NuGet package, the Ardalis.Specification type. The reason why we’re creating our own interface here is so that we have complete control over it and we can add additional behavior. For example, in this case we’re adding a generic constraint. We’ve said that this particular interface will only work with types that have the IAggregateRoot interface attached to them or applied to them. Looking at that particular interface, you can see that there’s nothing to it. It’s simply a marker. It’s a way that we tell the compiler that our intent for a particular class or entity is that it should be treated as an aggregate root. We use that marker to enforce our design and our encapsulation to make it so that we don’t accidentally just load up a child entity out of an aggregate, when instead we’ve made a design choice that we want to work with that entire aggregate as a unit. You can see that we’ve also implemented IRepository similarly. It also inherits from a type that comes from Ardalis.Specification, and also has the same IAggregateRoot restriction. Now let’s return to our FrontDesk application and see how we implement this. First, we should look at the DefaultInfrastructureModule. This is an artifact module that defines how we’re going to wire up our abstractions with their implementations. And here you can see all the important bits of how we wire up EfRepository to IRepository, as well as IReadRepository. But notice for the IReadRepository we’re actually wiring up a different type, a CachedRepository. This acts as a decorator around the underlying EfRepository, and will provide additional caching logic. Inside of the CachedRepository, when we asked for a list of doctors, it actually checked the cache first, and then if it wasn’t in the cache, it would go and fetch the result from the EfRepository, which in turn would make the request to the database. We can see in this example here that the logging is showing us that we’re actually hitting CachedRepository, and some of the times we’re fetching the source data and other times were fetching the data from the cache. The actual EfRepository that is also defined inside of FrontDesk.Infrastructure is shown here, and once more, you can see that there’s not much to it. Most of the behavior we’re simply inheriting from the EfRepository that exists in the Ardalis.Specification package. It’s called RepositoryBase. However, when we inherited it, we were able to add additional constraints, and so you’ll see here as well that we specify that this only works with IAggregateRoot. You can see the definition of the RepositoryBase in the Ardalis.Specification NuGet package, which is available on GitHub. The details of it are shown here. The ListAsync method simply delegates to dbContext.Set of the appropriate T type, and then calls its ToListAsync, passing along a cancellationToken if one was provided. Now the last piece of the puzzle is our own AppDbContext. Inside our AppDbContext, we define the DB sets that we’re working with and we also pass in some additional configuration. One thing to notice and take away from this example is how many places in our solution we have to reference AppDbContext or EntityFramework. It’s almost nowhere in the entire code base. The only place that we talk about it at all is inside of AppDbContext, EfRepository, and some related folders such as Configuration and Migrations. Everywhere else, and especially in our domain model, we’re completely persistence ignorant, relying only on abstractions that we’ve defined.\nIntroducing the Specification Pattern Eric Evans introduces the specification pattern in the original book on domain‑driven design. Although it’s covered in Evans’s DDD blue book, the specification pattern isn’t listed in the book’s mind map, and honestly, it doesn’t get the attention it deserves. Factories are in the book’s mind map, but specifications aren’t? Even though in my experience they play a much larger role in producing a clean domain model design. ‑In the book, Evans says that specifications mesh smoothly with repositories, which are the building‑block mechanisms for providing query access to domain objects and encapsulating the interface to the database. It’s this powerful combination of specification and repository patterns that truly result in a clean, extensible, and testable design. Let’s dig a little more into the specification pattern and how it integrates with repositories before we show you how we’ve implemented it in the front desk application. ‑Specifications are used to specify the state of an object, and as such, are primarily used in three ways, validation, selection and querying, and creation for a specific purpose. In our app, we are primarily leveraging specifications in our queries. Create explicit predicate‑like value objects for specialized purposes. A specification is a predicate that determines if an object satisfies some criteria, according to Eric Evans. The most basic specification simply provides a method typically named IsSatisfiedBy, which accepts some object and returns a Boolean. These methods perform their logic in memory, and unfortunately, in remote data querying scenarios, this approach would require every row to be transferred to the application before the specification logic could be run against it. ‑However, more sophisticated specifications can be used in conjunction with ORMs like Entity Framework Core to encapsulate the details of a query while still allowing EF Core to translate the query into SQL that executes on the database server. Our sample application uses such a specification in the form of a NuGet package, ardalis.specification, which is maintained by, guess who, Steve Smith. ‑Recall that one of the benefits of using the repository pattern and abstraction was that it prevented query logic from being spread throughout the application. This was also the reason for not returning IQueryable from repository methods. The same logic can be applied to repositories that accept arbitrary predicates since, again, that means the complexity of these predicates would need to live in the code calling the repository, which might be in the user interface for example. Using repository interfaces that accept specifications instead of custom predicates addresses this problem very elegantly. ‑What about the issue we learned about earlier in this module where generic repositories weren’t suited to aggregates with custom query needs? So, individually typed repository interfaces were required, and each additional custom query needed to be added to this new specific interface. Well, specifications solves that problem too. Generic methods accepting generic specifications allows for custom queries where needed for any given aggregate. ‑A few more benefits of specifications. They’re named classes that live in your domain model. You can easily unit test them in isolation, or if necessary, integration test them with a test database. They’re highly reusable. They keep persistence logic out of your domain and your user interface. They keep business logic out of your database and persistence layer. They help your entities and aggregates follow the single responsibility principle by keeping complex filtering or validation logic out of them. You can easily create your own specification interface and implementation. Feel free to look at the source for ardalis.specification on GitHub and take just the bits you find useful. Or, you can reference that package and leverage all of its features and just start adding the specifications that your domain needs. It’s up to you. Either way, you will need to write the specifications themselves. These belong in your domain model. When you don’t have many of them, you might just put them in a root specifications folder. However, as your model grows, if you’re using aggregates, it may make sense to have each aggregate include in its own folder the specifications that go with it. This makes them easy to locate as they grow in number. ‑Each specification class is a value object, so it should be immutable. Generally, they do all of their work in their constructor. Any variable part of the specification should be supplied as a constructor argument. And once constructed, the specification needs to be supplied to your query implementation. You can use specifications directly with EF Core or you can use a repository abstraction that supports them. In either case, pass the specification to the query object and it will be used to build the query, which is then executed and results are returned. The resulting code for most queries turns into one line to create the specification and another line to execute the query by passing the specification to a repository or a DbContext method. Note that our sample is built on top of a repository abstraction that’s provided with the ArdalisSpecification package, and so it’s fully compatible with its specification types. We’ll look at the code more in the next section. ‑Here’s an updated mind map that I have created which shows how specifications work with repositories to define the queries for aggregates and entities. If you’ve been using repositories without specifications and have experienced any of the pain points we’ve described in this module, try refactoring to use specifications and I’ll bet you’ll be surprised what a positive difference it makes.\nUsing Specifications with Repositories in Our App Now it’s time to see just how specifications are implemented in the sample app. While the application code does lean on Steve’s specification API, there is still plenty to see. Most of what you’ll see here is the application’s code, but occasionally you’ll also see some of the code that’s in the Ardalis.Specification API. Once again, Steve is going to walk you through this demo, and he’ll do so from the perspective of how the app retrieves data, starting with the front‑end. ‑When we first load the schedule page in the FrontDesk app, it loads our Blazor WebAssembly application, which then makes some API calls to fetch the appointments and related data. One of those calls is shown here. It’s used to get the list of appointments for the schedule. Looking at Swagger, we can see there are a bunch of appointment endpoints. Our API is designed to serve the needs of the client app. Its endpoints won’t necessarily match up with how our domain model is constructed, so it’s perfectly fine to have an endpoint for appointments, even though appointment is not an aggregate root. It just means we need to pass in the aggregate root ID as part of the request so that we can get the schedule that owns the appointments. If we test the list AppointmentsEndpoint, we can pass in the same schedule ID that Blazor was using, and we get back a list of appointments as expected, and these are, in fact, the same appointments that are being used in the front end. Looking at the source code for this endpoint, you can see that, again, it’s in the API project in the Endpoints folder in an Appointment folder, and within that, we’re looking at the List endpoint. Now, when we pass in the request, we’re specifying a ScheduleId, and if that ScheduleId is missing or empty, then we’re going to return NotFound from this API. Otherwise, it uses the ScheduleByIdWithAppointmentSpec to encapsulate the query that it’s going to use. On the page in question, we only want the appointments for one day. It’s worth noting that this specification does not perform any filtering by date; it returns all appointments for this schedule. We’ve left a to do task here for you to implement this behavior by creating a new specification. Now, the specification that we’re using here is passed to the repository method, GetBySpecAsync. We’ll look at that in a moment. For now, let’s take a look at this specification. All of the schedule specifications are in the ScheduleAggregate folder in the Core project. The ScheduleByIdWithAppointmentSpec is pretty simple and has just three details worth pointing out. First, it has a WHERE clause, making sure it only matches schedules that have a matching ID. Second, it eager loads it’s associated appointments by using it .Include statement. And third, it implements another marker interface, ISingleResultSpecification. This interface is used to mark specifications that are expected to only return a single result. It is required when passing a specification to a repository method that only returns a single instance of a type rather than a collection or enumerable. Considering that this is being called from a List endpoint on the API, this may seem strange, but remember, we are only loading a single schedule aggregate, and it is then just the container for the set of appointments that the endpoint is going to return. The method the endpoint is calling, GetBySpecAsync, is defined in Ardalis.Specification, as shown here. Note that it has a generic constraint requiring any specification passed to it to have that ISingleResultSpecification marker interface. The sample code is calling this first method, which just works with one entity type and then returns it. If you need to use projection, though, you can use the second method, which operates on your entity type, but returns a different type using a .select. You can use this to optimize queries to return only needed properties. Remember that specifications are useful to define the expected shape of returned data in a query. This doesn’t just mean filtering the number of rows using a WHERE clause, but also determining which associations should be brought back with the query, and even which columns should be included. Let’s see an example of that. Returning to the specifications for the schedule, there’s another one called ScheduleForClinicAndDateWithAppointmentsSpec. One of the newer features in EF Core is “filtered includes,” and so by adding an include filter, we can make sure that this schedule, which is being used with a particular ClinicId, will only load in its appointments where they are for a given date that gets passed into the specification. You can use this specification, by the way, as an example when you complete that to do task that we just saw in the list endpoint. Compare this code to how we solve this problem in the previous version of this course using custom SQL queries and a custom ScheduleRepository. The specification has replaced all of that with a single specification class containing all the query logic, and the calling code simply needs to create the specification and then pass it to the repository. Unlike custom LINQ expressions that might be anywhere in our application, specifications are easily tested in isolation. In the IntegrationTests project, you’ll see several different tests that demonstrate the various schedule specifications and ensures they work as expected. These tests use a real database, since .include logic can’t be tested with an in‑memory collection. For the last specification that we looked at, which only includes the appointments for a given date, you’ll see that there’s an integration test that adds a number of appointments on different dates and then uses a repository to fetch back a schedule using the ScheduleForClinicAndDateWithAppointmentsSpec and a specific date, and it verifies that we only get back the appointments for that date and not the appointments that are on different dates, which verify the behavior of many of the abstractions and implementations in our domain model.\nReview and Resources Once again, let’s begin a review with some of the important terms you learned in this module. First, and most importantly, the focus of the module, repositories, which encapsulate the data persistence logic, add, update, delete, and retrieve. In the case of domain‑driven design, we use repositories to focus on aggregate roots. Key to building flexible repositories is the specification pattern, which guides you to encapsulate business rules in a way that they can be passed around and acted upon in other methods, classes or APIs. You learned about persistence ignorance, which describes objects being ignorant about how they are persisted into data storage. It’s another critical aspect of domain‑driven design. Steve and I also talked about ACID, an acronym to describe transactions as being atomic, consistent, isolated, and durable. Another acronym we talked about is SOLID, which is a collection of software design patterns. ‑After introducing you to repositories and how they fit into the DDD mind map, you learned about their benefits and some tips for designing them. ‑We also addressed some of the debates around repositories, not only if you should even use them, but how to use them, for example, whether or not to return IQueryables. Many of these debates exist because of the complexity of balancing clean repositories with repositories that help you achieve the variations of queries required by your domain. ‑We introduced you to an often overlooked pattern, the specification, that plays a critical role in solving this problem with DDD. Remember that you are not on your own building specifications. You can lean on the NuGet packages that I created or just dig into my GitHub repo to pick and choose what you want to adopt. Links are coming up. ‑Steve gave you a great tour of how repositories are implemented in the FrontDesk application and then more deeply to see how these repositories are using specifications to provide the rich querying needed in the application. ‑Here are a number of links to not only my GitHub repo and NuGet packages, but a number of other resources we referenced, as well as some additional ones that we think you’ll find useful. ‑In the next module, you’ll learn about two more critical pieces of the DDD mind map, domain events and anti‑corruption layers, both which help provide some data pathways between the various parts of your software. Thanks again for watching Domain‑Driven Design Fundamentals. I’m Julie Lerman, ‑and I’m Steve Smith. Thanks for watching.\nAdding in Domain Events and Anti-corruption Layers Introduction and Overview Hi, this is Steve Smith. ‑And this is Julie Lerman. ‑In this module of Domain‑Driven Design Fundamentals, you will learn about domain events and anti‑corruption layers, two patterns for decoupling how the domain model communicates internally and with other systems. ‑We’ll start with domain events, which can be used to separate concerns, allowing different areas of the application to evolve independently, and sometimes helping with scalability as well. You’ll learn how to identify domain events in your system, and how to design domain event classes. Then we’ll show you domain events being used in a simple application, so you can get a feel for the structure and the workflow. ‑Then, you’ll get to see the domain events we built in our sample application, which are a bit more realistic. After this, we’ll turn our attention to another important element of domain modeling, anti‑corruption layers, which can be used as translators between bounded contexts and Legacy APIs.\nIntroducing Domain Events Domain events are a critical part of a bounded context. They provide a way to describe important activities or state changes that occur in the system. Then, other parts of the domain can respond to these events in a loosely coupled manner. ‑In this way, the objects that are raising the events don’t need to worry about the behavior that needs to occur when the event happens. And likewise, the event handling objects don’t need to know where the event came from. This is similar to how repositories allow us to encapsulate all of our data access codes, so the rest of the domain doesn’t need to know about it. ‑We can also use events to communicate outside of our domain, which we’ll look at in just a moment. Another thing that’s worth remembering is that domain events are encapsulated as objects. This may be different from how you’re used to coding events. It certainly was different for me when I first started learning about them. For example, in a user interface, events are more commonly written as some form of a delegate in another class, but here they’re first class members of the domain model. ‑Right. Although you can implement domain events using techniques, like the event keyword in C#, the domain events themselves should be full‑fledged classes. In fact, all of these parts of domain‑driven design are defined as objects in our domain model. ‑Vaughn Vernon describes domain events simply, saying we should use a domain event to capture an occurrence of something that happened in the domain. The domain events should be part of our ubiquitous language. The customer or domain expert should understand what you’re talking about when you say when an appointment is confirmed, an appointment confirmed event is raised. ‑You may already be familiar with the idea of events from working with user interfaces. ‑Many user interface clients, like .NET Windows Forms, Electron, or web pages, like the one shown here, make heavy use of events and event handlers. In this example, there’s a single page with a single button, and in the markup, you can see there’s an onclick attribute in the button that leads to a little JavaScript method defining what the app should do in response to a user clicking the button. ‑Events are helpful because they let us avoid a lot of conditional logic. Instead, we can write code that signals a certain thing has happened, and we can have other code in our system listen for these signals and take action accordingly. So in this kind of code, you don’t have a separate class for an onclick event, and it may take some getting used to that now in our model, we’re going to create a whole class to represent an event. Domain events offer the same advantages to our model as the events in the user interface. Rather than having to include all of the behavior that might need to occur whenever the state of one of our objects changes, instead, we can raise an event. Then, we could write separate code to deal with the event, keeping the design of our model simple, and helping to ensure that each of our classes has only one responsibility. Essentially, a domain event is a message, a record about something that occurred in the past, which may be of interest to other parts of our application, or even other applications entirely.\nIdentifying Domain Events in Our System ‑Be especially attentive to these kinds of phrases when discussing the application with your domain experts. When this happens, then something else should happen. If that happens, notify the user when, or inform the user if, these types of phrases frequently refer to situations that are important to the domain expert, the system, or the user. It might therefore be worth modeling these types of things as domain events. You may also discover behavior in the application that will benefit from being treated as domain events that may be the domain expert isn’t initially aware of. ‑Remember that domain events represents something that happened. Since we can’t generally alter history, this means they should be immutable. It’s a good idea to name the event using terms from the bounded context’s ubiquitous language describing clearly what occurred. If they’re fired as part of a command on a domain object, be sure to use the command name. Here’s some examples. ‑Depending on the application, it might be important to have events to represent when a user has authenticated, when an appointment has been confirmed, or when a payment has been received. Be sure to only create events as you need them in your model. You should follow the YAGNI principle, that’s you ain’t gonna need it. In other words, don’t create domain events unless you have some behavior that needs to occur when the event takes place, and you want to decouple the behavior from its trigger. You really only need to do this when the behavior doesn’t belong in the class that’s triggering it.\nDesigning Domain Events Here’s some more things to keep in mind when you’re creating domain events. We’ve already mentioned that domain events are objects, but to be more specific, each domain event should be its own class. It’s also usually a good idea to note when the event took place since frequently the code that’s handling the event might run some time after the event occurred. It can be helpful to create an interface or a base class that defines the common requirements of your domain events. For example, capturing the date and time the event occurred. ‑Also, when you’re designing your event, you need to think about the event‑specific details you want to capture. If it’s related to an entity, you might want to include the current state of the entity in the events definition. Think about what information you would need to trigger the event again. This can provide you with the set of information that is important to this event. Similarly, you may need to know the identities of any aggregates involved in the event, even if you don’t include the entire aggregate itself. This will allow event handlers to pull the information back from the system that they might require when they’re handling the event. Ideally, domain event objects should be lightweight, so you want to be sure you capture sufficient information to handle the event, but not so much that the event object itself becomes bloated. Since the main events are immutable, they’re typically fully instantiated via their constructors. And since they’re simply noting that something has happened in the system, they don’t usually have any behavior or side effects of their own.\nApplying Domain Events to a Simple App We’ve put together a simple console application that we’re going to use to demonstrate the value that domain events can have in your application. The idea behind this is to strip things down to as small a level as possible. Then, we’ll also show how domain events are playing a real role in a more real‑world way when we get to our veterinary scheduling application. This is a .NET console application with dependency injection. The main program just loads the needed services and runs the app. The app has a simple run method, which goes through the following steps. We can step through it with the debugger, so you can see the output in real time. The app loads services and starts running. It shows what happens when an appointment is created using a service. The service calls a factory method that creates the appointment. After instantiating the appointment, the factory method sends an email, which you can imagine includes code like what is in the comments here. Then, it similarly sends a notification to the user interface, again, with code like what’s in the comments before finally returning to the service. The service, then saves the new appointment in the database. Then, the app creates a different appointment and saves it directly using a repository instead of a service. And once more, the notifications and the save occur in the same order. Finally, the appointment is confirmed, which triggers some UI notification, and then that change, too, is saved. The main thing to take away from this example so far is that the Appointment class has a lot of concerns. The act of creating an appointment, especially, involves a lot of code that could fail. It’s also worth noting that notifications and emails are going out before the state of the entity is saved. So if something goes wrong, users will have been told the operation was successful, and people may have been notified via email when, in fact, the update itself might never go through. ‑The reason we’re showing the behavior both from a service and with the appointment directly is because our domains should be designed to work either way. Earlier in this course when you learned about domain services, we explained that forcing all operations on your domain to go through a set of services tends to lead to an anemic domain. Ideally, your aggregates and entities should behave correctly, whether they’re being used directly or through a set of services. One way we can improve this design would be to move the responsibilities of actually sending emails or updating the UI to help our methods or other services. Then, we could call them from appointment.create instead of having all the code in here. This would make for less code inside of Appointment. ‑That would definitely be better, but it would still mean that appointment would need to be updated every time a new requirement came along. There’s a principle we can use to avoid that, though, called the Hollywood principle. ‑I love the name of this principle. Its name comes from an old saying from Hollywood agents, don’t call us, we’ll call you. ‑Exactly. Applied to software, the principle is closely related to dependency inversion from solid. Instead of forcing appointment.create to have to know about and call every possible thing that might be involved in the appointment creation workflow, instead, it can just let the app know something happened and let the app respond by calling handlers. ‑Instead of putting all the logic into this method, potentially making it huge and complicated and really hard to read, we move that logic into handlers, and the app calls the handlers. We don’t call the handlers, the app calls us. And beyond just reducing the amount of code and responsibility inside Appointment, this approach also lets us make sure that notifications to the user don’t occur until persistence is successful. And it still keeps the model’s behavior consistent without requiring a service to perform any of the work. Let’s see how it works. ‑Domain events is a pretty simple pattern, but you do need to have some plumbing code to support it. You also need to think about whether you want your events to fire before or after persistence. In many cases, what you really want is postpersistence events for the reasons we mentioned above. You want to make sure your persistance succeeds before you send any notifications outside of your app. Also, although occasionally I’ve used them for validation in the past, ideally, your domain events and handlers should never fail. That is, don’t build your behavior around exceptions that might be thrown from event handlers. Use a different pattern if you need that type of behavior. ‑In this simple demo, which mirrors how our sample app works, we just need a collection of events on each entity. We’re creating simplistic types to represent domain events and the respective handlers. You can implement the logic to find and call handlers whenever an event is dispatched in a number of ways. For this sample, we’re using the MediatR NuGet package created by Jimmy Bogard. Steve mentioned that you’ll need some plumbing to start, and that plumbing is the interfaces or base classes, if you prefer, for handler and domain event classes. In our example, we’re using interfaces. Here’s the IDomainEvent interface and the IHandle interface. ‑Once you’ve set up your event and handler interfaces or base types, it’s time to create some events and their associated handlers. ‑For this scenario, there are two things happening, an appointment is scheduled or created and an appointment is confirmed. An event is something that already happened. So we name our events in the past tense, and we have AppointmentCreated and AppointmentConfirmed. The event classes are pretty simple and just include the instance that triggered them, so handlers have access to any properties they might need from it. Once the events have been defined, you just take each individual responsibility out of the original method and create a separate handler for it. It’s fine to have multiple handlers for the same event. Ideally, your design shouldn’t depend on the order in which the handlers execute. But if it does, you can think about adding a sequence to your handler interface and ensuring they’re called in sequence order. ‑The last thing you need to do is register or record the events on the entity. In this sample, that just means adding them to the list of events that are on that entity. The actual implementation for dispatching the events is done in the repository after the save is successful. And in our veterinary sample, this work is done in the DbContext SaveChanges method. ‑Let’s step through the code again now that it’s using domain events. ‑The app starts up as before. We enter the appointment.create method. ‑And look how much smaller that method is now. ‑Definitely. It’s way easier to see what’s going on here. Now the domain event is added to the collection, but notice that when we step over this, nothing actually happens yet. ‑Right, it’s just holding it until after the entity is persisted. ‑Which is now. Notice that we’re in the repository Save method. And for every event that we have stored on this entity, we’re using MediatR to publish it at this point in time. ‑This is still in process on the same thread. There’s no out‑of‑process queue or anything involved here. ‑Right, there’s nothing to install using this pattern except for MediatR, and that just runs in‑memory. And, of course, you could wire this up with your own code that simply loops over your set of events and then dispatches out to your handlers. There’s nothing that says you have to use MediatR. Notice in the output that the DATABASE Saved occurred, and then the UI and email notifications. ‑As expected, we only triggered side effects outside our domain after persisting. Now let’s see the version that uses the repository directly and doesn’t bother going through the service. ‑We basically see the same behavior, DATABASE Saved, UI, EMAIL. ‑All that’s left now is the confirm and save, which should look similar, entity saved, and then the UI is updated. ‑That’s basically it. I created a small GitHub repo, which has just this sample in it. It’s at github.com/ardalis/DomainEventsConsole. There’s a branch there showing how things work without events. Of course, you can also download it from the course details. ‑If you want to start your solution with all of this plumbing already in place, you can use Steve’s CleanArchitecture solution template, which is also on GitHub. He is one productive guy. Everything shown here is already in place in the template, which is designed for you to use as a starting point for your app.\nExploring Domain Events in Our Application Now let’s look at how we’re leveraging domain events in the veterinary FrontDesk scheduling app that we’ve been working with. Again, we’ll start by showing you the code, and then we’ll debug through it so you can see it in action. ‑In our Appointment class, we’re going to record a domain event when certain changes are made to the appointment. So, if we scroll down and take a look at the UpdateRoom method, you’ll see that it creates and saves an appointmentUpdatedEvent. The same is true for the other update methods like UpdateDoctor, UpdateStartTime, etc. They each will create an appointmentUpdatedEvent and pass it the current instance of the appointment, and then this is saved into the entity’s Events collection. ‑In the case of the Confirm method, it’s similar, but it creates a different event, an appointmentConfirmedEvent. Essentially, the appointment entity can trigger two kinds of events directly, change and confirmed. And you’ll notice it only does so if an actual change takes place. Calling an update that doesn’t change the current value will not trigger a new event. ‑Let’s take a look at the appointmentUpdatedEvent, and this is similar to the one we saw in the simpler console app in the previous demo. It inherits from BaseDomainEvent, which is defined in our shared kernel, and it adds a UTC timestamp property called DateOccurred that is set when the event is created. This can be useful for debugging purposes. The only other property the class takes is the appointment itself. The AppointmentConfirmedEvent, shown here, is similar. ‑Notice that these domain events are all defined in the core project with our domain model. For this sample, they’re in an Events folder in the root. However, in a large application with many events, it might make more sense to put them with the aggregate that they correspond to. In this case, the ScheduleAggregate. There’s one more domain event in our sample, which is the AppointmentScheduled event. It’s similar in structure to the others, but it’s actually created elsewhere. ‑Once you start working in event‑driven applications, it can be a bit more difficult to follow the flow of execution in the app where events are concerned. It really just takes some getting used to, and then you’ll find it to be second nature. The best way to see where events are raised and where they are handled is by looking at an individual event and examining its references. Looking at AppointmentScheduled, you can see that it is handled in the API project and in the core project. It is only created inside of the ScheduleAggregate itself. Let’s have a look at where that happens. ‑In Schedule, the AddNewAppointment method creates and saves the AppointmentScheduled event after adding the appointment to its collection and marking whether or not it’s conflicting. Once the schedule is saved, any appointments that have had domain events added to their respective collections will have them dispatched after the save to persistence is complete. ‑Before we step through the code, let’s have a look at one of the AppointmentScheduledEvent handlers. The thing to notice is that these handlers don’t get created or called anywhere in our code. That’s that Hollywood agent again from the Hollywood principle saying, don’t call us, we’ll call you. The event dispatching logic, in this case, using MediatR, is what calls these handlers at runtime. But at compile time, nothing references them directly. ‑Now let’s see the flow of domain events in our application when we change an appointment. We’ll modify this appointment for my little baby, Sampson, and change the appointment from a wellness exam to a diagnostic exam. But a diagnostic exam takes more time, and this will automatically change the duration of the visit, which should trigger a conflict with one of Sampson’s other appointments. Yes, he likes to go to the vet quite a lot. ‑The change initially hits the AppointmentUpdate endpoint. It loads the schedule and the appropriate appointment and calls its Update methods. In this case, the only one that has a change is the change to the appointment type. This intern adds an appointmentUpdatedEvent. Once the change is saved, the event is dispatched. The API project also has a handler, AppointmentUpdateHandler, that responds to this event by sending a message to the Blazor client using a SignalR hub. This will trigger a real‑time notification in the app. ‑What about communication between bounded context or apps using events? Applications and microservices frequently use events to communicate, too, but these aren’t domain events since they extend beyond a single domain. They’re frequently called integration events, and they may be defined as part of your domain or in a separate project or package. For simplicity, ours are here in this IntegrationEvents folder. ‑The FrontDesk has just two integration events, the AppointmentConfirmLinkClickedIntegrationEvent is published by another app and consumed by this one, and AppointmentScheduledIntegrationEvent is an event this app publishes and another app consumes. It’s important that the structure of the published and consumed types match, which is why frequently a shared package is used to define these kinds of events. ‑We don’t have time to dive deeply into distributed application architecture, but one thing you need to remember when designing integration events is that they typically will be enriched and denormalized when compared to a similar domain event. For instance, the AppointmentScheduled domain event just has a reference to appointment, and that only has IDs for the client, patient, and doctor. However, the integration event includes many more details like client name and email, patient name, and doctor name. The reason for this is to ensure that consumers of the event have enough information from the event to perform whatever actions they need to without having to immediately call back to the publishing app to ask it for more details. You can imagine that the performance of a system would suffer if every time an appointment event was published, one or possibly many apps that were consuming that event, turned around and immediately had to make calls to this app’s API asking for client details, patient details, and doctor details. Hence, we have a handler that is responsible for taking in a domain event and enriching it with the additional details shown here on the integration event. We’ll put these integration events to use in the next module.\nIntroducing Anti-Corruption Layers The last topic we want to discuss in this module is anti‑corruption layers. An anti‑corruption layer, as the name implies, helps to prevent corruption in your domain model. ‑Right, just like superheroes help to fight corruption, these layers provide a sense of security to your model when it needs to interact with other systems or bounded contexts. ‑Returning to our mind map, you can see that the anti‑corruption layer is used to translate and insulate as part of a context map, mapping between a bounded context and foreign systems. ‑When your system needs to communicate with other systems, especially legacy applications that weren’t written or modeled as well as your current system, you need to be careful not to let assumptions and design decisions from that system bleed into your model. For instance, if the other system’s model includes a customer, even if that customer refers to the same actual business customer, it’s likely that it will be modeled differently than a customer in your system. It’s best to have a layer that can translate to and from other systems’ models. In DDD, this is the job of an anti‑corruption layer. ‑Right, like we mentioned in the beginning of the course, even other bounded contexts in your own system may be different enough to merit having an anti‑corruption layer in place to protect the two distinct models from one another. And, of course, legacy applications frequently use very different models from newer systems. An anti‑corruption layer isn’t a design pattern, however, it’s usually comprised of several design patterns. The job of the layer is simply to translate between the foreign system’s model and your own. ‑In addition to translating the objects themselves, the anti‑corruption layer can also clean up the way in which you must communicate with the other system. It may provide a façade to simplify the API or an adapter to make the foreign system behave in a way that is known to your system. You can learn more about these design patterns in the Design Patterns Library on Pluralsight. ‑We’re usually most concerned with having an anti‑corruption layer in place when communicating with legacy systems. Eric Evans notes why that’s important. ‑Even when the other system is well designed, it is not based on the same model as the client, and often the other system is not well designed. ‑Since this is a fundamentals course, we’re not going to dig deeply into anti‑corruption layers, because they can be fairly complex, as well as very customized to each scenario, but here’s an example structure of one which comes from Eric Evans’ book, showing how an anti‑corruption layer can connect your beautiful system on the left with a not so beautiful system on the right. ‑I really like this diagram. I think Eric had some fun putting it together. ‑Gee, what gives you that impression, Steve? ‑Of course, in the middle you can see how the anti‑corruption layer is using a façade and some adapters, but on the right it’s protecting us from a big complicated interface, some messy classes, and some things we just don’t even want to know about. ‑Right, and of course, your own system is comprised of an elegant class, a very expressive class, and of course even more good stuff, and maybe even some stuff we should be refactoring as well. ‑There’s no one way to create an anti‑corruption layer. Whatever you need in order to insulate your system from the systems it works with is what you should put inside of this layer, which should allow you to simplify how you interact with other systems, ensure that their domain decisions do not bleed into your design, and ensure any necessary translation is done along the way.\nReview and Resources We’ve covered some new topics in this module, and there’s a few new terms that we want to make sure we review. Domain events are a type of object that actually represents something that occurred within the domain that other parts of the system may find interesting and want to tie their behavior to. And this is a great way to keep your system decoupled and to keep your individual objects simpler because they don’t have to know about all of the behavior that might occur when some event takes place. We also referred to the Hollywood principle, which can be summed up as don’t call us, we’ll call you. This principle is related to the dependency inversion principle from SOLID and is frequently used to decouple systems from one another. Instead of us putting all the logic we need in our code, we architect the system so that it calls back to us at the appropriate time. And we put our code into handlers that the app calls, rather than directly coupling our model to these actions. ‑And finally, we looked at anti‑corruption layers, which can be used to ensure that our model that we worked so hard to produce doesn’t become polluted by the models of other systems we work with based on objects they wanted to return to us or the type of API that they want us to code to. So we put anti‑corruption layers in place to shield our model from those other systems or bounded contexts that we might work with from our bounded context. ‑In this module, we introduced domain events, and hopefully, you have a good idea of what they are at this point. ‑We’ve talked about how you can identify opportunities to use domain events based on the kinds of requirements your customers give you, as well as when you see code in your model that’s doing too much and could be more loosely coupled. ‑We gave you some tips for designing and naming domain events, and then we showed them in action, both in a relatively simple console app, as well as in our much larger veterinary clinic sample application. ‑Finally, we introduced the concept of anti‑corruption layers, which use a variety of design patterns to insulate our model from the design choices of other applications or bounded contexts. Here are a number of resources where you can learn more about domain events and anti‑corruption layers. Some of these, including a few Pluralsight courses, we mentioned in this module, but there are others that we find to be relevant, even if we didn’t explicitly mention them. ‑Up next, we’re going to wrap up this course by adding a new feature to the application. Because of our clean architecture and well‑designed domain model, it’s going to be pretty easy to integrate into our existing app. I’m Steve Smith, ‑and I’m Julie Lerman, and thanks for watching this module of our Domain‑Driven Design Fundamentals course.\nEvolving the Application Easily Thanks to DDD Introduction and Overview Hello, this is Julie Lerman, ‑and this is Steve Smith. In this module, we’re going to wrap up our course on Domain‑Driven Design Fundamentals by showing how we can reap the benefits of our design when it’s time to add additional functionality to the system. ‑In this module, we’ll first review our current system design and see how it incorporates DDD patterns and practices. Then, we’ll circle back to our customer, Michelle, to see how the new vet clinic appointment management system is working out. ‑During that quick conversation, we’ll learn about a new feature, and we’ll show how we can implement that feature. ‑We’ll leverage message queues to implement this feature, so we’ll definitely be sure to share with you some of the basics about message queues before we show you that code. ‑The main benefit of our design choices is the ease with which the system can be extended and maintained in the future. And we hope you’ll agree that adding to the current design is quite straightforward.\nReviewing Our Current System Design So far, our system is pretty simple, though it’s fairly complex, as most course demo apps go. ‑The system is currently two different web applications, although the user interface makes it look like a single app. Our main focus has been the application used by clinic employees to schedule appointments. There’s a lot of complexity with scheduling, so this benefited from domain‑driven design. There’s also a clinic management application that’s used to do simpler data‑in/data‑out tasks like record keeping and maintaining information about doctors, clients, patients, and more. Let’s review the scheduling app a little more closely. ‑We have a single aggregate for a schedule, which contains a number of appointments. We limit access to the schedule through the schedule repository class, which is responsible for retrieving and storing the schedule in our database. We’ve identified a couple of value objects that allow us to better model concepts in the domain, and we’re making use of domain events to allow our domain in other parts of our system to respond to changes in the state of our model. ‑It’s taken us a while to get to this point, but now that we’re here, the design of the system is very clean, and it reflects the customers domain, as well as we’ve been able to model it so far, of course, given some time constraints. ‑Yes, we do have to ship the app, I mean, this course, at some point. ‑Right, of course, as we build on this application, our model would continue to evolve. But we’ve shown you techniques you can use to ensure that you can grow the application without being overwhelmed by the complexity you’re trying to model. ‑Actually, as it turns out, the customer does have one more request for us. She said something about customers forgetting their appointments. Let’s have another quick conversation.\nAddressing a New Feature with the Domain Expert As it turns out, the customer does have one more request for us. She said something about customers forgetting their appointments. Let’s have another quick conversation. ‑Hey, Michelle, great to see you. How are things going with the new scheduling application? ‑It’s been fantastic. We’re really able to see very easily who scheduled each day, and book new appointments, and move things around is needed, and the front desk folks really appreciate that it highlights the appointments that are conflicting or unconfirmed. That makes it much easier for them. But one thing that’s still a problem is the fact that sometimes our clients forget their appointments. It probably happens at least a couple of times every day, and our staff really don’t have the time to call every client to make sure they remember ahead of time. ‑So, you’d like the system to call them then? ‑Well, we understand there’s services that’ll do that sort of thing and we might move to that eventually, but for now, if we could just send an email that would probably help remind clients to put it in their calendar. ‑Oh, okay, so, do you want an email to go out when they schedule the appointment or on the day before they’re scheduled to come in, or maybe even both? ‑Oh wow, if we could do both, that would be great, one to let them know when they’ve booked so that they know that we’ve got it in our schedule and another one to remind them that they have an appointment the next day, just in case they forgot. ‑That shouldn’t be too hard. Our model already handles certain events that occur, like when appointments are scheduled, and appointments already support being marked as confirmed too. ‑Sure, and I think all we’ll really need to build that’ll be new is some kind of service for sending the emails and some way for clients to click a link in the email so they can confirm the appointment. Since it’s email, it shouldn’t be a problem to send these out the day before, even if that day isn’t a week day or a work day, right? ‑No, I think that should be fine. It shouldn’t hurt anything to send an email on a Sunday or a holiday, and of course, we’ll ask our clients to opt into these reminders so we’re not sending anything unsolicited. ‑Sounds good. We’ll get started, and should have something for you to review real soon.\nPlanning Our Implementation Steps Before we get into the gory details of the implementation, we just want to make sure that you understand the very high level of what we’re doing here. The first thing is triggered when the appointment is scheduled. And in response to that, our system will send a confirmation email to a client. ‑Once the client gets that confirmation email, they can click a link to confirm that they’re going to make it to the appointment, and the system will then mark that appointment as confirmed so that on the schedule, the staff will see that it’s got a green box around it, and they should expect the client will actually show up. ‑What’s nice about this implementation is that it benefits so much from a lot of the infrastructure we already have in place. And thanks to our DDD‑based architecture, it’s just as easy to add in a few extra features that we need to make this work. ‑So as we go through this, you’ll see us using some existing and some new domain events, some application events, a number of event handlers and services. One new tool you’ll see is something we haven’t talked about yet, messaging queues to communicate between separate applications. The application we’ve been working with will need to communicate with a public website that the customers will interact with when they confirm their appointment.\nIntroducing Message Queues Before we go any further, we did just mention something new, which is message queues. And we just want to talk about that a little bit. It’s a pretty advanced topic for this fundamentals course, so we’re going to talk about it at pretty much a high level. ‑Message queues are nice to use between applications for a number of reasons. They can help decouple them and make it so that one of the applications can just drop off something into a message queue and continue on with its work and not have to worry about what happens to the message after that. ‑Right, or if whichever application or applications it’s trying to communicate with, it doesn’t need to worry if that application is available and listening at that very moment. The message can sit in the queue and when the other application is ready to grab it, it does. With a message queue, we’re really just dealing with a single message. One application drops it, and the other one takes it, and then the message is gone. ‑Yeah, and there’s lots of different implementations of message queues that you can find online. Some of them are free. Most of the cloud services that are out there now have these types of things built in as well. ‑And what we’re doing here is dealing with a single message at a time in something of a silo app since we control both applications that are communicating with each other. But sometimes you need to have a lot more flexibility than that, you might actually have a number of applications that are interested in that message and you may not even know in advance or control those applications. So this is when something called a service bus comes into play. ‑Right, so you’ll frequently hear about something called an enterprise service bus. And there’s, again, a number of examples of these that you can find available. It usually sits on top of message queues and other features. And one of the responsibilities it has is making sure that messages get delivered to the different applications that care about that message. ‑It might even be an application that didn’t even exist or you didn’t know about when you were first setting up the message queue. So even at that point, because service bus allows you to decouple the routing of the message, it’s possible to go ahead and hook up other applications to listen to the queue. ‑Right, so you’ll see in our scenario that we have our scheduling application raising an event that an appointment was created. And it might be that maybe in the future we would want to add some other application that wants to react to that event. ‑We could publish it to social media, hey, I’m going to go see the vet. ‑Exactly. If we had a service bus, we could simply wire up in our service bus for this new social media notifier service, pick up that event. But with just message queues, as you’ll see in our implementation, we would have to change our scheduler application to know about this new app and write to its queue because we don’t have any advanced routing, everything’s hardcoded in our simple scenario. The message queue we are using is RabbitMQ. It’s a mature, open‑source message broker that you can get set up and running with zero install by using a prebuilt Docker container. It has a lot of capabilities, but we’re keeping it simple and just using it to define a few specific queues, which are separate bounded contexts we’ll use to publish and consume events.\nSending a Message to the Queue Now let’s take a look at how we’re adding message queues into our solution. The first part of the process happens when the appointment is scheduled. And you’ve already seen our AddNewAppointment method inside the schedule aggregate root. And you saw how the domain uses domain events and domain services to notify the user interface if there’s a conflict in the schedule. In the previous module, we showed you MediatR, which we’re using to publish these domain events. And we also talked about integration events, which are structured to be shared between different applications. So what we’re going to do in our system is add RabbitMQ into the mix at the same point where MediatR is publishing the domain events. But we’ll ask RabbitMQ to publish our integration events. These events will be formatted as JSON data before they’re inserted into the queue. So let’s see what this looks like in the application. We’ll be looking at the code that makes all of this work a little further on in this module. We’ll go ahead and create a new appointment. Let’s bring Sampson in to see Dr. Jones again. So there’s the appointment. Nothing has changed from the perspective of the user. RabbitMQ includes a user interface to inspect the queues, and in the Front Desk app the menu has a link so that you can open up this admin page and see what’s going on with the queues that are associated with this application. We’ll head to the Queues page and then drill into the vetclinicpublic queue, which is a queue that we set up to handle communication between the Front Desk app and the VetClinicPublic app. And you can see that the one and only message that RabbitMQ is tracking is in that queue. So we’ll drill into that queue and then scroll down to see the details of the message itself. And the most interesting part, the payload, which is the JSON expression of the event data. You can see the GUID value of the AppointmentId, the ClientName is Julie Lerman, an email address, which is not really my email address, the PatientName is Sampson, and other relevant details that came from the integration event. So the Front Desk app knew to publish the message to this queue, and our VetClinicPublic app knows to read from this very specific queue in order to perform the task of emailing the client.\nReading From the Message Queue and Acting on the Message Now that the message is waiting in the message queue, it’s time to read the message and act on it. And acting on it is the next step in a workflow, sending an email to the client to let them know about the appointment they’ve just scheduled. We can’t do this easily from our scheduler application because we need for the user to be able to click on a link that specifies that they want to confirm their appointment, so it needs to be publicly accessible. So we’ve decided to put this on the veterinary clinic’s public website, and so that will be responsible both for sending the emails and for hosting the link that the customer will click. The public site uses a hosted service to periodically check for new things in its queue. Once it finds a message on the queue, it will retrieve the information from that message to create a confirmation email using code like what you see here. One of the most important pieces of this email is a link back to the public website, not really localhost, which includes the GUID that represents the appointment ID. The website then sends the email. That’s what the user will end up clicking on in their email and trigger a confirmation using the website. Alright, so now we’re looking at the vet clinic public website, which is a super simple demo solution that we put together. And one of the things it does when it starts is start checking for messages, which you can see here. But we don’t have it running quite yet because it would’ve already pulled the message out of the queue. First, we’ll show you the code that’s making this all work, and in a bit, we’ll step through while debugging. The public website has a hosted service called FrontDeskRabbitMqService, which periodically checks the message queue to see if anything new has arrived. As soon as it finds one of those messages off of the message queue, it’s going to send an email, and we’re going to use a tool called Papercut, which will emulate a local email server for the purpose of testing. Rather than installing this on our dev machines, we’re running a Docker container to host Papercut. You can view emails Papercut has received by clicking the Sent Emails link from the FrontDesk app’s menu. Currently, there aren’t any emails in Papercut, but as soon as we start the web application, it’s going to check our message queue and then send an email that we should see appear in Papercut. There’s a message, the same message that we sent out for Sampson’s appointment. There’s a hyperlink that leads us back to being able to confirm. Let’s see first, high level, what happens when we click on that CONFIRM button, and then we’ll come back and click it and watch it in action. So now the user has the email, and their beautiful CONFIRM link in the email. When they click that, it opens up the website, browsing directly to the GUID that was their appointment. And in response, the website calls its own method called confirm, which takes the relevant appointment ID and pushes it into another one of the queues. You’ve seen the message queue that was used for relaying the message from FrontDesk to the public website, and that was named fdvcp‑vetclinicpublic‑in. Try to say that five times fast. But you can have as many queues defined in your system as you need. And one of the other queues that we’ve defined is for relaying messages from the public website, in other words, when the client has clicked on the button to confirm their appointment back to the FrontDesk app.\nUsing Multiple Queues to Handle Various Communications Now that the email’s been sent, let’s see what happens when the client clicks on the CONFIRM link in that email. ‑When we click on that, we’ve now confirmed the appointment. Once the user clicks on the CONFIRM link, it drops the message with the confirmation back into the scheduler queue, and you can see that message right here. ‑Yeah, this middle queue shows that there’s one message. Let’s look at it. We’ll scroll down to the Get Message(s) button, and the message is retrieved and displayed. We’ve seen this before where the payload is the JSON data we’re looking for, and this one contains the appointment ID that’s just been confirmed. Now you can see that the two different applications are communicating back and forth with each other using their two separate message queues. We’ve named the queues so that it’s clear which applications are using them to communicate and in which direction. The initial acronym specifies which two applications are involved. Fdvcp means frontdesk and vet clinic public. The latter part of the queue’s name says which app is listening to it. The last step now is for this confirmation information that’s sitting in the queue to get back to the scheduling app. ‑Now in our scheduler application, we have implemented a hosted service just like you saw in the public website This one is called the VetClinicPublicRabbitMQService, and it listens to the appropriate queue to see if there are incoming messages that it needs to deal with. When it finds one, it responds to the AppointmentConfirmLinkClickedIntegrationEvent, yes, it’s a long name, with the email confirmation handler. The handler looks up the appointment from the AppointmentId that was contained inside of the message, and from there, it calls Appointment.Confirm. Appointment, as you recall, is our entity, and its confirm method also then triggers some domain events, which for instance, our user interface listens to. And when it sees that that event has been fired, it triggers a change in the UI, enhancing the appointment with a green bar across the top to show that the appointment has been confirmed. Okay, so all that’s going to happen at this point is that when the message comes through, it’s going to make the Sampson appointment right here have a green border and pop up a dialog to let us know that a change has occurred. ‑It’s very slick. This is actually really easy to implement because we already had the website listening for events. Remember how it was able to display new appointments and display conflicts? We’ve implemented another design role based on a particular property of the appointment, which is confirm. All we did was set up another event handler. ‑We wrote the original sample for the first version of this course in 2013. At the time, things like SignalR and WebSocket, as well as emails with confirmation links were relatively rare, although we certainly didn’t invent these kinds of app interactions. ‑Right, but now, every time I make an appointment for my dentist or hair and even for Sampson in real life to go to the vet, I’m getting texts or emails with exactly these kinds of confirmation links. ‑I know, I guess maybe a lot of businesses watched our course.\nDebugging to See the Detailed Implementation in Code Now we’re going to take a deep dive into the code that makes all this work, and we’ll go through it step by step so that you can see how all this is wired together. And we’ll do that by literally just debugging through the whole process, so you can see how all the code links up. Remember, all of the code for this sample is available on GitHub, and we encourage you to run it yourself to really understand how it works. The README file has instructions for running the solution using Docker, which is the recommended approach if you just want to see it running. There are also instructions for using Visual Studio or VS Code, which you will need if you want to debug the apps as we’re about to do. For instance, I need to run RabbitMQ and PaperCut using the Docker commands shown here, before I can debug the app, as we’re about to see. We’re back in the vet manager, and the user is on the phone with Steve who wants to make an appointment with Darwin. Everything works just the same way it’s worked before. We’ll go ahead and add a new appointment and save the appointment, which triggers the ScheduleAggregate root’s AddNewAppointment method. We’ll leave the Locals window open while we’re debugging so that if you want to pause the video and take a look at any of those values, you can do that. We haven’t changed anything in the method. The only thing that’s different is that now we’ve got an additional subscriber that’s listening for this domain event, this particular domain event, the AppointmentScheduled event, to be raised. So we’ll go ahead and raise the event and watch what happens. At this point, we’re looking at a new class that we created, which is this RelayAppointmentScheduled service, and what it’s responsible for is creating the event that is going to get pushed onto the message queue that the public website is listening to. This is the new piece of logic that’s listening for the event that we just raised. You can see it’s listening for AppointmentScheduledEvent, a domain event, and in the method, the first thing we do is to create the AppointmentScheduledIntegrationEvent that represents our cross‑domain message that will be sent using RabbitMQ. The functionality we need from this event right now is to be able to send an email to the client, so we make sure to include all of the data that such an email would require. Now we’re in the Publish method that lives inside of RabbitMessagePublisher, and that’s inside of an infrastructure project. We’ve moved out of the core domain, but this is still part of the main front desk scheduling application. Yes, and what it’s responsible for doing is actually getting that message into a structure, a format that RabbitMQ can use. That means putting things into JSON format in this case, and then actually sending the message. Once this fires, we should be able to inspect the message queue in RabbitMQ, and verify that our message has actually been queued up for the VetClinicPublic input queue as expected. That’s what we did before, but this time we’re actually seeing the code that’s making all of this happen. Alright, so that completes the actual thread of the UI. The response is complete for this part of the application. Now we’ll pause this and switch over to the VetClinicPublic application. We’ve just started it up again, and we’ve shown this to you before. Now we’re going to watch the flow of the code after the hosted service starts up. Jumping to the next breakpoint, you can see now we’re inside of the actual HandleMessage method, which gets the message as a string. It’s responsible for parsing the string using JSON, and deserializing it into an appropriate type. This is just demo code, so it’s not the most reusable or elegant, but it works for this app. Remember that any change to the integration event in the front desk app will require changes here as well, which is one reason why a shared package can be useful for keeping applications in sync. Once we’ve deserialized the message into a command, we use mediator to send the command, and a separate handler to actually send the email. This keeps extra code out of the hosted service, and lets the handler use dependency injection to get any services it needs. In this case, it’s an implementation of, I send confirmation emails, called ConfirmationEmailSender. It’s the service that builds the email with its details, including the URL behind the CONFIRM link in the email that the client receives. Remember, the whole reason why we need a separate app to implement this feature is that the end user needs to be able to click a link that goes to a public location on the internet. The front desk app is an internal app that runs inside the vet clinic’s network so it’s not accessible. The public website is a good place to send users, and while they’re there, they can get more details about the clinic, or buy something from its theoretical online store, etc. After the email has been sent, we can see it in PaperCut, and opening it, we can see the CONFIRM hyperlink. Clicking the link brings us back into the VetClinicPublic application’s, AppointmentController class. This endpoint simply creates a new event. This is the one with a really long name, AppointmentConfirmLinkClickedIntegrationEvent. Unlike the name of the event, the message itself is really simple, and just includes the appointment ID that was confirmed, and when it happened. The controller action then sends the event using a RabbitMQ messagePublisher that’s identical to the one we just saw the front desk app use. However, this publisher’s destination is actually a different queue, the front desk input queue. Technically, the front desk has two input queues, one for messages from the ClinicManagement app, and another for messages from the VetClinicPublic app. In this case, we’re talking about the VetClinicPublic one. Back in the front desk scheduling app’s hosted service, it discovers the message on the queue, and calls into the HandleMessage method in the service we’ve seen a number of times, the VetClinicPublicRabbitMqService. Here, it parses the message and extracts the appointment ID, which it then uses to create and publish that really long‑named event again, AppointmentConfirmLinkClickedIntegrationEvent internally. This integration event triggers a call to the EmailConfirmationHandler, which loads the schedule aggregate, then locates the appropriate appointment, and calls its Confirm method. Finally, it saves the schedule. The appointment.confirm method makes an appointmentConfirmed domain event, which is fired once the aggregate is saved, and this event in turn triggers a handler in the UI. The appointmentConfirmed handler in the FrontDesk UI sends a message via SignalR, indicating the message was confirmed. This results in the browser showing a notification, and changing the format of the appointment to have a green border. You already saw similar logic used for the AppointmentUpdate and AppointmentScheduled handlers. That’s the full round trip for how creating an appointment, getting an email, clicking a link, and confirming that appointment works for this application.\nConsidering Microservices Since we published our original version of this course, which if you haven’t watched, you’ll find a link from either of our author pages, microservices have become incredibly popular. There are some benefits to microservices, even if they’re probably a bit overhyped at the moment, and there are some obvious parallels between microservice design and DDD. ‑Microservices should be self‑contained and should not depend on other microservices. They should be independently deployable. Changing the internal behavior of a microservice should not break services that work with it, as long as it maintains compatibility with its external APIs and message interfaces. ‑So, basically what you’re saying is each microservice should have a boundary around it, and within that boundary it should focus on a specific set of behaviors that its free to model however it sees fit. ‑That’s right. ‑It’s almost like each microservice can be considered its own context, and it has its own terminology and even language for how it’s designed. ‑It is a lot like that, it’s true, and it’s not unusual for teams to treat individual microservices like bounded context with their own ubiquitous language and everything else that goes along with being a bounded context. But, beware of assuming that microservices and bounded context always have a perfect alignment. There can be plenty of scenarios where this could be a problem. My brilliant friend, Vladik Khononov, not to be confused with the also brilliant Pluralsight author, Vladimir Khorikov, has shared his experiences along these lines in his blog and also in recorded conference presentations. We’ll include links to his content in the resources at the end of this module. ‑Now, this isn’t a microservices course, but obviously if you’re working on microservices, it would be helpful for you to have a good understanding of DDD concepts, because many of the problems that microservices solve are also solved by domain‑driven design. ‑In our sample application, there is an obvious candidate for a microservice. In fact, it’s almost there already, the confirmation email sending logic that currently runs inside the public website. ‑We put the hosted service in that existing web application because it was convenient and because the two are loosely related since the emails include a clickable link that goes to a page on that public website. ‑But we could easily move that hosted service into its own process and treat it like a separate microservice, and that would simplify the public web app, so it would no longer need to have a two‑way relationship with a front desk app by way of message queues. Also, the front desk app is likely to be updated more frequently than the confirmation email logic, so it’s possible that changes to the front desk application could break the email logic. ‑Yes, one of my favorite benefits of carving out a microservice is that if it’s something stable and working, you get the benefit of just leaving it the heck alone. Updates to other parts of the app or system are much less likely to break a microservice that is in production and working, and not being deployed frequently. ‑Right, and the email sending logic is about as micro as a microservice can get, but in the future we might want to add other kinds of customer emails to send, and it would be a logical place to hold that logic. ‑Exactly, and since it has no user‑facing logic, it’s a pretty simple change to make. Maybe some of our students could do that as another exercise.\nSharing Some Tips for Extending and Running the Sample Application As we wrap up the course, we want to remind you, once more, that there are a number of to‑do items in the sample that you can use as ideas for ways to extend this demo app. Doing so would help you gain real experience working with the architecture and patterns you’ve learned in this course. You’re sure to learn and retain more from actually working with the code than from just listening to us or watching us show you the code. ‑We do have detailed instructions in the README for how to run the app. You can run the individual solutions in Visual Studio, but if you do so, keep in mind, you’ll also need to make sure you have a local SQL Server running, and you’ll need to update the connection strings and app settings for the applications to access it. You’ll also need your own RabbitMQ and Papercut or similar test email server running, either as Docker containers or locally‑installed services. There’s definitely a bit of effort involved in getting all of this set up and running the first time. ‑Alternatively, if you just want to run the app and see everything working, you should be able to do so with just two commands, assuming you have Docker installed. Just run docker‑compose build ‑‑parallel and then docker‑compose up. Each of these commands might take a few minutes. It usually takes about 2 minutes for the build step on my machine, and it’s normal to see some errors when the docker‑compose up command runs until all of the services are up and running. Once the process stops outputting messages to the log window, you should be able to hit the application. To do that, take a look at the ports that are shown in the README file. And in the Docker column, you’ll see the ports for all of the different applications and utilities that are used.\nConsidering the UI in the Domain Design The control we used solved a number of the problems we thought we were going to have when embarking on this application. But the fact that the UI kind of impacted how we designed our domain begs the question about, well, if you’re totally focused on the domain, why would you even be thinking about the UI? But thinking about the UI while we’re working on the domain is not the anti‑pattern you may think it is. ‑Yes, we’ve been focusing on the domain, but frequently the user interface needs to be considered, especially in the early stages of planning. You don’t want to try to flesh out the whole domain design before you start thinking about the UI. ‑In a TechEd session I attended in 2013, Jimmy Nilsson, who’s the author of the book Applying Domain‑Driven Design and Patterns, talked about the importance of thinking about the UI in the early stages of planning and revisiting it while modeling the domain, rather than ignoring it until the end. In his session, he describes how even the UI sketching he does in the early stages of his application planning can affect the whole design of the system. As we were building this scheduler sample for this course, we actually discovered a huge benefit to considering the UI early in the process. We initially had expected to encounter a lot of complexity in the appointment scheduling problem, but we found a UI control that helped visualize the schedule for the user, such that the system no longer needed to be as complex. In our scenario, scheduling is a big part of the application, but it isn’t our domain, our domain is the veterinary clinic. We consider scheduling to be more of a cross‑cutting concern, and one that could be partially solved through a rich user interface. ‑By considering and using a rich user interface, we were able to do things like allowing conflicting appointments while making it obvious to the user that this had occurred. This gives the user more information, and they can make decisions about whether or not they need to correct the problem. When we initially considered the problem of appointment conflicts, we had thought the domain model would throw exceptions anytime something like that occurred. But this would have resulted in a much worse user experience. Frequently, in domain‑driven design, you need to consider the user experience, which at times may need to allow for models that are, at least temporarily, in an invalid or incomplete state. Keep this in mind as you design your domain model, and be careful not to make it too rigid to support scenarios your users may benefit from. ‑Thinking about the UI up front and discovering this kind of solution kept us from wasting a lot of time trying to solve certain scheduling problems in our domain. Of course, you don’t want your UI to totally drive how you model your domain, but as Jimmy Nilsson notes, you shouldn’t ignore it, either.\nModeling with Event Storming and Other Techniques When you’re developing apps using DDD, it can be helpful to visualize how processes communicate both within a bounded context and between context as part of a business process. As we mentioned earlier in this course, Alberto Brandolini has done a lot of work on a related practice called event storming. Event storming can be used by all parts of a business, not just developers, to describe how a part of the business works and to make the whole thing visible. Once this is done, later iterations of the diagrams and artifacts produced can be useful for modeling the software that will be used by the business. ‑You might recall the image we showed earlier of Julie facilitating an event storming workshop with a client. The result of that first iteration, called chaotic discovery, is not so easily captured, but it provides guidance for the later modeling you might do. ‑There are many ways to model your system. Another method, Event Modeling, championed by Adam Dymitruk, is another process, and this focuses on the inputs and outputs of events and how each of those events changes the system and changes state. And you can describe an entire system with this flow. ‑We’ve used the wonderful online tool called a Miro board at miro.com to show one perspective of the scheduling system as information flows through the front desk application and into the VetClinicPublic website bounded context. The colors used here correspond to different things in our model, like aggregates, events, and other processes. ‑And there are other modeling processes that have been invented, adopted, and adapted within the DDD community. And many of us rely on a combination of processes and tools to help us and help our clients better understand their systems before embarking on design. But as always, balance is important. You’ll want to beware of analysis paralysis. ‑Definitely. That reminds me of something Eric Evans talked to us about.\nEric Evans on the Fallacy of Perfectionism Steve and I believe that it would be fitting to leave you with one last thought from the father of domain‑driven design, Eric Evans. Eric was kind enough to talk to us about DDD when we originally created this course so that we could share with you some of his wisdom. Eric talked about the fallacy of perfectionism, which aligns with our own sentiments about considering what you’ve learned here to be guidance to help you solve complex software problems, not a roadblock to productivity. ‑Eric shared with us that what he’s noticed is that there seems to be something about DDD that brings out the perfectionist in people, and they say, this model is not really good enough and churn and churn, trying to improve it. He says, no model is ever going to be perfect. ‑Eric goes on to say that we need to know what we’re doing with this thing, the scenarios we’re trying to address. We want a model that helps us do that, that makes it easier to make software that solves those problems. That’s it. ‑This reminds me of the saying, all models are wrong, but some are useful. Our domain models don’t need to be perfect. They just need to help us build the software that helps people solve problems and get work done. Don’t strive for a perfect model, but rather just aim to develop a useful one.\nLessons Learned Since Our 2014 Course Julie and I wanted to finish this course by spending a couple of minutes talking about some of the things we’ve learned since we published the first edition of the course in 2014. ‑We’ve received a ton of positive feedback from so many of you over the last few years, and we really appreciate it. So we did our best not to change the overall flow of this course too much since we know the last one was so well‑received. ‑Definitely. If you watched the original version, hopefully you found this one to be fresh, but familiar, and I suspect a lot of students will end up watching both as a way to cement some of these concepts or just to spend more time with us, right, Julie? ‑Maybe. Now let’s highlight some of the things that have changed in the last few years. From a strict DDD perspective, there are a lot of new resources and techniques that have emerged as more and more companies are adopting DDD. Things like event storming an event modeling, which we’ve touched on in this course, are starting to become mainstream parts of DDD for many organizations. ‑Yes, and the industry’s use of some patterns have shifted too. There’s a lot of pushback against the repository pattern these days. I think, in part, because it became very popular, but was often used without the context of DDD or other complementary patterns like the specification, and these can really help it shine. Our first course didn’t really talk much about specification as a core DDD pattern, but it’s something I use on most of my projects now. ‑From a technology perspective, our previous course was built for .NET developers, and at the same time, that meant .NET 4. The original veterinary application used ASP .NET, MVC, and Web API, and an early version of SignalR. And for data access, we used Entity Framework 6. ‑Since then, .NET Core, which is now .NET 5, has shipped and become the new standard for .NET developers, and the latest versions of EF Core have added a number of features that we’re leveraging to help improve the design of our model like owned objects and filtered includes. We also shifted our use of domain events from being prepersistence to postpersistence. There are valid use cases for both kinds of domain events, but the latter is safer for any events that communicate outside of the domain, so we’re defaulting to that this time around. ‑Right, especially since one of our key demos involve sending emails to the client. The original sample also used SQL Server for its message broker, which we chose because we didn’t want to force our students to have to install a custom tool. But Docker is another technology that wasn’t mainstream in 2014, but it is today, and it makes it a breeze to use custom bits of infrastructure. In this update to the course, we’re definitely leveraging Docker to provide RabbitMQ messaging with 0 install, as well as to capture emails during development using Papercut in another Docker container. ‑Yeah, Docker should really make it trivial for students to run the application locally, even though it has a bunch of moving parts. If you don’t have Docker, you can still run it in your IDE or from the command line, but with Docker, it’s just a lot simpler to get going. ‑And along with Docker and containers, microservices have become a huge buzzword in the industry. Of course, Docker makes it much easier to deploy microservices, and DDD principles really shine when designing them. So all of these things, I think, are really complimentary. ‑Definitely, although I do think some companies are too quick to jump to microservices without fully understanding their domain and where to separate out different contexts. And on the topic of separation, our previous sample put everything in one giant solution, too, mostly to make it easier to find things. ‑This time, we went with something that should resemble a real‑world application even more with separate solutions for each bounded context. We even published the shared kernel as a NuGet package, in our case, hosted on nuget.org, although typically, your organization would probably have a private NuGet feed. ‑If you’re still working with .NET Framework apps and you haven’t watched the previous course, we encourage you to give it a look. Its samples are geared more toward that framework, and you should find a link to it on Julie or my author page here, on Pluralsight, or at this bit.ly link here. ‑And don’t feel bad if it feels like there’s still a lot you have to learn about DDD. It’s a big topic. And as we’ve just shared, Steve and I are constantly learning new ways to apply it, too. Be sure to check out other DDD courses here, on Pluralsight, and if you need direct help for you or your team, you can reach out to Steve or me, directly.\nReview and Resources If you remember nothing else from this particular module, the one thing to keep in mind is how simple it was for us to add in what was potentially a really complicated feature. Because of our DDD implementation and some of the infrastructure we had already built, it wasn’t really very challenging to plug these new puzzle pieces into the application. ‑Right, we introduced a couple of new concepts. We talked about message queues, and those fit really nicely into our existing architecture because we were already using events to correspond to interesting things happening within our application. ‑And the message queue allowed us to stick a message in an external place by one application, and another application can come along and retrieve that message. So the message queue allows our applications to communicate with each other, but they can do it in a disconnected way. ‑And then we mentioned, but we didn’t show, this concept of a service bus, often called an enterprise service bus, which you may want to introduce if you start having more than just a couple applications needing to talk to one another. ‑At the risk of being redundant, let’s just pay homage one more time to how the decisions we made earlier on, when implementing the vet clinic solution, allowed us to add in a potentially complicated new feature, email notifications and responses into the application. ‑While we had used mediator to transfer domain events within the FrontDesk application, this time we took advantage of message queues to help us move events back and forth between applications. ‑Using RabbitMQ’s API, we created three different queues that were specific to the cross‑application communications we needed. For example, a queue that the vet clinic public app could publish messages into for the FrontDesk application to retrieve so it could update the UI. ‑It’s also important to note that we leveraged existing tools like RabbitMQ and Papercut to perform certain tasks. In DDD, we would refer to these as generic domains. You’ve got to look under the covers to see how the code was making all the communication between the apps and the message keys possible, but without our domain model having to know about any of the details. ‑And then we shared some additional knowledge as we wrapped up the course. We talked about modeling practices like event storming and tools like MURAL. We talked about all of the new ideas that have evolved since we first published this course in 2014 and how they impacted this new version of the course and the sample application. ‑And we ended with some more wisdom from Eric Evans, to whom we are eternally grateful not only for bringing DDD to the software community, but also for spending time with us when we created the original course so that we could share his perspective and insights with you. ‑Like the end of a fireworks display when they shoot up many, many fireworks at once, we’re sharing here a lot of resources and links because of the great many topics we brought into this last module. There are two pages of links here to articles and videos and other Pluralsight courses, so you might want to pause the video to be sure that you see them all. ‑So, from me, Steve Smith, ‑and from me, Julie Lerman, thanks so much for taking this journey with us through Domain‑Driven Design Fundamentals.Course Overview Welcome to Pluralsight. My name is Julie Lerman, and this is Steve Smith. Together, we’d like to welcome you to our course, Domain‑Driven Design Fundamentals. Steve is a trainer and architect with NimblePros and spends a lot of time helping teams write better code, faster. And Julie is well known in the DDD community for helping reluctant teams embrace domain‑driven design. In this course, we give you a strong foundation for learning how to build applications and microservices using domain‑driven design. DDD has proven to be a very effective approach for managing complex requirements. The original version of this course has helped many thousands of learners leverage domain‑driven design, and they have shared amazing feedback. Now, we’ve updated the course and its sample application to reflect ideas and tools that have emerged since that first version. Some of the major topics that we’ll cover include what are the essential ideas of domain‑driven design? What are the main patterns used in domain models? We’ll also talk about how to break up concepts into smaller parts and how these smaller aggregates and contexts communicate with one another. By the end of this course, you’ll know how to break down customer requirements into a maintainable domain model and structure a solution using domain‑driven design. Before beginning the course, you should at least be familiar with software development, ideally using C#. From here, you should feel comfortable diving into DDD and design patterns with courses on the DDD learning path and the design patterns learning path. We hope you’ll join us on this journey to learn domain‑driven design with the Domain‑Driven Design Fundamentals course, at Pluralsight.\nIntroducing Domain-Driven Design Introduction and Overview Hi, this is Steve Smith ‑and this is Julie Lerman. Welcome to our course, Domain‑Driven Design Fundamentals. ‑We’re looking forward to sharing our experience with DDD and how it’s helped us and our clients. You’re welcome to reach out to us online. ‑You can find me online at thedatafarm.com or on Twitter @julielerman. ‑And I’m online at ardalis.com or on Twitter as @ardalis. ‑Eric Evans coined the term Domain‑Driven Design in his groundbreaking book with the same title published in 2004. Since then, other titles have followed, including great books expanding on the subject by Jimmy Nilsson and Vaughn Vernon and so many who are now also great experts at DDD. And there are also now a number of fantastic DDD conferences and even a well‑established virtual meetup. ‑There’s definitely continued and renewed interest in Domain‑Driven Design as both the demand for and complexity of software continues to grow. Domain‑Driven Design is commonly referred to as DDD and even has its own Twitter hashtag, dddesign. Although DDD has been around for so long, it continues to be a great approach to building software that we both enjoy employing and sharing with others. And as more minds have gotten involved in DDD, it continues to evolve.\nWhat to Expect from This Course and This Module Domain‑Driven Design is a huge topic. Our focus will be on the developer perspective and the technical and coding aspects of DDD more so than architectural concerns. We’ll start by talking about why we think you should even be watching this course. Next, we’ll jump right into an existing solution so you can get a concept of what the code and the architecture of an application written using DDD practices looks like. Then we’ll start digging into the big DDD concepts like modeling problems of the domain, what the various technical components of DDD are, and how you can use DDD to manage complex projects. Throughout the course, we’ll use the existing solution so you can see how some of this process works. ‑With this in hand, we’ll walk through extending the sample based on a new request from the client. Since this is a fundamentals course, we certainly don’t expect to turn you into an expert by the end of it; however, you should be well on your way to understanding the value behind Domain‑Driven Design and how some of the practices can be employed to improve your success with complex software projects. Right now, if you’re new to DDD, you don’t even know what you don’t know yet. However, once you’re done with this course, you’ll know more about DDD, but of course, you’ll also realize how much more there is to learn. That’s one of the great things about our industry. The more you know, the more you realize how much more there is you don’t know. ‑In this module, we’ll focus on the value of Domain‑Driven Design. You’ll learn what the term represents and what problems DDD can help you with in your software building process. ‑Not only will we share the benefits of DDD, but we will be sure to highlight some of the potential drawbacks. Finally, you’ll get a look at a small application that we’ll be using throughout the course as you learn DDD.\nUnderstanding the Value of Domain-Driven Design Domain‑Driven Design focuses on the problems of the business domain that you’re attempting to solve. Its a critical shift from decades of focusing on how to store your data and then letting that drive how the software is designed. But that workflow added a lot of unnecessary complexity to the task of building software. So why should you watch this course? Why should you care about learning Domain‑Driven Design. Steve and I have both been designing and developing software for a very long time. Without giving away our ages, we’ve got over 40 years of experience between the two of us, and we’ve both been very inspired by Domain‑Driven Design. In many ways, it aligns very naturally with ideas that we’ve each come to from our own experience. It also takes these ideas and lays them out in a way that’s not only illuminating, but it’s repeatable. When Eric Evans wrote his book, his goal was to understand what was behind the successes he had achieved with large‑scale, complex software projects and what were the patterns. That’s what he laid out in the book. ‑This is why we care about DDD, and we hope that you can gain from our experience, which is why we put together this course. DDD provides principles and patterns to help us tackle difficult software problems and even business problems. These are patterns that are being used successfully to solve very complex problems. The more we’ve learned about DDD, the more we found these ideas aligned with the approaches we’ve learned from our many combined years of experience. DDD provides us with a clean representation of the problem in code that we can readily understand and verify through tests. We developers live to code. When starting on a new project, we’re eager to jump in and start coding so that we can build some software. But you can’t build software unless you truly understand the client’s needs. DDD places as much emphasis on not only comprehending what your client wants, but working with them as full partners through a project. The ultimate goal isn’t to write code, not even to build software, but to solve problems. ‑You need to realize that nobody really wants your program. They want what it can give them. There’s a famous saying in sales. Buy a quarter‑inch drill, they want to buy quarter‑inch holes. Your client’s not interested in building software, but in being successful at their mission. Software provides a more efficient means to this end.\nGaining a High-Level Understanding of DDD Domain‑driven design is for solving complex problems. Evans put a lot of thought into the subtitle of his DDD book and came up with Tackling Complexity in the Heart of Software. But DDD itself is a complex topic. To start with, we think it’s helpful to look at it from a very high level. We call it the 10,000 foot view here in the US, but that’s probably 3,048 meters to the rest of you. ‑One of the critical pieces of DDD is to encourage better interaction with domain experts. These are the people who live and breed the business or process or whatever you are targeting with the software you’re planning to write. You may be thinking, but we already talked to them. Perhaps, but probably you’re using your terms, not theirs, and maybe talking in the language of tables in a database rather than domain concepts. Or you may presume that after some standard requirements gathering, you can infer enough about the problem at hand to design the solution on your own. After our own history in the business of developing software, we know that that rarely ends well. DDD guides us to engage with the domain experts at much greater length and through much more of the process than many software teams are used to doing. ‑When talking with Eric Evans about this, he told us that you really need to cultivate your ability to communicate with business people in order to free up their creative modeling. Another core theme in DDD is to focus on a single subdomain at a time. Say you’re asked to build software for a spaceship manufacturer. They describe their business tasks such as purchasing materials, engineering, managing employees, advertising their spaceships and share with you their dreams about mass producing spaceships when the market’s ready. Each one of these tasks are in themselves a complex subdomain filled with their own specific tasks, terminology, and challenges, and those subdomains may have only minimal interaction between them. Many applications just try to do too many things at once, then adding additional behavior gets more and more difficult and expensive. With DDD, you’ll divide and conquer. By separating the problem into separate subdomains, each problem can be tackled independently, making the problem much easier to solve. This lets us focus on the problem of employee management separately from the problem of sourcing materials for producing the spaceships. The term modeling is important in DDD and refers to how you decipher and design each subdomain. You’ll learn much more about this as you progress through the course. ‑The final theme in our high‑level perspective of DDD is writing the code to implement each subdomain. The principle of separation of concerns not only plays a critical role in identifying the subdomains, but within each subdomain, we use it as well. Many applications spread the domain logic between the persistence layer and the user interface, making it much more difficult to test and to keep all of the business logic consistent. DDD applies separation of concerns to help steer you clear of this problem by focusing on the domain and not on details like how to persist data into a database or how to connect to a service in the cloud. Those become implementation details that you can worry about separately. While implementing these subdomains, the focus is on the subdomain, the problems of the subdomain you are trying to solve with your software. You don’t get bogged down worrying about infrastructure concerns.\nExploring the Benefits and Potential Drawbacks of DDD Domain‑Driven Design is a big commitment. While Steve and I have both chosen to leverage pieces of DDD as we learn more about the wider scope, one thing we’re both confident about is that it’s providing a lot of benefits to our work. Because DDD guides us to focus on small, individual, nearly autonomous pieces of our domain, our process and the resulting software is more flexible. We can easily move or modify the small parts with little or no side effects. It even lets us be more flexible with our project resources as we’re building the software. ‑The resulting software also tends to be more closely mapped to the customer’s understanding of the problem. DDD gives you a clear and manageable path through a very complex problem. When you look at the code, you can see that it’s generally well organized and easily tested, and the business logic all lives in one place. Even if you don’t use full DDD for a project, there are many patterns and practices that you can use by themselves to benefit your application. So keep watching, even if you don’t think you’ll need all of it. ‑We often describe DDD as a way to take big, messy problems and transform them into small, contained, solvable problems. But DDD is not a path for every project. It’s real benefit is for complex domains. Even Eric Evans explicitly states that DDD isn’t suitable for problems when there’s substantial technical complexity, but little business domain complexity. Using DDD is most beneficial when the complexity of the domain makes it challenging for the domain experts to communicate their needs to the software developers. By investing your time and effort into modeling the domain and coming up with a set of terminology that’s understood for each subdomain, the process of understanding and solving the problem becomes much simpler and smoother. ‑But all this comes at a cost. You’ll spend a lot of time talking about the domain and the problems that need to be solved, and you’ll spend plenty of time sorting out what is truly domain logic and what is just infrastructure. The easy example there is data persistence, or for the sake of our spaceship manufacturer, maybe it’s how to communicate with an external service that helps to verify that potential buyers are properly vetted for space travel. ‑You’ll have a big learning curve as you learn new principles, patterns, and processes. There’s no question about that. DDD is a big topic and gaining expertise from end to end is a big commitment. This course doesn’t aim to make you an end‑to‑end expert in DDD, but to give you a big step forward that will allow you to not only comprehend the concepts, but you’ll gain a lot of new tools that you can use right away, whether or not you choose to dig further. And it’s worth restating that DDD is not always the correct path for your applications. And it’s helpful to keep in mind some of the scenarios where DDD is just going to be overkill. For example, if you have an application or a subdomain that’s just a data‑driven app and doesn’t need much more than a lot of CRUD logic, there’s really no need to use DDD. It would be a waste of time and effort. ‑And be clear about the difference between complexity in your business domain and technical complexity. DDD is designed to help with complex domains. If your domain is simple, even if you have a lot of technical challenges to overcome, DDD still may not be the right path. For example, if you are writing a tic‑tac‑toe game for a touch screen with a new complex API, the complexity lies in the touch interactions of the two players on the screen. The domain itself is well known and just comes down to Xs and Os. Getting others to follow the DDD approach can also be a drawback. There may be some politics involved in this decision. It really depends on your team and your organization. We hope that another takeaway from this course will be to help you understand the concrete benefits of DDD, which you can show to your coworkers to help convince them.\nInspecting a Mind Map of Domain-Driven Design In his DDD book, Evans included a really useful diagram of how many of the concepts and patterns of DDD are interrelated. Let’s take a look at that mind map. ‑Evans refers to this as a navigation map, and it lays out all of the pieces of Domain‑Driven Design and how they relate to one another. We want you to see it so that you have a concept of the big picture, even though in this course we’ll spend most of our time on a subset. We will be defining many of these terms later on in the course, so don’t panic. We’ve mentioned modeling the domain and subdomains a few times. Modeling is an intense examination of the problem space. Key to this is working together with the subject matter experts to identify the core domain and other subdomains that you’ll be tackling. Another important aspect of modeling is identifying what’s called bounded contexts. And within each of these bounded contexts, you focus on modeling a particular subdomain. As a result of modeling a bounded context, you’ll identify entities, value objects, aggregates, domain events, repositories, and more and how they interact with each other. ‑In the image, there’s more than just these subdomains, however. For example, there is a concept of an anti‑corruption layer, which allows subdomains to communicate with one another from behind their boundaries. The model also has notes for each element, such as free teams to go separate ways. This is something that can be accomplished once you’ve identified the boundaries of each subdomain. Or avoid overinvesting in generic subdomains. That could be something like a credit card verification service that you could choose to use rather than building yourself. As you begin focusing on specific subdomains, another very important DDD concept surfaces, driven by the need for clear, concise communication. It’s called the ubiquitous language. A simple definition of a ubiquitous language is to come up with terms that’ll be commonly used when discussing a particular subdomain. And they will most likely be terms that come from the problem space, not the software world, but they have to be agreed upon so that as discussions move forward, there is no confusion or misunderstanding created by the terminology used by various members of the team. ‑We invite you to pause this video to look over this map and read the notes associated with the various elements and contemplate what they might mean. We’ll revisit this throughout the course, and we hope that the map will make more and more sense as you work through the course.\nIntroducing Our Sample Application Now we want to switch over and show you a relatively small DDD‑based solution that we’ll be working on for the rest of the course. This app represents an appointment scheduling system for a veterinary clinic. It’s “small”, but since DDD requires a certain amount of complexity to warrant its use, it’s bigger than most demos you’ll see in other courses or presentations. For this course, we decided that we would use a veterinary clinic management system because it has a decent amount of complexity, and that means that we can apply some of the DDD principles, but it also gives us an excuse to show off pictures of our pets. ‑And our friends pets too. We’ve got a whole bunch of pet pictures from other Pluralsight authors in here, and they’re all so cute. ‑We’ve got Ben Franklin here from Michael Jenkins. We’ve got Patrick Neborg’s dog here, Sugar. Aren’t these guys cute? And, of course, Julie’s got Sampson. ‑Oh, my handsome boy. ‑And I’ve got Darwin, the silly poodle. He was just a puppy when we recorded the first version of this course, and he’s got a new friend, Rosie. Rosie is just a puppy. I guess every time I get a puppy we have to update this course. ‑So the idea behind this application is that if you’re working at the front desk of a vet clinic and someone walks in, maybe they want to schedule an appointment, or the phone rings with someone who wants to schedule an appointment for their pet, the first thing you’re going to do is look that client up, the person, in the system. ‑So the user starts by looking up the client, and from there, they can choose which of the clients, animals or patients, they’re going to schedule. So here’s Julie with Sampson. Here’s Kim with Roxy. Next, the user is just going to click on an open slot in the schedule, which opens up the create appointment window. ‑Oh, Roxy, you’re such a cutie. We can set up Roxy for a wellness exam with Dr. Smith. ‑Now notice before we save this appointment, it isn’t yet confirmed. We’ll get to that in a minute. So we save, and the appointment shows up. Now the complexity in this system comes into play when we have to do some checks for certain things. We want to make sure, for instance, that Roxy isn’t already scheduled in one of the other rooms at this exact time. We also want to send an email notification to Kim to let her know that Roxy has this appointment scheduled. We’ll add a link in the email the client can click to confirm. And in a real system, perhaps it would add it to their calendar of choice. The idea is to cut down on no‑show appointments for the clinic. ‑Of course, there are other features of this application. We’re focused on the schedule right now, but we do need to be able to manage client data and manage their pet data, the clinic’s patients, and things like that. Admins need to be able to manage doctors and rooms and appointment type since these all might change over time or from one clinic to another that uses the same software. But those are mostly CRUD tasks, which means we’re just talking about adding and removing records and maybe making some edits without a whole lot of complexity. We’ll talk about those tasks in a different compartment of the application than the schedule, which, of course, has a lot more complexity.\nExploring the Sample App’s High-level Structure So why don’t we take a look at the structure of our app? This is a distributed application built with ASP.NET Core on .NET 5. It’s running Blazor WebAssembly in the front end, which is talking to APIs running on ASP.NET Core. There are three different web apps that the system uses. Two are used internally by client staff, and then there’s the public‑facing website for the clinic, which is needed for the confirmation links that users will click. The two clinic apps, Front Desk and Clinic Management, each have their own database, and all three apps communicate with one another using messages transported by RabbitMQ. Like I said, it’s maybe a little more complicated than most demos. We want the sample app to be something you spend some time with and extend as part of your experience with this course, so please be sure to check it out and run it locally. It should just work if you have Docker installed. ‑Now let’s take a quick look at how the code is organized. The full solution is hosted on Steve’s GitHub account. Here’s the URL, but we’ll definitely also have that URL in the resources slides at the end of this module. PLURALSIGHT DDD FUNDAMENTALS is the name of the root of our GitHub repository. In here, you can see the three web apps, ClinicManagement, FrontDesk, and the public‑facing website, VetClinicPublic. ‑There’s also a folder for SharedKernel, which we’ll talk about a little bit later. The first app we’re going to focus on though is the FrontDesk app. ‑Our main focus for this course is going to be the front desk application and its scheduling functionality. Looking at the solution, you can see it’s broken up into seven projects, which seems like a lot, but three of them are just there to support Blazor The server‑side code, where our domain model resides, is just three projects. ‑The most important project is FrontDesk.Core. That’s where the domain model is defined. All of the app’s infrastructure needs, like how it talks to its database or RabbitMQ, are kept in the FrontDesk.Infrastructure project. In the front end, in this case, ASP.NET Core and its API endpoints, is in the FrontDesk.Api project. This is the front end from the server’s perspective. The system is using a clean architecture design which you may also hear referred to as onion architecture or ports and adapters. I cover this in my N‑Tier Applications in C# course, and I have a popular GitHub solution template you can use to set up a new project using this approach. ‑With clean architecture, the project dependencies all point towards the domain model in the core project, so both the API and infrastructure projects have a dependency on Core. Core should never depend on infrastructure concerns, but it can leverage NuGet packages that don’t couple it to infrastructure concerns. ‑In this case, it’s using a couple of utility packages, as well as the SharedKernel package that’s shared by other apps. We’ll talk more about SharedKernel later. The ClinicManagement app uses the same kind of structure and also has a Blazor front end because why not? It’s pretty much just CRUD, so we don’t focus too much on its domain model, but it is a distinct app with its own database, and we do need to build into our design a way to propagate changes from it to the FrontDesk app. ‑Finally, there’s the public web app. It’s just one project, and it’s pretty simple. This is responsible for sending emails, which this demonstration fakes using a tool called PaperCut, and it hosts the link that clients click to confirm appointments. The public web app also needs to communicate with the front desk, but it doesn’t have a database of its own, nor does it access any of the other app’s databases. ‑That’s it in a nutshell. We’ll demonstrate the confirmation emails and more complex use cases later in the course. But for now, that should give you an idea of how the ideas we’re sharing are put into practice.\nReview and Resources So, as we’ve talked about, creating applications is not about writing code, even though often that’s a really, really fun part for us developers, but it’s about solving problems. And the more complex the problems are, the more difficult the whole project becomes. So Domain‑Driven Design gives us some great patterns and practices for attacking these more complex problems, and they get us to really focus on interacting with the domain experts, breaking apart our domain, and working on things in smaller units and in a very organized fashion. And in the end, it gives us a much more efficient and effective path to success in creating our solutions. ‑Yeah, we talked about some of the benefits that Domain‑Driven Design provides, as well as some of the drawbacks. Specifically, your team just needs to know Domain‑Driven Design, and your domain experts need to be available to work with you on these systems. Domain‑Driven Design is a big topic. We looked at some of the different concepts that are involved in DDD, and we’re going to look at a lot more of them in depth through this course. But remember that this is just an introduction to Domain‑Driven Design, so some of these aspects that are a little more advanced, we’re not going to be able to cover with a great deal of depth. ‑In the next module, we’ll start exploring the process of discovering and modeling domains. Here are some links to resources that we mentioned this module and others that we find relevant. ‑This is Steve Smith ‑and this is Julie Lerman, and thanks for watching Domain‑Driven Design Fundamentals.\nModeling Problems in Software Introduction and Overview Hi. This is Steve Smith. ‑And this is Julie Lerman. Welcome back to our Domain‑Driven Design Fundamentals course. This module will focus on modeling problems in software, and you’re welcome to reach out to us online. You can find me online at thedatafarm.com or on Twitter @julielerman. ‑And I’m at ardalis.dot com or on Twitter as @ardalis. In this module, we’re going to take a look at how we decompose the model for the veterinary office domain. We’ll talk about the importance of domain experts in DDD. ‑We’ll drive this point home with a play in which we’ll consider a few different scenarios for how the project might have gone, which should provide you with examples of ways to involve the domain expert in the design of the system. ‑Next, we’ll talk about the domain model and some of the elements that typically are found in this part of the application. It’s important to separate the core domain model from related subdomains, and we’ll talk about how bounded contexts can help us accomplish this separation. ‑And then we’ll wrap things up by talking about ubiquitous language and how this seemingly small thing with a big name can have a large impact on your model, your design, and, of course, your application. So let’s get started.\nIntroducing Our Domain Steve and I both have a love for animals. In fact, Steve’s wife, Michelle, is a veterinarian. In thinking about a sample application we could use for this course, we wanted to use something complex enough to justify the use of DDD. The veterinary clinic management domain made a lot of sense, allowing us to leverage our own experience as pet owners, as well as having a domain expert available in the form of Michelle, or Dr. Smith as we’ll be referring to her in the course. ‑There are many different pieces involved in managing a typical veterinary clinic. The staff needs to be able to schedule appointments. They likely need to schedule their own working shifts as well. They need to be able to invoice for their services and collect payments and, in many cases, send out bills. They’ll also need to be able to store and retrieve medical records, as well as work with external labs and specialty clinics. Most veterinary practices also have products for sale and may need to track inventory, as well as sales. And there are often follow‑ups and reminders that may need to be sent by mail, phone, or perhaps email. There is certainly sufficient complexity in this domain to merit the use of domain‑driven design.\nPlanning Ahead to Learn About the Domain Of course, it’s a good idea to speak with a domain expert about the systems requirements before diving in and beginning to code a solution. Whether you’re tasked with building a full system or just adding a new feature, an overall understanding of the client’s business is a critical start. Of course, it’s just the beginning. It’s also important that you have a continuous conversation with the domain expert throughout the development of the system. The simple system we showed in the last module needs some updates. So we’re going to share some conversations we had with the domain expert to help validate our initial assumptions. ‑An important part of this conversation is going to be identifying the things that aren’t included in the scope of the project or feature. To that end, we’ll try to identify subdomains within the overall problem domain and then determine whether or not we need to concern ourselves with these subdomains at the moment. If not, we can consciously remove them from the scope with the customer’s approval and avoid confusion and possible missed expectations later. To get started though, we do want to know a little bit about the big picture.\nConversation with a Domain Expert: Exploring the Domain and Its Subdomains As Julie already mentioned, my wife, Michelle, is a veterinarian. In addition, she has a deep understanding of software development processes, having successfully managed software teams at NimblePros and Teller. She has graciously agreed to play the role of domain expert for our course. In real life, she knows quite a bit about software and technology, but for the purposes of this course, she’s playing the more traditional role of a veterinarian with little background in software development. Hi Dr. Smith. Thanks for your time today. Julie and I would like to learn more about what goes on in your veterinary clinic. Can you share some of the big picture processes involved in the day‑to‑day operation of a clinic? ‑So the biggest thing is probably scheduling patients and keeping track of them once they arrive. Clients will usually call ahead unless it’s an emergency, and then we need to get them entered into our system. Of course, surgical procedures need to be scheduled in advance. And when they’re here, we need to record information about the patient, our observations, notes, and diagnoses. ‑Wow, that’s quite a list. Probably not what you were dreaming about when you started vet school. So many of these are all secondary to the core reason for being a vet, keeping pets healthy. And, I think it sets you apart from other businesses that have to manage clients and schedule appointments. But, you can’t run a business without it. Is that all? ‑So when the appointment is over, they also have to pay. So most of the time that’s done immediately, but we do have some billing that’s done after the fact, and when they’re checking out, they may need to buy some things for their pets, toys or prescriptions, or maybe some prescription food as well, and we need to track all of that as well. For some of the lab work, we need to send that out and get the results back, and some prescriptions go out to outside pharmacies as well. So we need to manage all of those through the system. ‑Okay, so payments, billing, point of sale, labs, prescriptions, anything else? ‑I think that’s about it. Oh, we also use the system to note which staff members are working when, and right now our website isn’t integrated into the system at all, but we were thinking it would be great if clients could view information about their pets, maybe schedule appointments, look up prescriptions, and we can make updates to the site without having to go through our computer contractor. ‑Okay, great. So, we’ll add staff scheduling and content management to the list. I don’t want to assume you know what a content management system is. We also call it a CMS, you might have heard of that. It’s a type of software system that lets the owner, that’s you, be in charge of the information that’s displayed. A blog is a really good example of a CMS that can be managed by its owner. ‑I have a blog, so I understand exactly what you mean. Something like that would be really great for us to have so we can make updates right in‑house. But it’s kind of like a blog, especially something that’s more professional than my personal blog. ‑Cool. So I think that’s probably enough of a big picture view for us to consider at the moment. Now let’s try and think about which of these are connected to the others so we can determine which ones we need to worry about for our application’s needs. ‑We started with this fairly complicated view of the overall problem domain, but now we’ve segregated these into different areas and we know which ones we need to focus on right now and which ones we can treat as external collaborators. ‑Determining where we can safely draw the line between what problem our immediate application needs to solve and what is outside of its area is certainly helpful. It’s also important that this be well understood and communicated among everyone involved in the project.\nConversation with a Domain Expert: Exploring the Scheduling Subdomain Now that we have a better understanding of the domain and the other subdomains around the scheduling system, it’s time to focus more on understanding the scheduling subdomain. We had another meeting with Dr. Smith, and you can listen in. ‑Hi guys, welcome back to the clinic. How are things going with the computer system? ‑We’re making good progress, and now we’re ready to look at another more complex feature. ‑We know there’s a lot that goes on here, but today we want to focus on appointment scheduling because we realize we’re still a little confused about it. ‑Since we’ve both owned pets for a long time, we figure we probably have a rough idea of what’s needed, but it’ll be good to talk through it with you. Do your patients usually schedule their appointments over the phone? ‑Okay, so yeah our patients aren’t usually involved in the scheduling. Usually, it’s the clients that call in for appointments for their pets. And yeah, usually it’s on the phone or in person when they’re checking out after an office visit. Julie and I talked about that earlier. ‑Yeah, so Steve, the patients are the animals, and the clients are the people or the pet owners. ‑Right, right, of course, that’ll be important to get right. ‑Remember, we talked about that. So the client needs to make an appointment for their pet. They’ll talk to a staff member who will schedule the appointment. What kind of information do they need in order to do that? ‑So that really depends on the type of appointment. It could be an office visit, or it could be a surgery. Why don’t we talk about the office visits first. If it’s just for a wellness exam, that’s pretty standard. They just need to choose an available time slot with one of the doctors. Some of the visits can be scheduled with just a technician though, so if they need just their toenails trimmed, for example. ‑Or painted, like Samson. He gets his toenails painted. ‑Does he really? ‑No, I’m joking. I just want to, pink. ‑I’m sure he’d love that. Okay, so office visits might be an exam requiring the doctor or another kind of appointment that only requires a technician. ‑Right. We also have to worry about our rooms too. We only have five exam rooms available, and we try not to overbook. We don’t like for our clients to have to wait too long in the reception area, especially if we have a lot of cats and big dogs out there at the same time. It makes them all really nervous. ‑What about other staff? ‑So our technicians will float between the exam rooms and other areas of the clinic as needed, except, of course, for those scheduled technician visits. We do have a schedule for the staff, but it’s separate from how we schedule our appointments. ‑Okay, so what about the surgeries? ‑Well, if it’s a surgery, those are only scheduled on certain days, and they require that the operating room be available, as well as some recovery space in the kennel area. It also depends on what kind of surgery or procedure we’re going to be doing. Something simple like a dental cleaning takes less time and fewer people than a caesarean section for a bulldog. ‑Okay, so an appointment is either an office visit or a surgery. Office visits happen in the exam room; surgeries require the operating room and recovery space. Is that right? ‑Right. And depending on the reason for the visit or the surgery, different staff might need to be involved. ‑So we’ll probably want to have separate classes for appointments and surgeries. ‑Classes? No, we refer our clients to obedience and puppy preschool classes at other facilities. We don’t actually schedule any of those in the clinic themselves. ‑I’m sorry. That’s a software term. In software, we have different classifications of concepts in the program, which are called classes. I’m just getting ahead of myself here. Sorry. ‑Don’t worry. We’re not going to make you learn our software terms. Steve and I will try to have a little bit more self control with that. We do want to make sure we’re all speaking the same language when it comes to concepts in the application though. ‑Okay, so I have another quick question. Do we have to worry about multiple staff members scheduling appointments at the same time? ‑No, there should only ever be one person doing the scheduling at a time, although I could see if we grew in the future that could change. But I don’t think that’ll happen in the next couple of years. Okay, then we don’t have to worry about the rare occurrence of two people creating a conflict if they’re trying to schedule an appointment for different patients in the same room or with the same doctor. That’ll keep things a lot simpler. And we need to know before an appointment if certain resources are available, like rooms and doctors. And then if they are and we want to schedule the appointment, then we need to be able to book the doctor, the room, and any other resources. Hey, is it okay if we refer to doctors as resources? ‑Sure, that makes sense. You know, I think it makes sense to use the term resources to refer to the doctors, the rooms, and the technicians since those are all things that can affect whether or not an appointment can be scheduled. But remember, sometimes it’ll be just a vet tech in a room, and other times it might be the doctor in the room, but sometimes you might need the doctor, the technician, and a room. ‑Wow, this is a lot more complicated than we’d realized, but it’s interesting. This is going to be cool to model in the application.\nReviewing Key Takeaways from Meeting with Domain Expert(s) Some of the things we learned in that initial high‑level discussion with the domain expert included the fact that patients and clients are not the same thing to a veterinarian. ‑Yeah, that’s pretty obvious in hindsight. But in most other medical professions, it is the patients who make appointments and pay the bills. It’s good we were able to get on the same page with the customer on that early on in the process. ‑I think it helped Dr. Smith put some of the processes she uses into explicit terms that we could program against also. A lot of times just describing the process to someone who is unfamiliar with it can really help improve the understanding of it. It’s like that idea that when you have to teach something to someone else, it makes you learn it a lot better. Listen to what Dr. Smith had to say at the end of our conversation about this. ‑Yeah, I never really thought about the details of how we do some of these things since it’s just something we do, and we don’t really think about it. Being more explicit about what the rules are that determine how we do are scheduling could help us avoid some of the occasional scheduling problems we’ve had. This is going to be great. ‑We also need to remember not to use too much programmer jargon, especially when there are programming terms that might have a different meaning in the customer’s domain. ‑I agree. It’s a little early for us to be worrying about how things might end up looking in the code anyway. At this stage, the main focus is on understanding the domain. We’ll get to building the software soon enough. But first, we want to make sure we know what problem it’s going to be solving. One of the most important things we can do as we explore the problem with the domain expert is to try and make their implicit knowledge about the process they use now explicit. Once we’re able to capture the process and its rules and exceptions with some detail, we can start to work on modeling a solution using this information. Building software is hard. One of my favorite sayings is as software developers, we fail in two ways. We build the thing wrong, or we build the wrong thing. By making sure we understand what the customer needs and, of course, working closely with the customer throughout the development process, we can dramatically reduce the likelihood of the second kind of failure, which is much harder to fix typically. ‑Hey, Steve. I like the way you quote yourself here, but it really is a great quote.\nTaking a First Pass at Modeling our Subdomain After talking to Dr. Smith about how appointments work, we’ve identified a few high‑level elements of our model. The central concept in this application seems to be the appointment itself. Typically, an appointment is scheduled by a client for a patient. Booking an appointment often requires an exam room and a doctor, but may involve other resources. Appointments might be for office visits or vaccinations, or they might be surgeries, which are a separate kind of thing entirely with their own rules which involved different kinds of procedures. Surgeries require different resources too, like operating rooms and recovery rooms. ‑That’s a pretty good high‑level view of the model we have so far for the appointment management part of our application. I think it’s worth noting that some of the concerns of this application are going to also play a part in other subdomains. For instance, I’m pretty sure we’re also going to be working with clients and patients in a lot of the different parts of this application. ‑Yeah, I think it’s time we introduce the idea of bounded contexts.\nUsing Bounded Contexts to Untangle Concepts that Appear to Be Shared As you develop your model, remember to identify its bounded context. That is, where is this model valid? If you don’t put boundaries around your model, eventually, pieces of it will be used where they don’t fit. Concepts that make sense in one part of the application may not make sense in another, even if they have the same name and sometimes even if they literally refer to the same thing. ‑For example, as we built out the appointment scheduling portion of this system, we needed to know some very basic information about clients. But in the context of appointment scheduling, these are very simple concepts with little behavior beyond their names. However, in the billing context, we’ll want to include contact and payment information for clients, but that’s information we don’t care about back in the appointment scheduling context. If we try to reuse the same exact client model in multiple places, it’s likely to cause inconsistent behavior in our system. ‑That’s right. For instance, we might decide to include some form of validation on clients to ensure we have enough information to bill them. If we’re not careful, that validation might inadvertently prevent us from being able to use clients to schedule appointments, which certainly isn’t the desired behavior. Maybe the billing system requires that clients have a valid credit card in order to save changes for them, but it wouldn’t make sense for a lack of a credit card to prevent us from saving an appointment for a client in the appointment scheduling system. In this example, we have two contexts, but the boundaries between them are blurred and overlapping. Eric Evans notes that models are only valid within specific contexts. Therefore, it’s best to explicitly define the context within which a model applies. We should be able to avoid compromising the model within this context, keeping it strictly consistent within these bounds and avoiding distractions or confusion from outside issues. ‑Once we explicitly define our bounded contexts, we can easily see whether or not we have elements of our model that are trying to span multiple contexts. In this example, we’d want to keep a simple view of a client in the appointment scheduling up and a richer version of the client with contact and billing information in the billing context. We would define these two views of a client in two separate classes, and they will most likely live in separate applications. In fact, Evans recommends that bounded contexts maintain their separation by giving each context its own team, codebase, and database schema. ‑While this is ideal, in many real‑world apps, we need to work on systems where this level of separation is not present, usually due to resource constraints or for political reasons within the organization. Remember though, if you have multiple contexts, you’ll want to keep them bounded. And one way to maintain this separation is to keep their data, code, and team members distinct from one another, although in real world, I’ve never seen something with that level of separation. ‑Yeah, but I think even if it’s not possible to literally do that with your company and your team, just having that concept in mind really helps in your brain have that idea of separation. ‑I agree. I know that just thinking about the fact that these things ought to be separated and trying to figure out a way to do it means that even if you can’t get to the ultimate level where everything is is completely separate, you can still introduce separations through things like namespaces, separate folders, separate projects, anything you can do to make it clear that these are different contexts that shouldn’t be sharing too much information. ‑You know, I think that’s also really important point about this course in general and DDD in general. For me, it’s really hard to think of all of these things we’re learning as hard and fast rules, like you have to do it this way or you’re not doing it right. I like to see all of this as really good guidance. So, you know, it helps me keep my eye on the prize, and when there’s places where I can’t truly achieve exactly what DDD kind of directs me to do, you know, I’m using my own experience, my own intelligence to make decisions about how to do things, and I’m letting DDD guide me in a lot of scenarios. ‑Sure. And some of these ideals, I think of like 100% test coverage. It’s almost impossible in most real‑world applications to achieve 100% test coverage. But just because that ideal is not something you can ever achieve doesn’t mean that you shouldn’t strive for more test coverage. ‑Yeah, yeah, totally, totally agree with that.\nConversation with Eric Evans on Subdomains and Bounded Contexts When learning about DDD, most of us have a hard time understanding how subdomains and bounded contexts are different. We asked Eric Evans about this and got some great insight. He explained that a subdomain is a view on the problem space, how you’ve chosen to break down the business or domain activity, whereas a bounded context represents the solution space, how the software and the development of that software has been organized. Quite often, these will match up perfectly, but not always. ‑Eric helped us understand this further with the example of a room that you want to cover with carpeting. The room is the problem space, so it’s like a subdomain. You could install a wall‑to‑wall carpet that matches the shape of the room perfectly. This would be like when the subdomain and the bounded context encompass the same thing. But other times you might just use some area rugs to cover the floor, and the area rugs solve the problem. They cover the part of the floor where you walk, and you don’t have to worry about cold feet in the winter. And that’s a scenario where the area rugs are like bounded contexts that don’t match the subdomain, but they solve the problem even though they’re not an exact match to the shape of the room.\nIntroducing Context Maps If your organization has multiple bounded contexts, and ideally these are separated, there can be confusion when the different teams are talking to one another. Again, DDD focuses at least as much on effective communication as it does on anything specifically related to the code we produce. Evans recommends using context maps to visualize and demonstrate to all teams where the boundaries between their context lie. ‑Think about a complex topographical map. It will frequently include a legend, like the one shown here, in order to explain what each of the lines and symbols on the map mean. However, this legend is only valid within the context of the map with which it appears. Trying to use this legend on another map would be confusing at best. ‑A good first step for an existing application is to create a map that shows how things are. Remember that the names of your contexts are also important as you’ll refer to them frequently when discussing different parts of the application. It may be that things are not as separate as they should be, and that’s worth noting. If you have separate teams responsible for different contexts that share resources, it’s important that each team understands which aspects of the application they can change on their own and which are shared dependencies they’ll need to coordinate with other teams to avoid breaking things. If we look at these two sets of concepts, we can see some obvious overlap. For one thing, Client appears in both contexts, but we know that for appointment scheduling we really only care about the client’s name, whereas in the billing system they’ll want additional information like address and payment details. However, although the details involved vary, we know that Mr. Jones, the client on the left, is the same actual person as Mr. Jones, the client on the right. However, we also have a concept of notifications on both sides, and in this case, they’re referring to different things. On the left, we’re talking about sending a notification when an appointment is booked as a reminder, and on the right, we’re talking about notifying the client that their payment was received or perhaps that it’s past due. ‑Especially in smaller organizations, it’s common to have one team responsible for several contexts of the same overall application. In such cases, it’s also common for the team to use a single codebase for the bounded context that they’re working with and store it in a single repository, such as GitHub. Usually, there will also be a shared database. As we’ve already noted, this is not ideal since it makes it much more difficult to maintain the boundaries between the separate contexts. ‑Part of creating a context map involves explicitly identifying its boundaries. If we try to draw the boundaries around these two bounded contexts, we can see there are now several resources that belong to each bounded context. This isn’t ideal if the two contexts really are meant to be kept separate. ‑In the ideal case for a large complex system, we would have bounded contexts like these, with their own teams, codebases, and database. For instance, on the left, we have an appointment scheduler application. It’s being worked on by Team Awesome, and they’re storing all of their code in their own repository called vet‑app‑sched. And, of course, this application has its own database. This team is free to change anything they want with their model or any other part of their system without worrying about breaking anything outside the boundaries for the team on the right, which is working on a billing system, and their team has decided to call themselves Team Ultimate, store their code in a repository called vet‑billing, and, of course, using their own database. By having this separation, this can greatly increase team velocity and reduce integration bugs. ‑Of course, you’re probably wondering how the two systems will interoperate. There are a number of patterns that can be applied to enable this kind of integration. We won’t be covering all of them in this course, but one question that frequently comes up is how to share cross‑cutting concerns like blogging and shared abstractions such as people names that are used by multiple bounded contexts. For this scenario, a common approach is to designate these shared concepts or resources as what we call a shared kernel. Team Awesome and Team Ultimate agreed to share the subset of the domain model. Since they’re sharing it, they also agree not to change it without coordinating with the other team first. Frequently, the shared kernel will either be a part of the customer’s core domain, or some set of generic subdomains, or even both, though it could be any part of the model that both teams require. Using a shared kernel is a tradeoff between code reuse and consistency and the overhead involved in integrating changes to the shared kernel across multiple teams and bounded contexts. It works best when the shared model is relatively stable.\nAddressing the Question of Separate Databases per Bounded Context The concept of having separate databases for each bounded context often throws people for a loop. But with the advent of microservices, which also, by definition, each have their own database, teams are beginning to get more accustomed to the idea. Here’s what Eric Evans said to us when we talked with him about the problems created by trying to share a database across teams. “If you’re in a company where you share your database and it gets updated by hundreds of different processes, it’s very hard to create the kind of models that we’re talking about and then write software that does anything interesting with those models.” Given that sharing a database across bounded contexts is really not a great idea, then we have another important question. ‑Another question that comes up often is how to sync data between the individual databases that are tied to each of the bounded contexts. Some different patterns you can use are publisher/subscriber, commonly referred to as pub/sub, and two‑way synchronization. Pub/sub is definitely simpler and preferable when you can manage it. You can use different implementations like message queues, database processes, batch jobs, or synchronous API calls. It’s really up to you how you want to design your synchronization between bounded contexts. The point is just that you don’t get the integration for free from using a shared database.\nSpecifying Bounded Contexts in our Application We talked with Eric again to get his perspective on defining context boundaries. Some of the key points he shared were that first, it’s important to understand that it’s never a simple task whether you’re new to it or not. And he’s seen stumbling blocks of all sorts. The most common is not having a clear enough context boundary, so the effort of applying DDD isn’t clearly separated from other tasks related to building software. ‑He also reminded us that the bounded context is such an essential ingredient that is probably the biggest stumbling block. And it’s not often one that an individual on a project can usually addressed by themselves. It kind of has to be dealt with at the team level or even the organizational level. In our application, we’ve organized the solution to make it clear where the boundaries are between our contexts. The main area that we are currently focused on is the appointment scheduling bounded context. ‑We’ve identified two other bounded contexts that are involved in the overall application or will be eventually. For instance, it’ll be important for users to be able to manage clients and their patients. The staff of the clinic also needs a way to manage their schedules so they know who’s working on different days. We’re referring to these two bounded contexts as client patient management and resource scheduling. ‑We also have a few parts of the application that are common to several bounded contexts. These are cross‑cutting concerns that we have consciously chosen to share. In DDD, we isolate such code into its own package referred to as a shared kernel, and it’s worth noting that a bounded context does not always mean a separate application, even though we’ve identified several different bounded contexts. ‑It’s also a great opportunity to consider packaging logic up into microservices. Do keep in mind, however, that there’s not always a 1:1 alignment between bounded contexts and microservices or applications. Also, let’s not forget that our application will definitely need a front end.\nUnderstanding the Ubiquitous Language of a Bounded Context We’ve mentioned already that an important part of DDD is an emphasis on effective communication among the stakeholders in the project. And remember, if you’re a programmer, count yourself as one of the stakeholders in whatever you’re working on since you certainly have a stake in its success. The language we use to describe the problem and how we choose to model it is key to the shared understanding we want to have with our domain experts in order to be successful. Having a single, shared, ubiquitous language helps avoid unnecessary confusion and translation within the team building the software and is one of the fundamental practices of Domain‑Driven Design. And when I talk about the team building the software, I don’t just mean the programmers. I mean the whole team, including the business people that are deriving what the software should do. The discovery of the Rosetta Stone allowed us to unlock several different languages by showing the same message in three different texts. We don’t want to have to have a Rosetta Stone or any other sort of tool to help us translate between what the business is talking about and what the programmers are talking about. We want to make sure that everyone is speaking the same language the whole time so that translation is unnecessary. ‑Think about if you’ve ever used an online translation tool to round trip a sentence. You can run into similar communication issues in your application if you’re constantly having to translate to and from the domain expert terms or the programmer’s terms. Here’s an example of a user story for a sample system about creating appointments. ‑We have a lot of developer friends in Nigeria, so I thought it would be fun to try out Igbo for our translation. We used a website to translate between English and Igbo a few times, and in the end, the user story has changed just enough to create confusion. Translation software is pretty good these days, and we were hoping for a more humorous result, but according to animal experts, it’s close, but not the same as a veterinary technician. ‑But the point here, of course, isn’t just relating to different international languages, but to the different languages spoken by business experts and programmers. ‑Incidentally, a great practice when you’re discussing your system requirements with customers is to always try and explain back to them what you think it is they want the system to do so they have an opportunity to correct your understanding of what they think they just told you. ‑Definitely. Remember, one of the key benefits of using a ubiquitous language is that all parties can understand it without having to perform any translation. This means when you show a test or some code to a domain expert, you don’t have to explain that in the system you call something an animal when the domain expert calls it a patient. ‑Evans cautions that a project faces serious problems when it’s language is fractured. When domain experts stick to using their jargon while the technical team members have their own language tuned to discussing the domain terms in the design, translation errors will manifest as software bugs. Neither the customers nor the developer’s language is sufficient for all parties to discuss the application effectively. What is needed is a shared common language that incorporates and uses terms defined in the domain model. The use of this language must be ubiquitous, and the more the language is used, the more will force deficiencies in the model into the open. ‑And by ubiquitous, we mean it must be used everywhere within the bounded context. The vocabulary of the language includes the names of model classes and prominent operations. The team should use these common terms in code, in diagrams, on the whiteboard, in design documents, and especially when discussing the system. ‑Yeah, pretty much ubiquitous means everywhere, all the time. Even in that one email you’re sending off to another developer, stick to using the terms that you’ve agreed makes sense for this bounded context.\nConversation with a Domain Expert: Working on our Ubiquitous Language You’ve heard some of our conversations that helped lead to a ubiquitous language for the scheduling app. There was another important one that happened early on between Michelle and me that we want to share with you now. ‑Pay attention to not only the clarification of the terms, but also to the fact that Julie and Michelle are equal partners in this conversation. Although Julie is trying to lead the conversation towards the goal of identifying the correct terms, she’s careful not to make assumptions about Michelle’s domain. ‑So Michelle, last time you and Steve and I got together to talk, Steve and I have been working on just kind of fleshing things out and planning things, and I realized that we had some confusion over some of the common terms, like things that, as real pet owners, we would kind of assume the terms are, but then when we’re thinking about business and software, we’re thinking of the terms a little differently. So I was wondering if we could just sort that out with you so that we’re all on the same page and using the same terms and using terms that none of us have to stop and think about what we’re talking about. We’ll always know what they mean. ‑Sure. ‑The first thing is we have these clients, those are the people who own the pet. So when thinking about the software and business, we think of them as clients, but kind of in the real world, and me, I have a pet, I go to the vet all the time. I think of myself as a pet owner. So what do you refer to those people who bring the pets, pay their bills, call and make the appointments, etc? ‑Most of the time, I mean those would be listed as as clients. ‑Okay, so you do call them clients. You don’t worry about calling them owners, and of course, it sounds kind of weird to say I own a dog, right? ‑He kind of owns you. ‑Yeah, that’s more like it. You’re the pro you know. So then what about that dog, like are they patients, are they pets, are they clients? What do you refer to the pets as? ‑So for the purpose of the medical record, we refer to them as the patient. ‑Okay. So it would be client and patient. ‑Exactly. And actually in veterinary medicine they talk a lot about this triad, the veterinary client/patient relationship, where all three are really important in that. ‑Okay. So those are actually terms that are commonly used in your industry. Industry, that sounds so weird, but with that. Cool. Alright, so the next one we were also going back and forth on was an appointment or an office visit. When somebody is scheduling a visit, scheduling to come in, how do you refer to that? ‑So there would be two big subsets of what they might be scheduling to come in for. They might schedule a surgery, which is an easy one to define. They’re going to come in, we’re going to do some sort of a procedure. Usually, there is going to be some anesthetic involved. That would be a surgery and that would be outside of our normal office hours. ‑Oh, okay. So what about when they just come in for regular stuff? ‑So when they come in for regular appointments, you could call those office visits or appointments, and there are a few different subsets of those. You may have an appointment that’s a wellness exam, and in that exam, we would be doing, of course, a physical examination and generally wellness treatments like vaccination, some blood work, generally your healthy pet who is coming in for a routine checkup. ‑So that’s an office visit and there is a couple other things that come under the umbrella of office visit, but if I, I’m also thinking about scheduling because that’s the thing we’re really going to be focused on is the scheduling portion of the app. So we’re always scheduling an appointment, an appointment for a surgery, an appointment for an office visit, whatever type of office visit that is, so is using the term appointment, does that make sense? Would you, if if I said appointment would you think that could be a surgery, that could be a checkup, that could be whatever. This thing to be scheduled is what I want to define. ‑Yeah, I mean I think you could call them all appointments, but I would differentiate between the surgery and something that’s done in the office, but then I would further differentiate in the office between a wellness exam, an exam for somebody that’s coming in with a problem, or an exam that doesn’t need to see a doctor, but could just be done by a technician like a toenail trim. ‑Oh good. Yeah, we always need those, clickety‑clack on the floors. Alright, so I think then we’ll use just the overall umbrella of we’ll schedule an appointment and then we’ll be more explicit about what type of an appointment that’s going to be. Would that feel okay to you? ‑Yeah, that makes sense to me. ‑Great. Excellent. Alright, so I’ll get back to Steve and then we’ve got another meeting set up I think in a few days to just hash out some more details after Steve and I’ve gotten some more of our ducks in a row. ‑Sounds great! ‑Excellent. Thanks Michelle. Bye bye. ‑Thank you. Bye. ‑Now we have a stake in the ground for our ubiquitous language. As we continue working with Michelle, not only will we learn more items for the bounded context, but there is also a chance that the ubiquitous language will evolve. Eric Evans guides us to pay attention to those changes because a change in the ubiquitous language is also likely to mean a change in the domain model. We have to update our design to accommodate what we’ve learned.\nReviewing Important Concepts from This Module We’ve covered quite a few concepts in this module. One of the most important ones is just understanding the problem domain and the overall thing that your software is working within. ‑‑And breaking things apart. I know that when I started out, I had a really hard time really understanding differences between the core domain, the subdomains, and the bounded context, especially the subdomains and the bounded context because at first glance, they looked like the same thing to me. ‑‑Sure, it’s really easy to have an application where you have some kind of a concept, like a customer that you know is used by every system that your organization uses. And it ends up becoming this like God object in your database and in your different applications where any given application might only care about a tiny subset of that concept. ‑‑Yeah. So, for me, I think the most important thing is really focusing on the bounded context. Getting down to that and understanding about the boundaries. One thing that helps me a lot is just stating within the context of this and then suddenly like, oh right, that’s what a context is. It’s not like some mysterious new term that Eric Evans invented. He just is leveraging what makes sense. Within the context of appointment scheduling, this is what a client looks like. Within the context of billing, this is what a client looks like. ‑‑Sure, I think that makes a lot of sense. And it’s valuable, even when you have an application, like a legacy application that wasn’t built with domain‑driven design. Let’s go ahead and look at some more terms here. For instance, we’ve got what you were just talking about, I think of as context mapping. And even in a legacy application, it can be valuable to kind of map out what are all the concepts in this application and where are the overlaps with different subdomains that maybe we haven’t even defined in this legacy application. ‑‑Yeah. Even if you’re not planning on making huge changes to it, it’s still really, really helpful to just kind of update your perspective on things. Sometimes it just leads to new understandings. ‑‑I think the shared kernel is a really important part of this, too, because in almost every real‑world organization I’ve worked with, there are different types of cross‑cutting concerns, and we talked about one of them being the authentication piece, and that’s definitely a really common one. But there are usually others too that you want to share. ‑‑Yeah, and, again, it’s another one of those things that sounds like it might be a big, scary, mysterious thing because you haven’t referred to it that way, but if you really just start out thinking of it as the common stuff, but then‑‑‑I think one of the important things, though, is even within the context of domain‑driven design, we have a ubiquitous language because if I say common, you might have a different idea of what I mean by common, but if I say shared kernel, we’ve got an agreed‑upon understanding of what we’re talking about there. So at first, I really kind of pushed back against using these terms because I felt like a lot of the DDD experts were just throwing them around all the time. And then I started really getting a better understanding of why it’s important to use those terms. It’s about‑‑‑it’s the ubiquitous language of domain‑driven design so everybody’s on the same page. ‑‑Yeah, I do agree that that’s an important part of learning about DDD and other areas of software development, like, for instance, design patterns. These things give us these terms that we can use that are very, very dense. If we talk about shared kernel, it would take me three or four sentences to describe what I meant by that. But in these two words, you know exactly what I mean, just like if I talk about using a strategy design pattern, that is much easier to convey than if I were to try and describe it with words and have to draw a UML diagrams to say what I mean. ‑‑And it’s the same, again, with the ubiquitous language because now I really have a better understanding of the fact that what it means is the language is ubiquitous throughout a particular bounded context. When we’re talking about a scheduling app, we’re going to use these terms all the way through, like you were saying before, we use it not just when we’re talking to the domain expert but in our class names, in our methods, it’s just ubiquitous throughout all of the pieces of the things that are involved in that bounded context from one end all the way to the other of it. ‑‑And I think as we’ll see when we look at the code again, some of the constructs in .NET, like namespaces, are really appropriate to ubiquitous language because when you prefix that same term in your code with a particular namespace, that tells all the other programmers that if I say SchedulingApp.notification, we know that that has a different meaning that if I’m talking about EmailReminder.notification. ‑‑Or SchedulingApp.client versus Billing.client. ‑‑Exactly.\nReview and Resources In this module, we learned about our domain, in this case, a veterinary practice. We talked about it at length with a real live domain expert and identified the core elements of our domain model. We identified a variety of subdomains and focused in on the key area that we would be addressing first with our application. ‑We spent some time designing the system based on our conversations with Michelle, identifying boundaries between different contexts, and noting how sometimes the same object with the same name might mean something different within a different context. ‑Finally, we talked about the importance of communication in general and in particular having a ubiquitous language. We know that Domain‑Driven Design can help us avoid many design errors and wasted time miscommunicating as we work on a complex project. ‑Steve and I are so grateful to Eric Evans for spending time with us while we were creating this course in order to share his luminous advice and insights. In the next module, we’ll drill into the domain model so you can have a good understanding of its critical elements. ‑This is Steve smith, ‑and this is Julie Lerman. Thanks again for watching Domain‑Driven Design Fundamentals.\nElements of a Domain Model Introduction and Overview Hello, this is Julie Lerman, ‑and this is Steve Smith. ‑In this module, we’re going to focus on the elements of a domain model which are in our bounded context. ‑You’ve seen these in the mind map. It’s patterns like entities and aggregates and more. ‑You can find me online at ardalis.com or on Twitter as @ardalis. ‑And you can find me online at thedatafarm.com or on Twitter at @julielerman. ‑In this module, we’ll focus on the technical aspects involved when modeling a bounded context. We use these terms while modeling, and these same terms refer to patterns we’ll use when we code. The concepts flow through the entire process, which is great. You don’t have to keep switching hats or mindsets. ‑We’ll start by grounding ourselves in the domain and understand why it’s important to stay focused there. DDD models are driven by behaviors, not classes and properties. This is another very cool shift in thinking for those of us who have always focused on objects. Then you’ll learn about some terms used to describe domain models, rich and anemic. You learn what the terms mean at a conceptual level and what the code that they’re describing looks like. ‑Entities are the key types in your system, but not every type in your system is an entity. ‑You’ll learn how entities fit into DDD, how to differentiate entities that have complex needs from simpler entities that might only need some basic CRUD logic, and you’ll be able to see how we’re implementing all of these concepts in our code.\nThe Importance of Understanding DDD Terms Domain‑Driven Design is filled with lots of specific terms. Much like the ubiquitous language that we use to make it easier to communicate while working within a bounded context, understanding and using the terms of DDD makes it easier to talk about the process. We’ll spend the bulk of this module focusing on some of the concepts behind modeling bounded contexts, concepts that are critical to this process, but, unfortunately, often misunderstood. ‑I’ve definitely had my challenges with some of the DDD concepts. Some of my issues were because the terms overlap with other technologies I use. For example, I do a lot of work with Microsoft’s ORM called Entity Framework. Entities are a key element in Entity Framework, and they’re also a key element in DDD. So I thought my understanding of entities from Entity Framework was enough to translate to DDD entities, but it really wasn’t, and my less than solid grasp on DDD entities caused problems when I was trying to model domains and implement the model and code. We also have the concept of a context in Entity Framework. While the real goal of that context is to provide interaction with the database, it also does provide a boundary around a model. But it’s very different than the concept of a bounded context, and that definitely confused me for a while. Another important element in a DDD model is value objects. These got me pretty confused at first, and my ego was saved by discovering that others have also been confused by value objects. But I’ve worked on my DDD education and sorted these problems out, so in this module, it’s really important to both Steve and I that you start off on the right foot with a proper understanding of entities, value objects, and some of the other DDD puzzle pieces so that Domain‑Driven Design can help you with your complex problems, not complicate them even more.\nFocusing on the Domain It’s important to remember that first D in DDD stands for Domain, and yeah, the other two Ds, Driven and Design. But we really want to focus on Domain here. ‑By now, you’ve probably heard us talk about this plenty, but both Julie and I find that we constantly have to remind ourselves to focus on the domain. We hear ourselves begin to talk about the user interaction with the app and have to ask, well, what part of the vet clinic domain is this user? Yeah, obviously we care about the user and how the actual application will work from their perspective, but that’s for another conversation, and we have to draw ourselves back to focusing on modeling the domain. ‑I have quite a long history with data access, and I catch myself worrying about how our domain model will translate to the database so that things definitely get persisted correctly. That’s when Steve needs to give me that look, you’re doing it again, Julie, and I have to bring my focus back to the domain of the vet clinic again. So while it may seem redundant to harp on domain, domain, domain, this diligent focus will help you avoid the complications and distractions that come from thinking outside of the domain or the subdomain that you’re focused on. ‑Here’s an important quote from Eric Evans’ book about this focus on the domain. “The Domain Layer is responsible for representing concepts of the business, information about the business situation, and business rules. State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure. This layer of the domain is the heart of business software.” ‑Just to reiterate, the domain model is the heart of the business software. This is the whole point behind Domain‑Driven Design. Focus on the domain, not the technical details of how the software will work. ‑In a typical database‑driven app, we’re used to focusing on properties or attributes of classes. Our apps sometimes become all about editing property values and the state of our objects. However, when we are modeling a domain, we need to focus on the behaviors of that domain, not simply about changing the state of objects. ‑Michelle didn’t talk to us about setting the name of a dog or editing the time of an appointment. She told us that she needs to schedule an appointment, and when she does that, she needs to book a room and create a schedule item on a doctor’s calendar as well. So scheduling appointment is a lot more than setting the attributes of the objects involved, the appointment time and identity of the pet we’re making the appointment for. We’re talking instead about how the system behaves. In response to scheduling an appointment, the system should also book a room and do something to the calendars of the doctor and any vet techs that might be involved.\nIdentifying Events Leads to Understanding Behaviors An important way to identify behaviors in your system is by focusing on events. Doing so gives you a great path to understanding the behaviors of your domain. Alberto Brandolini devised a great way to brainstorm with clients, which is referred to as event storming. It begins by having a somewhat chaotic brainstorming session with a good number of domain experts writing events on Post‑its and sticking them on a wall. The format of what they write is in the past tense. For example, an appointment was booked, a client contacted the office, or a dog was weighed in. I facilitated quite a few event storming workshops with clients, and I’m a big fan of using this process to help get a picture of the domain, discover bounded contexts, and even discover key problems that should be addressed. Another interesting methodology for modeling a system based on events is called Event Modeling. Adam Dymitruk came up with this workflow and has had great success using it to help teams collaborate on learning about the domain and designing the flow of software. I was fortunate to participate in a three‑day workshop with Adam to learn about Event Modeling. We won’t be teaching you about event storming or Event Modeling in this course, those are beyond the scope of our goals here, but we did want to be sure you were aware of them. You’ll find links for more information about event storming and Event Modeling at the end of this module.\nComparing Anemic and Rich Domain Models In order to understand the difference between design that’s focused on attributes versus design focused on behaviors, it will help to understand two commonly‑used terms in domain‑driven design, anemic domain models and rich domain models. An anemic domain model is a domain model that is focused on the state of its objects, which is the antithesis of DDD. While the term is somewhat negative indicating a deficiency, you don’t need to perceive it that way. There is nothing wrong with anemic classes when all you need to do is some CRUD logic, but if you are creating a domain model, you’ve already made the decision that your domain is too complex for simple CRUD. So anemia in a domain model is considered an anti‑pattern. ‑Martin Fowler writes about anemic domain models with such drama that you may never mistakenly use them in your domain model. He says the basic symptom of an anemic domain model is that at first blush it looks like the real thing. There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have. The catch comes when you look at the behavior and you realize that there is hardly any behavior on these objects making them little more than bags of getters and setters. Indeed, often these models come with design rules that say you are not to put any domain logic in the domain objects. Instead, there are a set of service objects would capture all the domain logic. These services live on top of the domain model and use the domain model for data. ‑What we aim for then is rich domain models, not anemic domain models when we are modelling our domain. Rich domain models will represent the behaviors and business logic of your domain. Classes that simply affect state are considered an anti‑pattern in a domain model, and therefore, get the nasty label of anemic, even though they are perfectly fine in a CRUD model. Martin Fowler doesn’t mince words when it comes to anemic domain models saying the fundamental horror of this anti‑pattern is that it’s so contrary to the basic idea of object‑oriented design, which is to combine data and process together. I have to say I agree and I’ve worked with many teams who have had to deal with the self‑inflicted pain of treating their domain entities like DTOs lacking any encapsulation or behavior. That can work for simple CRUD apps, but it’s often a disaster in a DDD model. ‑While Martin Fowler and other DDDers have strong words to say about anemic domain models, we’d like to share a gentler message, which is to strive for rich domain models and have an awareness of the strengths and weaknesses of those that are not so rich.\nUnderstanding Entities Even though a DDD app is driven by behavior, we still need objects. DDD expresses two types of objects, those which are defined by an identity and those which are defined by their values. We’ll focus first on the objects that are defined by their identity. These objects are called entities. ‑An entity is something we need to be able to track, locate, retrieve, and store, and we do that with an identity key. Its properties may change, so we can’t use its properties to identify the object. If you’ve done any type of data persistence in software, you’re probably pretty familiar with entities and their keys. When we are modeling a problem, we can talk about entities without having to think about how they are implemented in the resulting software. But when it is time to start coding, there are patterns to follow to ensure that these objects have the technical attributes of Domain‑Driven Design entities. ‑As you can see from this section of the DDD navigation map, entities are pretty integral to our software. So, before we can learn about these other elements, domain events, repositories, factories, and more, you should have a very good understanding of an entity. ‑The most important entity in our model is Appointment. This is what we will be creating, editing, and retrieving in the context of scheduling appointments. Appointment inherits from a base class we’ve created called Entity. We’ll look at that more in just a bit. Notice that all of the classes shown here are inheriting from the identity base class. However, although the other classes are entities, after our discussions with Michelle, we came to the conclusion that we would like to have a separate utility for managing client and patient information and to manage information about staff and staff scheduling. Thus, we don’t need very much information or behavior related to these collaborating entities within the bounded context of appointment scheduling.\nDifferentiating CRUD from Complex Problems that Benefit from DDD ‑Let’s take a closer look at that data that supports scheduling appointments in our system. ‑We determined that managing the client, patient, and staff information, which is external to this model, was well‑suited to just simple CRUD. We didn’t identify complex rules or behaviors for creating and editing that data. Thus, the concepts of doctors, rooms, clients, and patients are managed outside of the scheduling bounded context. ‑For comparison, look at the CRUD classes for Patient and Client in the other bounded context. They’re very simple. They don’t inherit from our entity base class, and most interestingly, their ID properties are integers. We’ll let the database assign the IDs when we create these classes. So these classes are not designed using domain‑driven design. Now let’s go back to the appointment scheduling context. The client, patient, doctor, and room classes here are completely different from the CRUD classes we just saw. However, they do have a subset of the same fields from those CRUD classes. All we need to know about these objects when we’re scheduling is their IDs, their names, and maybe a few other details. But here, they’re simply used as look‑up data, and they’reread‑only.\nSwitching Between Contexts in a UI Even though our domain is split up into a number of bounded context, the user interface can be designed in a way that moving from one context to another is seamless to the end users, they don’t need to know that these things are in separate bounded contexts. While maintaining client and patient data is a completely separate task from scheduling appointments, Michelle wanted to be sure that anyone working at the front desk is able to easily move between these tasks in the software without disrupting their workflow. So let’s say the person at the clinic who does the scheduling is on the phone with Kim and about to make an appointment for Roxy to come in, but then the other line rings, they put Kim on hold, and it’s me. And in the nicest way possible, I’ve called to just let her know they’ve got my last name spelled wrong. That happens all the time. People just want to put that h in there. Even though they’re in the middle of scheduling and scheduling has its own backend, its own bounded context, and is totally separate from client management, they can still drive the app right over to the Client Management area and very quickly fix my name and save that. Then they can just flip back to the schedule. Notice that Kim is still the active scheduling client that’s showing up in the left‑hand corner and the change to the spelling of my last name is already visible on the schedule. And so now that person can go ahead and finish up with Kim scheduling the very adorable Roxy for a wellness exam. To the user, there is no real difference between doing the scheduling and doing the client management, it’s just a nice smooth flow between the two, it doesn’t feel like, oh, now we have to open up a different application in order to do this other thing and doesn’t break everything they’re in the middle of, but for the purposes of designing our application, everything is bound within its own individual context. And when designing this context, we don’t have to worry about switching from one context to another. ‑So remember, we’re talking about what makes these all entities. An appointment object needs to be located and tracked and we need to be able to edit them easily. Using a unique identity allows us to persist and retrieve an appointment even if some of its values change. Appointment is definitely an entity in our system. We actually had to think a little more about client, patient, doctor, and room in this particular context. Our discussions highlighted the fact that when creating appointments, we only need access to some of the high‑level information about the client, patient, doctor, and room, but these objects won’t be edited. So we wanted these stripped down read‑only types that give us minimal amount of detail for each. We do still need to be able to uniquely identify them though, they do have some identity. If the client’s name changes, a change we would make in the client management system, that new name will need to be reflected when we look at the appointment scheduling for that client. There should only ever be one record to represent a particular client in this bounded context. So client and the other types that are reference types in this context are still entities. We triple checked our decision with another kind of domain expert, Vaughn Vernon, a DDD expert, and we were happy to get his thumbs up on this particular decision. So Julie, Michelle, and I also talked about how to name the types that are simply reference types in this particular bounded context. At first, we were worried that we might get confused by having different definitions of client, patient, doctor, and room. We wanted to call them client details or client view or something like that, but thanks to the ubiquitous language, the fact that we are in the scheduling context drives our comprehension of what a client means in this particular space. ‑A client in scheduling is still a client, so we use the same name, even though it’s a differently defined pipe than the client we work with in the Client/Patient Management app. ‑Right, and thanks to namespaces in our code, we’re able to keep it clear which ones are which in the code.\nUsing GUIDs or Ints for Identity Values So, all these types inherit from our base entity class. However, notice that those reference types use int for their base entity’s ID and not the GUID that’s used by appointment. That’s because all of the management of those other types happens to be done using CRUD, and with CRUD, it’s easy to just use database‑generated ints. Appointment is built using DDD principles, and you’ll see that it’s much easier to use GUIDs when building DDD entities and their related logic rather than relying on the database to provide the identity values. Not only is it easier, but it follows DDD principals more clearly, since we will build all of our domain logic around appointments without involving the database. We would have a hard time working with appointments in our model and in our unit tests as we develop the application if we always needed a database to assign their IDs. ‑So that’s not to say that you can’t use integer IDs If you’re going to use a DDD style of application; it just makes it a little harder. Wouldn’t you say, Julie? ‑Yeah, yeah, and I’ve definitely come up against that. With the stuff that I do with Entity Framework, I’ve made sure that I show patterns for continuing to use the database‑generated ints because I didn’t want to give people the impression that they had to throw away, like, for me like 25 years of this dependency. And like all of a sudden I have to go cold turkey and move over to GUIDs. ‑Sure, I mean, there’s trade‑offs in what you choose to use for your ID, but having an ID that we can generate in the client and just in our code has a lot of value. ‑Every time we’ve been working on some of our different unit tests and we needed as part of the test to instantiate something that was an int, we were like, ugh, now we have to find another way to get that in there because we were protecting it and it was a problem. As our own experience grew, we realized there’s another way to bridge this conflict by using both GUIDs and database‑generated ints in an entity. This way, while creating objects, you’ve got the control over key generation with the GUIDs, and they’re not depending on the database. However, once the data has been created in the database and int keys exist for it, then you can benefit from those when adding indexes and performing queries in the database.\nTalking with Eric Evans About the Responsibility of Entities We talked with Eric Evans to gain some additional insight into entities. Specifically, I asked him how entities align with the single responsibility principle. ‑‑If you’re not familiar with this object‑oriented programming principle, you can learn more about it in Steve’s SOLID course right here, on Pluralsight. ‑‑One of the questions that I’ve heard is, What is the single responsibility for an entity? Or to put it another way, does having an entity that has a lot of business logic in it violate the single responsibility principle? ‑‑Eric told us that entities are very central, and so it’s natural that they get heaped up with lots of functionality. ‑‑But there’s a downside to this. As you build out the system, there are more and more conflicting demands for these central entities, so they end up being huge. Evans said that the main responsibility is the identity and the lifecycle. ‑‑Eric also told us that single responsibility is a good principle to apply to entities, and it points you towards the sort of responsibility that an entity should retain. Anything that doesn’t fall into that category, we ought to put somewhere else.\nImplementing Entities in Code Let’s take a look at an entity in our veterinary appointment scheduling application, FrontDesk. We’re going to look at the Appointment class, which defines all the information that we need to schedule an appointment for a particular animal or patient. It associates the patient with the doctor, room, and appointment type, and also includes the start and end time for the appointment. Now, the Appointment class inherits from BaseEntity, which is a generic base class. In this case, it’s BaseEntity, as you can see here. The GUID is defining the type of our identity property, our ID. ‑Right. And we talked about that earlier when we were looking at the structure of the different entities in this model. We wanted Appointment to have a GUID because we’re creating new appointments on the fly. So, let’s take a look at that BaseEntity class. First of all, it’s an abstract class. So we can’t just create a BaseEntity object, we have to create something that is a BaseEntity, such as an appointment. And using generics, we’re saying that the BaseEntity is going to use whatever type we ask it to, and that type is for defining the ID. So for Appointment, we said BaseEntity is going to be using a GUID as its identity. I mentioned this earlier, why I would need GUID for appointment in this context because I need to be able to create new appointments in this context, and I’m not going to be waiting for the database to generate the ID for me. So using a GUID lets me create that ID right up front as I’m creating that new appointment. So I’m giving it its ID. The BaseEntity class also has a property to hold a list of domain events that will define explicitly for each of the types that inherit from this base entity. You’ll learn more about domain events further on in this course. ‑All right, so let’s take a look back at the rest of Appointment. Now, since Appointment has more behavior than just state, we don’t want to have it just be a bag of properties that our application can get and set however they would like. ‑Because that would be an anemic domain model. ‑Yes, because that would tend to lead us toward a more anemic domain model. ‑And we want a rich one. ‑Now, in particular, we’re also constraining how we create this appointment. We want to ensure we create appointments in a valid state, so that means passing in the minimum necessary elements an appointment needs to have. Sometimes we’ll want to update an appointment. Remember, these aren’t value objects. They’re not immutable, so we can change them. When we need to modify an appointment, we’re going to do that through methods. And so, for instance, if we decide we want to modify what room an appointment is scheduled in, we’re going to do that through a method rather than just a setter. We do this because there’s additional behavior we may want to do. In this case, we have some guards, again to ensure a valid value is being passed. ‑These guards are a set of reusable functions that you’ll find in the shared kernel of our solution. ‑And we also want to raise an appointmentUpdatedEvent, that we might handle and send a notification or perform some other action as a result of what happened. ‑And that also gives us the flexibility in the future to change what type of logic we want to trigger. ‑And that’s something we can’t do very easily If we just let anybody in the application set the value. ‑Right. ‑By providing a method to use to update room explicitly and otherwise making the setter private, we force all interaction with the model to use this method, which gives us just one place to model behavior that should be associated with this operation. It’s the same as with the constructor, we need to do our best to keep our domain model in a consistent state so the rest of the application can count on it being correct. ‑Right, because otherwise somebody could satisfy the requirement that they pass in the room ID, but they might pass it in as 0, which would be invalid. So, we’re further constraining that they don’t do that either. The appointment would be invalid if it had a room ID that didn’t correspond to an actual room entity. And in any case, the database wouldn’t let that fly since there’s a foreign key relationship between appointment and room. ‑Yes, but we want to make at least some effort to catch such problems in our code, rather than relying on the persistent store to inform us of a user error. Overall, using guard clauses, like the ones you’ve seen here, help us ensure our entities aren’t partially constructed and inconsistent. Once we’ve created an appointment, we need to record it as part of the clinic schedule, which involves some additional rich behavior. So, if we scroll down to the bottom, we have this method called Schedule. And this is where we’re going to do the additional work involved with actually saving an appointment and ensuring it fits in with other appointments that have already been scheduled. We’re not going to worry about the code at the moment, but the idea is that this method would query the database for other appointments that might be near this one and make sure there is an available slot in the schedule that this one fits into. Then it will save the appointment and raise an event, letting the rest of the app know that a new appointment has been scheduled. In the next module, we’ll investigate this design further and revise it a little bit. Now, let’s look at one more simple entity that this bounded context needs, the Doctor class. You can see that Doctor inherits from BaseEntity as well, but in this case it’s using an int for its key. The only other property it has is a string Name property. ‑This is a minimal implementation of the Doctor type that satisfies the scheduling bounded context. It’s essentially no more than a reference type. Doctor and the other similar types, Patient, Room, etc., are all organized into this folder called SyncedAggregates.\nSynchronizing Data Across Bounded Contexts Let’s dig a little more into how these reference types in the scheduling bounded context are getting their data from the Clinic Management app, especially if the two BCs aren’t sharing a database. If you recall from seeing the class descriptions of all of these classes, the AppointmentType, Client, Doctor, Patient, and Room, we had explicitly decided that these are reference entities where we’re actually doing their maintenance elsewhere so they’re not adding any unneeded complexity to the Front Desk application. ‑‑Right. And they’re just READONLY. So we’re never having to create or modify them. ‑‑And we’re using the ints that were created by the database when we persisted these with a CRUD context in a different application, but there are still entities here, just entities of type integer. The Clinic Management bounded context is responsible for updating these types. When changes are made, application events are published by Clinic Management, and this Front Desk bounded context subscribes to those events and updates its copies of the entities. ‑‑One of the questions we get all the time when we describe how bounded contexts have separate databases is, How do we synchronize changes between these two apps? This is one of the simplest and most common approaches. One app is responsible for updates, and the other apps just subscribe to the changes and are notified when they occur. ‑‑This is an example of eventual consistency. The two systems aren’t immediately kept in sync using a transaction or something similar, but through message queues, eventually the different bounded contexts are updated to the new state when a change is made.\nReview and Resources We’ve covered a lot of ground in this module and you’ve learned a lot of new terms, so we just want to review some of them with you before we move onto the next module. The first is a pair of terms that often go hand in hand, anemic domain models versus rich domain models. And remember the anemic domain models, while often looked down upon from the perspective of DDD, they’re perfectly fine for CRUD. These are models that look a lot more like a database schema than a class that has lots of methods and rich behavior in it. On the other side of that is a rich domain model, which is what we strive for in domain‑driven design, and that’s a model that really is focused on behavior, not just changing the values of properties. ‑Then we talked about entities and entities tend to be one of the core pieces of our domain model. The key thing that distinguishes an entity from other types in our model is that it has some kind of identity that we can use to track it over time and to bring it in and out of persistence. This module provided you with your first look at implementing a bounded context in code, an important part of tactical design. You learned about the difference between anemic models and rich models, and that while anemic models have their place, focusing on behavior with rich domain models is how DDD lets us solve complex problems. Entities are the classes in our domain models that are tracked by an identifier allowing us to build graphs and eventually persist and retrieve that data. ‑Sometimes we are working with entities whose behavior and rules are critical to the bounded context in which we’re working. Other entities may only provide supporting or reference data. You learned how to help identify the differences between them. Then you got to look at the appointment class in our scheduling app to see how we have applied rules and behaviors in that entity. You also looked at one of the reference entities and learned how we use message queues to ensure the reference and the data that is maintained in the clinic management app is made available to the scheduling bounded context, even though they do not share a database. ‑In the next module, we’ll focus on some more important elements of a domain model, value objects and domain services. We’ve referenced a lot of interesting and helpful resources in this module and here are two pages of links for you to follow up with if you want to dig in a little further, including Steve’s Pluralsight course on SOLID principles of object‑oriented design and information on event storming and event modeling. This is Julie Lerman ‑and this is Steve Smith, and thanks for watching our course, Domain‑Driven Design Fundamentals.\nUnderstanding Value Objects \u0026 Services in the Model Introduction and Overview Hello! I’m Julie Lerman. ‑And I’m Steve Smith. Welcome back to Domain‑Driven Design Fundamentals. In this module, we’ll continue exploring the elements of a domain model as we dig into value objects and domain services. ‑Value objects are a confusing concept. So we’ll begin by looking at where they fit into the mind map and introducing what makes an object a value object, and how they relate to entities in a model. ‑We’ll share some more guidance from Eric Evans and Vaughn Vernon, and then show how we’ve implemented value objects in our code. ‑Next, you’ll gain a high‑level understanding of domain services, and solidify that by exploring their features, and then some examples of domain services.\nGetting Acquainted with Value Objects When introducing entities, Steve and I talked about objects that were defined by a thread of continuity and identity, not defined by their values. So, what about objects that are defined by their values? These are called value objects, and they play an equally important role in a domain model, as entity objects do. ‑A value object has very specific characteristics. It is an object that is used to measure, quantify, or describe something in your domain. Rather than having an identity key, its identity is based on the composition of the values of all of its properties. Because the property values define a value object, it should be immutable. In other words, you shouldn’t be able to change any of the properties once you’ve created one of these objects. Instead, you would simply create another instance with the new values. If you need to compare two value objects to determine if they are equal, you should do so by comparing all of the values. Value objects may have methods and behavior, but they should never have side effects. Any methods on the value objects should only compute things; they shouldn’t change the state of the value object, since it’s immutable, or the system. If a new value is needed, a new value object should be returned. Don’t confuse the value object’s pattern with C# and .NET support for value types and reference types. Custom value types in C# are defined with structs, while reference types are defined as classes. In DDD, both entities and value objects are typically defined as classes. Classes have advantages over structs when it comes to encapsulation and support for inheritance‑based extension and reuse.\nRecognizing Commonly Used Value Objects To help you better understand the basics of value objects, let’s take a look at some value objects that you probably use all the time as a developer. The most commonly employed value object is a string. In .NET and many other languages, a string type is immutable, and you now know that immutability is one of the key attributes of a value object. A string is a collection of characters, and the combination of all those characters give that string meaning. For example, C‑A‑R in English, a car. If a string were mutable, we could change the R to T. Now the string is C‑A‑T, a cat, which has a very different meaning than a car. Or we could add a letter, maybe put an S in front of it, turning CAR to SCAR, also completely changing the meaning of car. But it’s not just the array of characters that gives a string its meaning, the order of them is also critical. Just think of the word dog, d‑o‑g. Shifting its letters around gives us something with a very different meaning. ‑So one of the things that .NET makes it really easy to do is to modify strings, like you can change the length of it or make one all upper case. But when you call, for example, ToUpper on a string, it doesn’t just change that string object, it gives you a new instance of a string that now has all uppercase characters. ‑Many developers say that monetary values in financial systems have been perfect candidates for value objects in their system. And Ward Cunningham provides us with a really helpful example, a company’s worth. If a company is worth 50 million dollars, that means something, 50 million dollars. It’s a very specific measurement. Fifty million on its own is not a measurement, it has no meaning without the unit, which in this case is dollars. But dollars alone doesn’t describe worth either. In fact, dollars doesn’t really help, does it, because is it US dollars or Canadian dollars, Australian dollars? It only makes sense when you put the two together as 50 million US dollars. There’s actually one more factor to take into account, is the point in time of this 50 million dollars because of the way financial systems work and the fluidity of monetary values. ‑We could still just have the two properties in this Company class, but by creating a value object you also protect and constrain the measurement. For instance, we might have a class called Company. It might have one decimal property that represents the worth amount and another string property that represents the worth unit. The problem with this approach is that it doesn’t tie these properties together in any way. These two properties appear to be independent of one another, but they’re obviously closely related. If an update is made just to the Worth Unit string, it could obviously have a tremendous impact on the company’s worth as a combination of these two concepts. Fifty million rupees has a very different worth than 50 million US dollars. To ensure nobody can set the unit without also specifying the amount, a separate value object can be introduced to represent the entire worth concept. This ensures the entire object must be updated as a whole. Since the worth type is immutable, the only way to make updates to the Worth property on the Company class is by replacing the whole instance with a new one, not just changing an isolated field. ‑A value object is not always for a measurement though. It can be another type of description. Eric Evans calls out dates as a great example for value objects. I’ve used this one often, DateTimeRange, and it was perfect for the vet appointment scheduling app. We usually set a start and an end time together and can’t really set one without the other. Also, we often need to pass the two values, start and end time, around from one method to another. So we’ve encapsulated them in a value object called DateTimeRange. The properties have private setters, which makes the object immutable since we can’t change them. We aren’t showing the full logic of the class here, but when we look at the value objects in our application you’ll see more of how we implement a value object in our software to ensure that it meets all of the attributes, not just immutability, but how we handle equality, comparison, and other logic.\nGetting More Insight from Eric Evans and Vaughn Vernon In his book, Implementing Domain‑Driven Design, Vaughn Vernon recommends that we should try to use value objects, instead of entities, wherever possible. He says, it may surprise you to learn that we should strive to model using value objects instead of entities wherever possible. Even when a domain concept must be modeled as an entity, the entity’s design should be biased towards serving as a value container rather than a child entity container. What this means is that you’ll find that your design will have a number of entities who have very little logic of their own or very few primitives as their properties, but instead will have a number of properties that each are themselves a value object. ‑So he’s not saying everything should be value objects, but that it’s probably our natural instinct to start by thinking of things as entities and then maybe once in a while go, oh, maybe that should be a value object. So what Vaughn is suggesting is really start by thinking every time should this be a value object and you will surprise yourself at how many times something that you originally might have thought of as an entity really does make a lot more sense as a value object. ‑Or sometimes when you’re looking at an entity, there might be a couple of properties that seem to always go together, you might be able to bundle these properties into a single value object. It’s interesting to note that identity values can be treated as value objects as well. In many systems, entities have a primitive type, usually int or GUID as their ID, but this means that it’s easy to substitute a client ID for a patient ID if developers are not careful. By creating actual value objects for client ID and patient ID, which can still be stored as ints or GUIDs, it can eliminate this kind of error from our design. ‑Here is an example of a Client class that’s inheriting from base entity, but specifying that the type will be ClientIdValueObject rather than a scalar type like int or GUID, that’s followed by a service class that has a CreateAppointmentFor method which takes a clientId and a patientId. If those IDs were both GUIDs, the runtime code would allow you to accidentally pass them in in the wrong order because the signature is only constraining that you pass in two GUIDs and that could create a big problem when you’re trying to build an appointment. But with the specialized value objects, you can tightly constrain the parameters to avoid this problem rather than adding a lot of extra logic elsewhere to protect you from making that mistake. For me, this highlights the beauty of DDD thinking. With this little bit of upfront work, you’re removing the complexity of solving the kind of problem that could be created by accidentally transposing the client id and patient id. In our conversations with Eric Evans, we asked him for his thoughts on putting logic into value objects. He told us that he thinks value objects are a really good place to put methods and logic because we can do our reasoning without side effects and especially the complications that identity brings along, all those things that make logic tricky. We can put functions on those value objects and then do the pure reasoning right there in the value object. ‑Eric also called out date libraries as a good example of a value object. They perform common functions on dates so we don’t have to keep coding them ourselves in our entities or services. For example, a date library could be used for calculating a person’s age from their birth date. As long as the library causes no side effects to the date in question, it can work well as a value object.\nImplementing Value Objects in Code Our primary demo involves scheduling appointments. Appointments have a start and an end time. These two things always go together, so they make sense to extract as a value object. Here’s a closer look at the DateTimeRange ValueObject we created for the course’s demo. We also have a DateTimeOffsetRange, which is identical, but includes support for time zones. Because DateTimeRange is a pretty low‑level concept that could be useful in a number of different applications, it’s implemented in the shared kernel package. The class inherits from a ValueObject base class that provides flexible equality checking behavior, so we don’t need to clutter our class with overloads for Equals, GetHashCode, et cetera. It was written by fellow author and DDD expert, Vladimir Khorikov. ‑Because this is a ValueObject, you can see that all of its properties are read only. Recent versions of C# and Entity Framework Core do allow us to avoid even having a setter in there when we want to define read‑only properties, and we also now have the use of records in C#. EF Core can comprehend read‑only properties that don’t have any setters at all, and it takes advantage of fields. But here we’ve written our value objects in a more generalized way that’s not taking advantage of any specific or specialized features. However, you can adapt these samples to benefit from those specific APIs and language versions that you’re working with. The important goal here, though, however you implement it, is that the state of the value object should not be changed once it’s been created and as part of the domain model. ‑Right. Value objects should get all of their state through their constructor, and any invariants that need to be checked should happen in a constructor as well. In this case, the date time range is guarding against having a start time that exceeds its end time. If it does, an exception will be thrown. The second constructor that takes a timespan calls the first one using constructor chaining, so in either case, the guard will always be enforced. Since the DateTimeRange is immutable and cannot be created in an invalid state, the rest of the domain model can count on it being valid. ‑Our DateTimeRange type does have some additional methods that let us create new DateTimeRange instances from existing ones, much like the DateTime type provides options to create new date times by adding time to an existing instance. In our type, for example, to change an appointment set to end at 10:30 instead of ending at 11:00, a new instance of DateTimeRange can be created using the newEnd method. Finally, the base ValueObject class requires overriding a GetEqualityComponents method. This is used when comparing two instances of the ValueObject, and it’s up to you to decide which properties should or shouldn’t be included. In the case of DateTimeRange, the start and end times are sufficient. If two DateTimeRange instances have the same start and end values, they should be considered equal. ‑Custom logic needed to determine whether one appointment overlaps with another is another area where the ValueObject can help. The whole appointment isn’t needed to determine if there is an overlap in appointments. Only the DateTimeRange is used in such a calculation. Thus, the Overlaps method, shown here, has been moved out of the Schedule and Appointment classes and into the ValueObject, where it is more reusable, and it reduces the complexity and responsibilities of the other domain types. ‑We asked Eric to share his thoughts on moving logic out of entities into value objects. He agreed that it’s a good idea. What he said was if there’s logic that’s really the classic software logic, I like to add that in value objects. You can really test value objects much easier than entities, and you can use them much more freely. So your entity becomes this critical piece of glue, an orchestrator among different value objects. But that doesn’t mean that you won’t have some logic in the entity. It’ll just be very concise. ‑Eric also said that it’s a nice way to work towards the ubiquitous language to the point where you look in the methods of the entity and you see higher‑level things. They read like use case level communication, rather than nitty gritty detail. My personal takeaway from this is to keep an eye on the properties of your entities, and specifically, their types. If you find that they’re all primitive types, like ints and strings, think about if any of those primitive things could be grouped together as value objects instead. Another value object that we can point out here is the AnimalType. This is just to give you an idea that our value objects can be extremely simple. In this case, AnimalType is just a combination of the species and the breed of a particular pet or patient that we’re dealing with at the vet clinic. And there’s not a whole lot of other behavior here. But it does provide us with a container by encapsulating these two related properties together as a single value object.\nUnderstanding Domain Services When an operation is important to the model but doesn’t necessarily belong on any one entity or value object, a service is often appropriate. But don’t be too quick to give up on finding a natural home for the operation on an existing entity or value object or you may end up with a very procedural anemic model. Frequently, domain services serve as orchestrators for operations that require several different collaborating entities or value objects. Evans notes that good domain services must first and foremost not be a natural part of an existing entity or value object. Again, we don’t want to shift all of our rich behavior from our entities and value objects to our services. Services should also have a defined interface that’s comprised of domain model elements. And finally, domain services should be stateless, though they may have side effects. What this means is we should always be able to simply create a new instance of a service to perform an operation, rather than having to rely on any previous history that might have occurred within a particular service instance. But of course, the result of calling a method on a service might result in changes to the state of the system itself. These rules apply specifically to domain services which belong in the core of our application. Your software will likely also use services to perform work related to infrastructure or as part of the front end of the application. ‑Here are some examples of the kinds of services we might find in different layers of a DDD application. The UI layer represents the front end of the system and should have as little business logic as possible. It is frequently combined with the application layer, which should be concerned with behavior necessary for the application, but unrelated to the customer’s problem domain. For example, the application may need to work with file formats or parse some XML, and it might have services for these purposes, but these are unrelated to the domain. In the core of the application where we store our core model and domain objects, we will define any domain services for operations that don’t belong somewhere else. These services will frequently involve operations on multiple domain elements or may be responsible for orchestrating some kind of workflow. For instance, processing an order might involve a series of steps and multiple domain elements as the system checks inventory, verifies customer information, maybe charges a credit card, and then sends messages to ship the order, notify the customer, and reduce inventory. Finally, we have infrastructure‑level services. These will usually implement interfaces that are defined in the core of the domain, such as I send email. But since they require access to external dependencies, like file systems, databases, or network resources, they live in the infrastructure layer of the system. With respect to our domain, you may find infrastructure not very interesting, ‑although the people who create the internal workings of those services might find them quite fascinating. We’ll look at implementing services in our application later on in the course.\nReview and Resources Let’s review some of the important terms you learned in this module. You heard us talk about immutability, which is a really critical attribute for value objects. And immutability just means once an object has been instantiated, you can’t change the value of any of its properties. ‑Another important term we learned about is the value object. A value object is an immutable class that is defined by the sum of the different properties that it has. We don’t need an identity for a particular value object. In fact, a value object doesn’t have any identity outside of the individual properties that it has. And in order for us to compare value objects, we simply compare all of its properties, and if they all match, then we can consider these two value objects to be equal. We also learned about domain services and these are interesting because domain services give you a place to put logic and behavior that you can’t find a home for in the entities and value objects in your domain. ‑And the last term that we want to review is side effects. Side effects are changes that occur in your application or any kind of interaction with the outside world. Now, technically any change to the state of the application can be considered a side effect, but generally when we’re talking about them, we’re talking about things that changed other than the main intent of the operation that you’re performing. For instance, it’s often a good idea to keep operations that query information separate from those that change state, and if you follow this practice, then any queries that you make, that result in changes to state would be said to have side effects. That brings us to this module’s key takeaways. Most of this module was focused on value objects, which are used in your domain model to measure quantify or describe something in the domain. Value objects typically don’t exist alone, they’re usually applied to an entity to describe something about it. ‑Value objects should be compared using only their values. They don’t have an identity. Any two value objects that share the same values should be considered equal. And value objects in our domain should be designed to be immutable taking all of their needed values in their constructor and they shouldn’t have any side effects. ‑We looked at a few examples of value objects in this module. We mentioned the .NET Framework string type that you’ve no doubt used. Strings and datetimes are value objects that are available to any .NET application and can be used as a model for how you should design your own value objects. We also looked at a couple of custom value objects we used in our sample application, the datetime range and the animal type objects. ‑Finally, we wrapped up the module by introducing domain services, which are used to orchestrate operations between different parts of your domain model. Remember that domain services should generally only be used if you don’t have an entity or value object where the behavior makes sense. Overuse of domain services can lead to an anemic domain model. In the next module, you’ll learn how to build aggregates from entities and value objects while respecting their relationships. Here are some links and resources relevant to the topics of value objects and domain services that we discussed in this module. Thanks for watching Domain‑Driven Design Fundamentals.\nTackling Complexity with Aggregates Introduction and Overview Hello, this is Julie Lerman. ‑And this is Steve Smith. ‑Welcome back to Domain‑Driven Design Fundamentals. In this module, you’ll learn more about aggregates and the associations between entities. ‑We’ve talked about the domain model and the need to have effective communication in order to ensure the model is a useful representation of the customer’s problem space. However, most problems that weren’t using domain‑driven design can be quite complex. So now we’re going to specifically look at some patterns and techniques that can be used to manage this complexity. ‑We’ll cover several new terms along the way, including aggregates and aggregate roots. You’ll learn about invariants and the aggregate roots’ responsibility for them. Aggregates often contain related data, so we will explore how to model relationships, often referred to as associations in DDD. ‑Then, we’ll look at our application and see how thinking about the aggregate roots pattern helps us revise and simplify our model. ‑And finally, we’ll walk through how we’ve implemented this pattern in our code.\nTackling Data Complexity Let’s start by considering data complexity. If you’ve ever worked on a relatively large or mature application, you’ve probably seen some fairly complex data models. One way to reduce the complexity that we already talked about is using aggregates and aggregate roots, which you’ve seen in the DDD mind map. Another is by limiting how many bidirectional relationships you have in that data model. ‑If your design doesn’t have any clear notion of aggregates, the dependencies between your entities may grow out of control, resulting in a model like this one. And if your object model reflects a data model like this one, trying to populate all of the dependent objects of one object might result in trying to load the entire database into memory. And the same problem exists when it comes time to save changes. With a model like this, there’s just no limit to which areas of the data model might be affected. ‑Even though in the real world at the highest levels of your system all of these things really do interrelate, we need to be able to separate them to keep the complexity of the system in check. ‑I’ve gone into a lot of clients where their entity data model looks like this, and they’re using this one big, huge single model throughout their entire system. So, one of the things that I work on with them is breaking this down and using the whole concept of bounded contexts to start looking at what makes sense for smaller models. ‑Yeah, a system that’s designed like this is what we tend to call a big ball of mud because everything is just kind of slapped together, and it collapses under its own weight once it gets to a certain level of complexity. ‑Great. So, let’s see how we can use aggregates to help solve the problem.\nIntroducing Aggregates and Aggregate Roots Aggregates consist of one or more entities and value objects that change together. We need to treat them as a unit for data changes, and we need to consider the entire aggregate’s consistency before we apply changes. In the examples shown here, the address is part of the customer and the component is quite literally a part of the product. We can treat a set of changes to a customer and their address as a single transaction. Every aggregate must have an aggregate root, which is the parent object of all members of the aggregate, and it’s possible to have an aggregate that consists of just one object, in which case that object would still be the aggregate root. ‑In some cases, the aggregate may have rules that enforce data consistency that apply across multiple objects. For instance, maybe our product consists of a collection of components, but in order to be in a valid state, it needs to have a specific set of such components. As an example, if the product is a Lego minifig, the collection of parts won’t be a valid product unless it includes a head, an upper torso, a lower torso, two arms, two hands, and two legs. If we allowed the collection of components to be modified independently of the product it was associated with, we could easily end up with consistency problems. If we want to modify the composition of a product, in this example, we should do so as a transaction, so that we start and end with a valid product. Data changes to the aggregate should follow ACID, that is they should be atomic, consistent, isolated, and durable. It’s also the responsibility of the aggregate root to maintain its invariants, such as the number and type of components it requires in the example. An invariant is a condition that should always be true for the system to be in a consistent state. When considering whether particular objects should be treated as an aggregate root, you should think about whether deleting it should cascade, in other words, if you need to also delete the other objects in its aggregate hierarchy. If so, it’s likely the object in question should be considered an aggregate root. ‑Another way to think about whether it makes sense to have an object as an aggregate root is to ask, does it make sense to have just this object detached from its parent? In the example shown here, if you’re deleting the minifig, then you have to delete all of its parts. Conversely, if you have to delete a head, maybe it got broken, you don’t need to delete the rest of the parts. Therefore it doesn’t make sense for the head to be the root of this aggregate. ‑In the Domain‑Driven Design book, Eric Evans states this pretty simply, he says, an aggregate is a cluster of associated objects that we treat as a unit for the purpose of data changes.\nConsidering Associations in Aggregates When considering aggregates, which, as Evan says is a cluster of associated objects, it’s also important to think about relationships between those associated objects, especially those which exist within the aggregate. Before diving into how related entities participate in an aggregate, it’s important to learn some important concepts that DDD brings to us when considering relationships among entities. ‑Many developers, myself included, tend to define relationships between classes in both directions. For example, an order has a line item and a line item has an order, a pet owner has pets and a pet has an owner. Many of us tend to think in bidirectional relationships by default. Because domain‑driven design aims for simplicity in the model, we start recognizing more quickly that the bidirectional relationships can often make things overly complex. For instance, I’ve often found this to be true when it comes to adding in my persistence layer, and I happen to mostly use an ORM Entity Framework, which brings along its own behavior and assumptions about how relationships are managed. Sometimes the fact that my model includes navigation properties that may not be totally necessary can be the cause of some grief that’s led me to take some time to consider if I really need that navigation or not. ‑Domain‑driven design guides you to default to one way, or unidirectional relationships. That’s not to say that you shouldn’t ever have bidirectional relationships, but that because of the extra complexity involved, you should spend some time considering if that complexity is justified. ‑A relationship, also known as an association, should be part of a type’s definition, and we do that using properties that allow us to traverse from one end of the relationship to the other. In this example, we have a client type with a Patients property, and in a patient type, we have a Client property; not just an ID value, but a property that leads to a complete object or set of objects. If you introduce a bidirectional relationship, as shown in this code, using properties that let you traverse in both directions, you should only do so when neither object can be defined without the other. If that’s not the case, then you need to be specific about the direction of the relationship, also called the traversal direction, to keep your model design simple. ‑Eric Evans puts it this way, “A bidirectional association means that both objects can be understood only together. When application requirements do not call for traversal in both directions, adding a traversal direction reduces interdependence and simplifies the design.” ‑So with a DDDI, we can look at our model and ask, can we define a client without identifying their pets? Can we define a pet without identifying the client who’s responsible for them? ‑This may sound like a simple set of questions, but it could lead to a whole lot of debate. For example, why would a person be scheduling an appointment if they didn’t have a pet? So in the context of scheduling appointments, a client doesn’t make a whole lot of sense without one or more pets or patients. ‑Or from another perspective, a cat can’t pay a bill or call to make an appointment, so how can we define a pet without a client? These are both pretty reasonable arguments, but neither one gets us anywhere. ‑So, let’s start again with defaulting to a one‑way relationship. A client would need a patient to schedule an appointment. A client would not need a patient to pay a bill. ‑Okay, and if we started from the patient end, a patient doesn’t schedule an appointment, so that becomes a moot point. Nor does a patient pay the bill. And, you know, because my dog doesn’t have a credit card. He can’t use the phone very well, either. So, when would you start with a patient and need to know something about the client responsible for that patient? That’s an interesting question. So, in the context of scheduling an appointment, one could argue that we should define the traversal from client to patient and that we gain nothing by having a way to traverse from a patient back to a client. You may balk at that notion, but remember that all we care about right now is scheduling an appointment, not all the other possible scenarios where it might make sense to traverse from patient to client. ‑Sure. It’s another example of YAGNI, you’re not going to need it. In fact, we originally had owner as a property on patient in this context, but we realized it wasn’t necessary, so we removed it. However, we kept the ID because we had some scenarios where it was useful. ‑So in the end, we chose to define relationships that traverse from appointment to doctor, patient, and client, and to define one that traverses from client to patients or their pets, but not the other way. ‑You may have experienced another type of bidirectional relationship problem if you’ve seen related data gets serialized in your applications. When objects are serialized, the serializer typically traverses all of the object’s properties recursively, If there is a bidirectional relationship, it can create a loop that will cause serialization to fail. You can think of saving aggregates in much the same way, and in fact, depending on how your persistence layer is implemented, serialization may actually be required as part of how your app persists its aggregates. In our aggregates, the single direction that we would use would go from the root to its dependents, and never the other way around.\nHandling Relationships that Span Aggregates Aggregates serve as boundaries between logical groupings within our application. We enforce these boundaries by prohibiting direct references to objects within an aggregate that aren’t the root of the aggregate. Consider the customer with the address. It’s perfectly okay for customer to reference address. Address might be an entity, or it might be a value object; it doesn’t really matter in this scenario. What’s important, though, is that the only way to get to the address in this aggregate is through the customer. We won’t be referencing an address by some identity outside of this aggregate, but that’s not the case for customer. Since the customer is the aggregate root, it can be referenced from other aggregates. ‑In this common example, an order might reference a customer. Depending on our context, it might make sense for a customer to reference an order. In this case, let’s assume it only makes sense for the order to be central to the application’s design. What’s not okay is for the order to reference a customer’s address directly. This violates the integrity of the customer aggregate. ‑Remember that aggregates and aggregate roots only apply to objects, not data. And when we’re talking about references, we’re talking about object references, properties that use an object directly. This is especially important with ORMs. For example, if you were to save an address that had a customer object attached to the customer property, there are scenarios in which Entity Framework would involve the customer in the database INSERT or UPDATE, possibly even a DELETE. And this behavior leads to a lot of confusion. I frequently advise developers to just remove the navigation property and use the foreign key ID instead. It’s a little more work, but removing some of the ORM magic results in more control over the behavior. And this aligns perfectly with the fact that one common way to enforce aggregates is to replace direct navigation properties in the model’s non‑root types with key references, and this reduces the number of dependency relationships within the model.\nEvolving the Appointments Aggregate Since we’re dealing with appointment scheduling, our initial design might look something like this. An appointment involves bringing together a patient and a doctor in an exam room for a particular type of exam, and since we’ll typically need to know the owner’s information when we deal with the scheduling, it’s important to have a reference to the client from the patient also. So if we model our system this way, any time we saved an appointment, it’s going to scan all of these objects for changes and save them as well. So modeling it this way, the scope of our domain for appointment scheduling is much greater than it needs to be since, in our case, we don’t expect to modify any of the other objects when we’re creating an appointment. ‑Right, an appointment is basically just a list of resources tied to a particular timespan, it models who, what, when, and where, but it doesn’t ever need to change any of these associated concepts. As a result, we can simplify our design by eliminating most of these object relationships from the appointment classes designed. Recall that for an object to be a good candidate for being an aggregate root, it should be the case that deleting an object should also delete the other objects within the aggregate. In the design shown here, if a customer cancels an appointment and we delete it from the system, it doesn’t make sense that this should delete all of the associated objects. ‑So here is another perspective on that same model. By simply including the IDs of the related concepts rather than object references, we’re able to ensure that creating and changing appointments has a minimal impact on our system when we persist the appointment. This relationship works because an appointment in the real world is really just a note that includes a place, time, and additional details. Adding and removing appointments shouldn’t impact the people and places involved, and this revised design reflects this.\nUsing Invariants to Better Understand Our Aggregate We do still have a bit more learning to do with this model though. Somewhere in our design, we need to enforce certain invariants about appointments like that they shouldn’t be double booked. Our current thinking is that appointments need to include this rich behavior with regard to how they’re scheduled. It’s the aggregate roots responsibility to verify any invariance the aggregate may have, and in this case, the appointment is still acting as an aggregate root, even if we have eliminated the navigation properties to the other objects that it might be working with. Let’s make sure we’re clear on invariants and then we’ll see how invariants in our application impact our design. An example of an invariant in the real world is the speed of light, which is a constant that you just can’t break in terms of the physics of the universe as we know it. Some things in your system must be true in order for the model to be consistent or valid. Other examples of invariants might be that the total of the items on a purchase order do not exceed the PO amount, or that appointments do not overlap, or that an end date on an object must follow the begin date on that object. Sometimes an invariant only involves a single object, maybe a particular property or field such as name is required. In this case, we may model the system such that one can’t even create the object without the required information. Our value objects are like this. For example, you can’t create an instance of a datetime range object without defining both the start and end time. However, sometimes the invariants involved how multiple objects relate to one another. ‑In the example here, the purchase order and the individual line items would most likely be modeled as separate objects, however, the purchase order would be the aggregate root, and as such, it would be responsible for verifying this invariant. The individual line items on the purchase order probably don’t know anything about one another nor should they, so it wouldn’t make sense to put the responsibility for enforcing this invariant in the line item object. What about appointments? How does one appointment know whether it overlaps another?\nModeling Breakthroughs and Refactoring As we focused on these invariants and where they belong in our design, it became clear to us that the appointment didn’t really make sense as an aggregate root. If you apply this thinking to our appointment scheduling context, it follows that one appointment doesn’t really know anything about other appointments, but the schedule knows about such things. Let’s evolve our domain model to follow this pattern and see where that leads us. ‑This feels like a big change to the model, and these kind of epiphanies happen when you’re working on the model. But that’s not a bad thing. It’s not like you’ve wasted a lot of time focusing on appointment as an aggregate root. This is the beauty of modeling your domain, having conversations with different people, with the domain experts, because ideas like this bubble up, and suddenly, something big like this becomes clear. So, you’re not going to get it 100% right the first time. Your understanding will evolve as you learn more about the domain. And from time to time, you’ll realize there are big changes that can dramatically improve your design. In the Domain‑Driven Design book, Eric Evans talks about these breakthroughs in his section about refactoring toward deeper insight. This is really an important part of domain‑driven design, and about a quarter of the book is dedicated to it.\nRecognizing Signs of a Misidentified Aggregate Let’s take a look at the signs that Steve and I eventually recognized in our domain, which led us to shift our appointment aggregate to a schedule aggregate. ‑Originally, our solution had the appointment as the central focus of the design. I had figured it would be its own aggregate with appointment at the root and its various properties as its children. As we’ve just discussed, that doesn’t really work as well as I’d hoped, so now we’re refactoring the design to introduce a new type, the schedule. Before we show that, though, let’s review the original structure and some of the reasons it didn’t work as well as an aggregate in our solution. ‑You can see the original structure had appointment in its own folder and marked with the IAggregateRoot interface, which is required for it to be accessible from our repository methods. It has essentially the same properties as the later version, except for ScheduleId, since there’s no schedule type yet. And it has the same basic set of methods for modifying its room, doctor, time, and other properties. None of that really changed since all of those operations only had to deal with this single appointment instance. ‑However, when the appointment tried to enforce the invariant that appointments whose times overlap for the same pet should be marked as potentially conflicting, things were a bit messier. You see, this appointment doesn’t actually have any association with any other appointments, so the only way to enforce this is to use a repository to get those other appointments for the same date as this one. Since entities don’t support dependency injection through their constructor, this means an instance of the repository needs to be passed into this method. Creating this repository instance was the responsibility of the calling code, which may not otherwise have needed it. Note also that because the repository’s interface is async, this method must now be async as well, even though no other methods on the appointment entity are async. ‑The real problem here, from a DDD perspective, is that cross‑aggregate invariants should not be enforced by any one aggregate. In the case of something like a unique constraint between all aggregates, you might need to use a domain service, or another approach. However, in other cases, the need to do this may indicate that you’ve missed an important part of your model. ‑Right. In this case, the whole thing that the user is interacting with is the clinic schedule, but nothing in our original model referred to the schedule itself. Since some of our business rules, like what to do with appointments that conflict, only make sense at this higher level, it made sense to introduce a change to our model, the schedule aggregate.\nConsidering Schedule as Our New Aggregate So, even though the initial design we had was about scheduling, the schedule itself was never part of our model. Once we include schedule as its own explicit object in our model, it makes the design much simpler. Appointments no longer need to know anything about other appointments. The responsibility for ensuring that appointments are not double booked and similar invariants can be performed by the schedule, which is the aggregate root. ‑So, let’s see if this passes our other tests about defining aggregate roots. A schedule will certainly help us ensure that appointments don’t overlap one another. When we save changes to a schedule, does it make sense to update any changed appointments? Yes, it does make sense. And if we were to delete an entire schedule, would it make sense to delete all of its appointments? Yeah, I think that would make sense also. ‑Yeah, I think this is the schedule for a particular clinic. At the moment, we only have one clinic, but if we imagine a scenario in which multiple clinics each have their own schedule, it wouldn’t make sense to delete a clinic’s schedule but then keep its appointments floating around. So I think that works. ‑Great. And if a schedule exists for each clinic, then it makes sense to persist the schedule, which means that it needs an ID, and therefore is truly an entity. And when we retrieve a schedule, we’ll most likely be filtering which related appointments we want to look at, for example today’s schedule or this week’s schedule. That would mean we want all of today’s or all of this week’s appointments from a particular clinic’s schedule. It really does make a lot more sense to me to tie the appointments to a schedule than directly to a clinic. Now, let’s see how this effects our design.\nExploring the Schedule Aggregate in Our Application Now I’ll show you the new schedule aggregate implementation in our application. In the refactored solution, we’ve renamed the folder so that now it’s ScheduleAggregate. This folder only includes schedule and appointment, as well as related guards and specifications. In larger applications, it can help to organize your domain model by grouping everything related to a particular aggregate in its folder. Looking at the ScheduleAggregate’s code, you can see that it inherits from our common BaseEntity type and uses a GUID for its id key, just like appointment. This lets us set the key ourselves, rather than relying on a database to do it for us. The class is also marked as an aggregate root with an interface. In the next module, you’ll see how we use that to protect the integrity of our aggregates. ‑Right. We’ll see how that works when we look at our repository and specification implementations. ‑Next, the Schedule’s constructor just takes in its id, its dateRange, and its associated clinicId. In our sample, the clinicId is always hard‑coded but in a real application, there might be several clinics using the same software, and they would each have their own ids. The constructor is responsible for ensuring that the incoming values are valid so that it’s always created in a consistent state. Schedule has just a few properties. There is the ClinicId, the associated set of appointments, and the DateRange. We’re careful to only expose a read‑only IEnumerable of appointments because our aggregate must encapsulate its internal state. We don’t want other parts of our application to add or delete appointments without going through the schedule’s explicit methods designed for this purpose. Also, the date range isn’t persisted since it can vary with any given instantiate ation of the schedule. ‑Yeah, and for performance reasons, you wouldn’t really want to load the ScheduleAggregate with every appointment that had ever been made included in it. By using a property like this, we make it clear to the rest of the domain what set of dates this instance of the aggregate holds. The actual population of the appointments that match this range is left as a responsibility of the specification and repository classes that are used to retrieve the schedule from the database. ‑Yes. And the configuration of the aggregate’s persistent details is done in the infrastructure project’s Data Config folder. This is where every entity’s EF Core‑specific mappings and configuration is performed, which keeps these details out of our domain model. You can see here that we’re also letting EF Core know that we don’t want the database to supply an id when we create a new schedule. We’ve marked that property as ValueGeneratedNever. ‑Getting back to the schedule, let’s have a look at its methods. The first method is for adding new appointments. Our design forces all new appointments to come through this method, so we don’t have to have duplicate behavior anywhere else in the application to take care of whatever should happen when a new appointment is added. It’s all right here in one place, easy to understand, and easy to test. The method validates the inputs to ensure we’re not adding bad data to our aggregate, and then it adds the appointment. When a new appointment is added, the schedule is responsible for marking any appointments that might be conflicting. It’s the right place for this behavior to live, since the schedule knows about all the appointments and knows anytime appointments are added or removed. After marking any conflicts, an appointmentScheduledEvent is added to the aggregate’s event collection. We’ll see how this works in the module on domain events. The DeleteAppointment method is similar. After deleting an appointment, the schedule needs to once more mark any appointments that might be conflicting. There’s also a TODO comment here. These are left as exercises for you to learn more about how to work with the patterns introduced in this course. You’ll find a number of TODO exercises scattered throughout the sample. ‑We hope you’ll take some time to download the code, run it locally, and try implementing some of the TODO tasks using the existing functionality as a guide. There are a couple more in the MarkConflictingAppointments method, which, remember, was originally on the appointment type when we started out with that as its own aggregate. This method is responsible for detecting and marking appointments that might conflict. The basic rule, shown here, just checks whether the patient has two appointments that overlap. If any such appointments are found, they are updated to set their conflicting property to true. Then, the current appointment’s property is set based on whether there are any other appointments that conflict with it. ‑This is an important part of the business logic for this application, and it’s encapsulated right in our schedule aggregate. In a lot of data‑driven applications, this kind of logic might be in a stored procedure, or perhaps just implemented in the user interface. But in a domain‑driven application, we want these rules to be explicit and defined in our domain model. ‑The last method on schedule provides a hook for its appointments to use to notify it when changes are made to one of them. Because we don’t have navigation properties from appointment back to schedule, we can’t directly call methods on the aggregate root from appointment methods. There are a few different patterns we can use to accomplish this task. For this sample, we chose this one because it’s simple and easy to follow. This handler simply calls MarkConflictingAppointments, but it’s exposed as its own separate method because it could do other things as well, and we don’t want to expose the internal behavior of the schedule to the rest of the app. To see how it’s used, let’s look at the appointment class’s UpdateStartTime method. When the application needs to update the start time for an appointment, it will call this method. Because appointment is part of a scheduling aggregate, we know the app will already have loaded the schedule before calling this method. So the second parameter in the method asks for the handler on the schedule that will be called. The call to update the schedule is made after updating the TimeRange property on the appointment, so when mark conflicting appointments is called, it will use the new value for the time range. There are a lot of other ways you can set up this communication, using C# events, static domain events, or some kind of double dispatch approach. They all have trade‑offs, and when you need to do this in your apps, you should choose the one that works best for your app and your team. ‑Let’s see the final result in the application. This change to our model of adding in a schedule aggregate made a big difference to how the domain model is organized. It gave us a much better place to put the logic of enforcing business rules around combinations of appointments and business logic that needs to run when appointments are added or removed. ‑Right. Without the schedule, we would have had to use a domain service or something to add behavior around the newly added or removed appointments. But with this design, we can go into the schedule, add a new appointment for Rosie, and then add another one, and you can see the notifications being triggered by the events, as well as the red outline representing the conflict in these two appointments. Not only is our domain model clean and easy to test, but even more important, it actually works! ‑And notice that as we move one of those conflicting appointments to another spot, the red alerts disappear. Good job, Steve! I am so grateful that you let me off the hook for working on the front‑end of this application. You know I’m more of a back‑end developer.\nSharing Our Tips for Aggregate Design So let’s step back a moment and review some of the things we’ve just learned about designing aggregates. First of all, aggregates exist to reduce complexity. You might not always need an aggregate. Don’t add complexity just for the sake of using an aggregate. Another is that entities with an aggregate can only reference the root entity of another aggregate. ‑But you can always use foreign key values as a reference to entities inside another aggregate. It’s perfectly okay to use this, and it will avoid the need for when you go to save that aggregate for it to cascade its persistence into other aggregates. If you find you’re needing to use a lot of foreign key references to aggregate children often, you may need to reconsider the design of your aggregate in your domain model. ‑Another pointer was don’t be afraid to have an aggregate of one, in other words, an aggregate that only has one object in it. ‑And finally, don’t forget the rule of cascading deletes. Remember, one test for whether or not a particular object makes sense as an aggregate root is to consider whether deleting that object should also delete all of the other child objects in that object’s hierarchy. If it doesn’t, then you have probably chosen the wrong structure for your aggregate.\nReview and Resources Once again, we have covered quite a bit in this module. Let’s review some of the terms that you learned in this video. The first thing we talked about was an aggregate. An aggregate is a group of related objects that work together in a transaction. The root becomes the entry point through which you do any work with the aggregate, and the root also is what’s in charge of making sure that all of the rules that apply to that graph of objects are met. ‑Each of the rules that describes the state that the system must be in in order to be valid is called an invariant. Within our aggregates, we have objects that are related to one another. In DDD, we refer to these relationships as associations. If you use an ORM, you may hear the term navigation properties, which refers to those properties that reference the related objects in the model. And we talked about the importance of defaulting to one‑way relationships, which we also refer to as unidirectional relationships. ‑In addition to these important terms, Steve and I shared a lot of guidance around creating aggregates and roots in your domain models. Nobody wants to work with a big ball of mud. We use aggregates to organize our model. An aggregate is a set of related objects that live in a single transaction while encapsulating the rules and enforcing invariance of that transaction, making sure that the system is in a consistent state. When designing how related objects work together, your job will be easier with one‑way relationships. Use those as a default, and only introduce bidirectional navigation if you really need to. ‑And most importantly, don’t resist updating your model as you and your team of domain experts learn more about the domain. Hopefully, most of this will happen early on, and then just once in a while you might have a big breakthrough, like we did when we realized that the schedule made more sense as an aggregate root than trying to have each appointment be its own aggregate. Up next, you’ll learn about repositories which are a critical pattern in domain‑driven design. This is Steve Smith, ‑and I’m Julie Lerman. Thanks for watching Domain‑Driven Design Fundamentals.\nWorking with Repositories Introduction and Overview ‑Hello. I’m Julie Lerman. ‑And this is Steve Smith. ‑In this module of Domain‑Driven Design Fundamentals, you’ll learn about repositories, another critical pattern for Domain‑Driven Design. ‑We’ll start by defining what repositories are, and then we’ll provide some tips for working with them, as well as talking about some of their benefits. There are different ways to define repositories and plenty of debate around their use. We’ll address some of these points. ‑Next, we’ll introduce you to the specification pattern and how it can be really helpful when you’re implementing repositories. Then we’ll open up Visual Studio again and show you how we’ve implemented some repositories in the scheduling app.\nIntroducing Repositories ‑Now, Julie, if this were an in‑person class, I’d definitely ask for a show of hands who has heard of the repository design pattern. I would expect most hands to go up. ‑I hope so too. I think the repository pattern is by far the most popular element of DDD to be practiced outside of Domain‑Driven Design. They can be valuable in so many applications as a way to simplify data access and enforce separation of concerns. When I began learning about repositories and implementing them in my own software design, it had a huge impact on my application architecture. Along with automated testing practices, it really forced me to consider separation of concerns with each method and behavior added to my software. ‑Personally, I love the pattern, and I find it makes it much easier for me to write good, testable code. We’re going to talk about using repositories within a DDD application, but if you want to learn more about the pattern itself, you can look in the design patterns library, and I know Julie also discusses using them with Entity Framework in her Entity Framework in the Enterprise course. ‑You can see the repositories are part of the DDD mind map, as they’re used to access entities and aggregates. Any system that needs to persist between restarts has some kind of persistent storage for the state of the system, like a database. Many applications focus a great deal of effort on the mechanics of querying, fetching, and translating data to and from objects to the point where it distracts from the model that these objects are meant to represent. And having ad hoc access to the data source also promotes having developers query for any bit of data they want anytime they want, rather than using aggregates. This makes it pretty difficult to manage the consistency of aggregates by enforcing their invariants. At best, the logic for enforcing the integrity of the model becomes scattered among many queries, and at worst, it’s not done at all. ‑Applying Model‑First design and separation of concerns means pushing persistence behavior into its own set of abstractions, which we refer to as repositories. Only certain objects, like specifically aggregate roots, should be available via global requests. Repositories provide this access, and through omission, prevent access to non‑aggregate objects, except through their aggregate roots. They give you the ability to constrain the data access, so you avoid lots of random data access code throughout your application. ‑When you think about the life cycle of an object in your application, you should consider two cases. In the first case, you have objects that are not persisted. These objects are created, perform some work, and then they’re destroyed. In the second case, you have objects that are persisted. These objects have a slightly more involved lifecycle since after the object is created, it must be reconstituted with whatever state it had when it was last saved. Then it can perform whatever work the application needs it to do, after which it may need to save its state to some persistent storage before finally being destroyed. You can use repositories to manage the lifecycle of your persistent objects without the objects having to know anything about their persistence. We call these objects persistence ignorant because they’re ignorant of how they’re stored into and retrieve from a data store. ‑In his book, Domain‑Driven Design, Eric Evans speaks quite a bit about repositories. They can be summed up by saying that a repository represents all objects of a certain type as a conceptual set, like a collection with more elaborate querying capability.\nRepository Benefits ‑Repositories can add a number of benefits to our application. First of all, they provide a common abstraction for all of our persistence concerns, which provides a means for clients to very simply obtain model objects and to manage their lifecycle. They also promote separation of concerns. The domain logic and the user interface can both vary independently from the data in the back‑end data source that is used by the application. ‑The public interface of a repository very clearly communicates our design decisions. Only certain objects should be accessed directly, so repositories provide and control this access. Another important benefit is that repositories make it easier to test our code. They reduce tight coupling to external resources like database, which would normally make unit testing difficult. Having a repository separate from client code and domain logic means that we can easily make improvements to optimize data access for this application, tuning for performance, adding caching behavior, etc. is all much easier and safer when the code for data access is all encapsulated in one or more well‑known classes. All of this makes your code easier to maintain.\nRepository Tips ‑Here’s some basic guidance you should keep in mind when designing repositories. First, a repository should have the illusion of a collection of a specific type of object. You’ll be adding the objects to the collection, removing them, and retrieving objects from the collection, but that it is an illusion of a collection is important to keep in mind. When you interact with the repository, these are the types of methods you’ll be calling, add, remove, and retrieve. Your calling code doesn’t care how the repository performs those actions. So in the repository, you might have code that responds to a retrieve method, goes out to a database and gets data, but it could be getting data that’s already in memory, or it might be grabbing data from a text file on your computer. ‑Another important recommendation for repositories is to set up access through a well‑known global interface. That way, developers that need to interact with the repository will be familiar with a common pattern for using it. ‑Here’s a simple repository interface example. Depending on the size and complexity of your software, you may have a few layers of interfaces. ‑For example, if you anticipate having a number of repositories for a schedule aggregate used in different bounded contexts, you might want an IScheduleRepository interface that not only implements the lower‑level interface, but defines some other methods or properties that every schedule repository is required to have regardless of the bounded context it might reside in. Because a repository acts like a collection, you’ll want methods to add and remove objects to encapsulate the underlying data insertion and deletion operations. We’ve got these defined in our IRepository. It is up to each concrete implementation to define how add and remove will actually work. ‑It’s not unusual to need to add specific query methods to individual repositories. Whether you need a custom subset of entities or a specific way to load entities’ relationships, custom methods are a simple way to achieve this. For example, if we wanted to fetch a schedule instance with all the appointments for a given day, we could add a method to the ScheduleRepository that might have an EF Core implementation like this one. ‑Likewise, if we just wanted to be able to fetch a client with their patients, we could add a method like this one, which will eager load the patients when it loads the client. Be careful with this approach though, as it can grow out of hand, and your repositories may end up with many different query methods. A simple way to address this is to use specifications instead, which we’ll cover later in this module. In addition to these specific tips for implementing repositories, you should also keep in mind these more overarching tips. First, be sure to provide repositories only for aggregate roots that require direct access. And next, keep the clients focused on the model, while delegating all of the object storage and access concerns to the repositories.\nAvoiding Repository Blunders We’re not always going to land on the happy path, so we do want to share with you some common problems that you might run into, how to recognize them, and most importantly, how to avoid them. ‑Remember your client code can be ignorant of the implementation of your repositories, ‑but developers cannot. ‑It’s important that developers understand how your specific repository is implemented, otherwise, they can run into a number of different problems. ‑So we’re talking about not just the developers who are implementing the repository, but also the developers who are using the repository. ‑One of the common repository problems the developers working with repositories often encounter is called an N+1 query error. This is where in order to display a list of rows from the database, you end up calling one query to get the list and then a number of queries equal to the count of that list to fetch each item individually. ‑Another one that I see a lot is when people are fetching related data. With Entity Framework, they’re either using eager loading or lazy loading, and especially with lazy loading, there are a lot of developers who don’t really know what to expect from it and just because it’s easy and it just works, they use it and then run into all kinds of problems because of it. ‑And depending on how your data is structured, sometimes if you’re trying to fetch just one or two properties that are represented in a particular column in a data table, you might end up fetching more data than required if you pull back the entire row which might include dozens of columns and a lot of actual data there. These are things that knowing how your underlying data is persisted and how your repository is implemented, how those things work, can make a huge difference in your application. ‑Most of these blunders impact how data is accessed in a data store and that means that one of the best tools you have for surfacing these problems is profiling your data store. Many of the IDEs we use for managing databases have profilers built in, some examples are SQL Server Profiler, Jetbrains DataGrip, and Azure Data Studio. Many of the APIs we use also have logging capabilities that can relate database activity. As a .NET developer, I often use the .NET Core logging API or some of the features built into Entity Framework Core, but most any language you use can do this and all of the cloud providers have ways to trace activity in their various data stores. There are even third‑party tools dedicated to database profiling. The suite of profilers from Hibernating Rhinos is a great example. They have profilers for RavenDB, Azure CosmosDB, and the EF Core, and Hibernate ORMs.\nAddressing the Debates Around Using Repositories Many developers have strong opinions about the use, and some might say overuse, of the repository design pattern. Let’s consider some of the common arguments made about repositories. It’s worth remembering that like Bjarne Stroustrup’s famous quote about programming languages, there are two kinds of design patterns, too. It’s no surprise, really, that as the repository pattern grew in popularity, that there would be many complaints about when and how to implement it. ‑Here’s one that really gets me. EF Core, the .NET ORM which we’re using this course, has a built‑in repository for its data access. It’s called the DbContext. I’ve heard and read comments from so many people who say never use a repository on top of EF Core because it already has a repository built in. And then I hear others who say you should always use a repository to interact with EF Core. I am not a fan of the words always and never. Maybe it’s because I’m a libra, who knows. So, these strongly held opinions really frustrate me. What Steve and I want to do here is give you the information you need so that you can make educated decisions about when to use repository and when to opt for something else. ‑Let’s remember for a moment what repositories are and where they live in a domain‑driven application. Repositories are abstractions. They’re part of your domain model. They define the persistence operations the model will use. That’s it. There’s nothing in the domain model patterns produced through model‑driven design espousing the use of Entity Framework, or NHibernate, or any other specific vendor tool for doing persistence. It doesn’t even know if you’re doing Java or .NET. It’s meant to be totally abstract and just types. ‑The domain model should be persistence ignorant, and it shouldn’t depend on implementation details. ‑Right. One of the things I really appreciate about DDD and the way it isolates domain expressions within a layered architecture is that it aligns perfectly with SOLID design principles, like the dependency inversion principle. ‑You are a big fan of SOLID, Steve. ‑Guilty! In this case, in terms of SOLID, using an abstraction for persistence enables us to follow dependency inversion because we can define an abstraction in our domain model and then implement it in another project that depends on the domain model. We can also write our application and its user interface so that it depends on our persistence abstraction, too, rather than on the implementation details. That’s the heart of dependency inversion. ‑And that makes it easier to follow the interface segregation principle, which I also learned about from your SOLID course. This principle prefers smaller interfaces, so if your app is using a DbContext directly, that is not a small interface. Along with DbContext repository features, it exposes a lot of other functionality. Using an abstraction that limits what your app needs to do with regard to persistence makes for a much simpler design in our model, reducing complexity. ‑Right. In that way, it’s similar to the facade pattern because it lets us work with a much simpler view of what could otherwise be a potentially very complex and powerful persistence library. ‑So, when we’re following DDD, our domain model shouldn’t know anything about EF Core, or whatever APIs you’re using for your data persistence. If our model requires persistence, like most do, we should define abstractions in the model that describe what our needs are without specifying how they’re done. ‑Exactly. The abstraction defines what needs done, the specific implementation is all about how to do it. ‑And one really popular and powerful way to do persistence in .NET is with Entity Framework Core. And because it implements methods that map pretty closely to most common persistence abstractions, it’s usually pretty easy to implement a particular abstraction with a class that calls into EF Core. ‑Definitely. ‑EF Core works great for this in most of the apps I work on, but we should never couple it tightly to our domain model. ‑Exactly. The whole point of DDD is that we shouldn’t be coupling our domain problems with our persistence problems.\nReturning IQueryables: Pros and Cons Another question I get all the time, and which I’ve discussed in some of my other Entity Framework courses, is whether repositories should return IQueryable, and yes, I do have my opinions on that. ‑Yes, this is another source of some debate. On the face of it, it sounds like it would be a great idea. Your most basic repository abstraction might not provide much in the way of complex filtering options and you can avoid having to think about that sort of thing if you just return an IQueryable. ‑Right, because then any code that consumes an IQueryable can extend the expression adding additional filters or projections to the query before it’s actually executed. On the surface, it sounds pretty good, right? ‑Well, it turns out that a lot of query logic is actually business logic, and if you return an IQueryable, it has two not‑so‑good effects. It can leak a lot of the implementation details so your application code’s behavior changes significantly based on the implementation of the repository and it tends to put the business rules for querying all over the application. ‑Let’s say we have an MVC application with a controller so that’s the server‑side logic of the UI layer and it returns a view to the UI. The controller calls into a service to get its list of customers and the service contains a customer repository interface. That repository calls into an infrastructure project and the infrastructure project is where we’re using EF Core and it’s DBContext, but to limit what’s exposed outside of the infrastructure project, there is a repository there as well. The repository and the service makes its calls to the repository in the infrastructure layer. It sounds like a lot of layers, but that’s not a problem because we have reduced coupling and made a maintainable solution. The real problem here is where can we put our query logic in this example? ‑Well obviously the repository, and it wouldn’t be unusual for the method in the service to further modify the query, but since it’s also returning an IQueryable, the controller action could further modify that same expression tree, and assuming the controller just passes that same IQueryable to the view, which we’ve both seen teams do, even the view could further refine the query. So is this a good thing or a bad thing? ‑Well on the plus side, we get a lot of flexibility without having to write a lot of code for our repository. We’re also able to tailor the data we need to the specific place it’s used and even modify the query from multiple steps in the app. At the same time, we get to reuse a simple repository interface everywhere in our app. ‑Right, but on the other hand, that query logic is now spread out everywhere. Every class that’s adding query logic, in addition to whatever else it’s doing, is now violating the single responsibility principle. Then there is separation of concerns. Query logic should be separate from other concerns in most of these classes. ‑And another problem I see a lot with this approach is confusion about when the actual query is executed and what runs on the database server versus in‑memory in the application. ‑Many developers will assume the query runs inside the repository and the result they get back is from the data store. And of course that’s true for most calls, but not necessarily for those that return IQueryable. ‑Right, the query will execute the first time any code tries to enumerate the result. That could happen inside the repository, but it could also happen in the service, or in the controller, or even in the view. ‑Yeah, I see that a lot. a related issue is that developers at any step of this process can add additional logic that may compile just fine, but then at runtime when EF tries to interpret it, it blows up. ‑Anything you add to the query expression that Entity Framework doesn’t know how to translate into SQL is likely to cause an exception, at least with recent versions of EF Core. ‑And it may be redundant at this point, but it’s probably worth adding here that there is no encapsulation when you use this approach. ‑There is a way we can fix at least some of these issues though. For example, instead of returning IQueryable, we can still create flexible repository methods by passing in predicates. Then in the implementation, this predicate can be passed along to the DBContext as its Where expression providing the necessary filter. If you’re not familiar with the term predicate, but you’ve used the link where method, that’s what the method takes as its parameter, which is why we’re able to pass it right to the WHERE clause. ‑That does help part of the problem. Where before the query could have been executed at any of these points, at least now we know that whatever comes back from the repository will be the in‑memory result. The actual query is always executed in the repository itself. Of course, if the service takes in a predicate, it still means that any code anywhere in the system could be responsible for creating the query logic with the possible exception of the view if it’s just being passed an IEnumerable at this point. ‑Okay, so with predicates, they’re still very flexible, but they’re not as easy to build up from multiple locations in your application, especially compared to IQueryable. The rest of the good points still hold though. ‑The only thing we’ve really changed on the bad side is confusion about when the query actually executes. Being a fan of solid and encapsulation and knowing some other patterns we’ll share later in this module, I’m usually going to vote against this approach too. ‑Well another way we tend to solve this conundrum is going the custom query route. We even suggested this as a tip earlier, but you can definitely take it too far. Every little change to a query means another method, customer with orders, customers by shoe size, by shoe size, customers by favorite Netflix show. Hey, you never know what problems your domain experts are going to share with you. ‑The problem with this approach if it goes beyond one or two methods, is that you really start to feel the pain of the open/closed principle violation. Every time another custom query requirement comes in, you have to change the repository abstraction and all of its implementations, and the bigger the type gets, the more it violates the interface segregation principle, too. The more complex your problem is, the more query methods you’ll be adding to your solution. This can surely be an untenable situation, and we will show you some better alternatives a little later in this module.\nConsidering Generic Repositories and Interfaces Using generic interfaces for persistence is great from a code‑reuse point of view. With just one simple interface, any entity can be persisted using a standard set of operations. If you’re using aggregates, you can use generic constraints in this simple marker interface to ensure that only aggregate roots can be persisted using your interface. It can work really well. ‑But there are trade‑offs. What if you have certain aggregates that should never be deleted, but your generic repository includes a delete method? Does it make sense to have operations defined in your domain model that should never be used? This is where you need to make a judgment call. Is the convenience of having a single consistent way of dealing with persistence throughout your model more valuable than having only the necessary and appropriate persistence operations exposed? There’s no one right answer. Pick what makes sense for your app, your model, and your team. ‑In our demo, partially for the sake of simplicity, we are using a single generic repository for all of our operations, even though, yes, this means there are operations on some aggregates that are never called and some that never should be called, for example, deleting the entire schedule. ‑If we didn’t go that route, our model would need to include separate repository interfaces for each of the aggregates in our model, including schedule, doctor, room, client, and appointment type. Each would define only the operations that were actually needed by the application. For a larger model, this could result in quite a few interfaces, and possibly implementations, but would provide a more pure representation of the domain model. ‑If you do choose to create a generic repository interface, that doesn’t necessarily mean you’ll implement it generically. You might only choose to create implementations for each aggregate root, which would comply with DDD recommendations. However, it can be convenient to create a generic Repository of T implementation class that you can then use with any entity. ‑This is what we’re using in our sample, both for the front desk app and for the clinic management app. In both cases, if you review the sample, you’ll see there’s very little persistence‑specific code in either solution. ‑If you really like the code reuse you get from having a generic repository implementation, one way to keep it from allowing too much access to the internals of your aggregates would be to use a marker interface, perhaps one that simply extends the entity interface to identify your aggregate roots. Then you can update your generic repository to require this interface, rather than working with any entity. ‑At that point, code that uses the repository won’t be able to instantiate the generic repository with non‑root entities, so we’re able to use our repository to restrict access to non‑root entities from client‑server model. Using marker interfaces to identify aggregate roots is one way you can enforce your design decisions in your model using the compiler rather than relying on code reviews or other less effective practices. ‑Repository abstractions, especially generic ones, can sometimes get to be pretty large. Large interfaces violate the interface segregation principle, one of the solid principles that I cover in my Solid Principles for C# Developers course. One way to keep these interfaces smaller and more focused is to split them into read and write operations. This is related to the concept of Command Query Responsibility Segregation, or CQRS. Read operations are queries, write operations are commands. There are many benefits to leveraging CQRS that we don’t have time to cover in this course, but one area where you may immediately benefit is with modifying behavior related to these kinds of operations. Queries often benefit from data caching, and it’s very easy to add data caching to just the read operations. ‑Commands often benefit from being performed asynchronously using a queue, and having a separate interface for commands makes it easy to implement this behavior. These are just two ways you can quickly leverage splitting up your repository definitions between reads and writes. Of course, if you have a lot of different read methods, this can make it more and more difficult to implement custom caching logic, since every new method will also need to be added to the caching layer. Fortunately, this is easily solved by using the specification pattern.\nExploring Repositories in our Application Steve is going to give you a guided tour of how data access and persistence are handled in the FrontDesk application using repository abstractions. Because he’s been fine tuning versions of this demo application for many years, it’s quite impressive, and he truly is the best guide for walking you through this implementation. ‑We’ll start from the front end of the application, which is our Blazor client. Let’s take a look at editing an appointment. Here’s an appointment for Julie’s dog, Samson. You can see that on the edit screen, in addition to showing the details for the appointment, it also provides us with a list of the doctors and appointment types. When we hit the drop‑down list, we can see all of the different doctors who are available that we could schedule to work with this particular appointment. That’s actually accomplished through a back end API that’s coming from a different project. Let’s take a look at that. We’ll start by examining the API using our Swagger endpoint. Looking at Swagger for DoctorEndpoints, you can see that there are two endpoints, one to get a specific doctor by ID and another one that returns a list of doctors. We just saw the list of doctors in action. Let’s go ahead and run it again from Swagger. Here you can see the resulting set of three doctors, just like we saw in the drop‑down list. You’ll find the code for this particular endpoint inside the FrontDesk.Api project. Within there, there’s an Endpoints folder with subfolders for each of the different types of entities that we expose API endpoints for. Inside of Doctor, you can see there’s a GetById and a List, and we’re looking at the List endpoint here. When we define an endpoint, we simply inherit from BaseAsyncEndpoint, and specify the request type, if any, and the response type, if any. We can also do dependency injection through the constructor, just as you would with a controller. Each endpoint has a single Handle or HandleAsync method, and this is where the actual work of the endpoint is done. You can see in this example that we are simply awaiting on the repository’s ListAsync method in order to get our list of doctors. Once we have the list, we map it to our DTO that we’re going to actually return, and pass that back as part of that response type. The response, as we just saw in Swagger, includes the Doctors as JSON, as well as a Count property that includes the total number of those doctors. Now let’s look a little bit more closely at that repository. You can see in the dependency injection that’s occurring in the constructor that we’re depending on an IReadRepository, but where is that defined? For that, we need to look at our SharedKernel project. Inside the separate SharedKernel project, which FrontDesk references as a NuGet package, you can see that we have defined an IReadRepository interface. This inherits from IReadRepositoryBase, which is actually itself defined in another NuGet package, the Ardalis.Specification type. The reason why we’re creating our own interface here is so that we have complete control over it and we can add additional behavior. For example, in this case we’re adding a generic constraint. We’ve said that this particular interface will only work with types that have the IAggregateRoot interface attached to them or applied to them. Looking at that particular interface, you can see that there’s nothing to it. It’s simply a marker. It’s a way that we tell the compiler that our intent for a particular class or entity is that it should be treated as an aggregate root. We use that marker to enforce our design and our encapsulation to make it so that we don’t accidentally just load up a child entity out of an aggregate, when instead we’ve made a design choice that we want to work with that entire aggregate as a unit. You can see that we’ve also implemented IRepository similarly. It also inherits from a type that comes from Ardalis.Specification, and also has the same IAggregateRoot restriction. Now let’s return to our FrontDesk application and see how we implement this. First, we should look at the DefaultInfrastructureModule. This is an artifact module that defines how we’re going to wire up our abstractions with their implementations. And here you can see all the important bits of how we wire up EfRepository to IRepository, as well as IReadRepository. But notice for the IReadRepository we’re actually wiring up a different type, a CachedRepository. This acts as a decorator around the underlying EfRepository, and will provide additional caching logic. Inside of the CachedRepository, when we asked for a list of doctors, it actually checked the cache first, and then if it wasn’t in the cache, it would go and fetch the result from the EfRepository, which in turn would make the request to the database. We can see in this example here that the logging is showing us that we’re actually hitting CachedRepository, and some of the times we’re fetching the source data and other times were fetching the data from the cache. The actual EfRepository that is also defined inside of FrontDesk.Infrastructure is shown here, and once more, you can see that there’s not much to it. Most of the behavior we’re simply inheriting from the EfRepository that exists in the Ardalis.Specification package. It’s called RepositoryBase. However, when we inherited it, we were able to add additional constraints, and so you’ll see here as well that we specify that this only works with IAggregateRoot. You can see the definition of the RepositoryBase in the Ardalis.Specification NuGet package, which is available on GitHub. The details of it are shown here. The ListAsync method simply delegates to dbContext.Set of the appropriate T type, and then calls its ToListAsync, passing along a cancellationToken if one was provided. Now the last piece of the puzzle is our own AppDbContext. Inside our AppDbContext, we define the DB sets that we’re working with and we also pass in some additional configuration. One thing to notice and take away from this example is how many places in our solution we have to reference AppDbContext or EntityFramework. It’s almost nowhere in the entire code base. The only place that we talk about it at all is inside of AppDbContext, EfRepository, and some related folders such as Configuration and Migrations. Everywhere else, and especially in our domain model, we’re completely persistence ignorant, relying only on abstractions that we’ve defined.\nIntroducing the Specification Pattern Eric Evans introduces the specification pattern in the original book on domain‑driven design. Although it’s covered in Evans’s DDD blue book, the specification pattern isn’t listed in the book’s mind map, and honestly, it doesn’t get the attention it deserves. Factories are in the book’s mind map, but specifications aren’t? Even though in my experience they play a much larger role in producing a clean domain model design. ‑In the book, Evans says that specifications mesh smoothly with repositories, which are the building‑block mechanisms for providing query access to domain objects and encapsulating the interface to the database. It’s this powerful combination of specification and repository patterns that truly result in a clean, extensible, and testable design. Let’s dig a little more into the specification pattern and how it integrates with repositories before we show you how we’ve implemented it in the front desk application. ‑Specifications are used to specify the state of an object, and as such, are primarily used in three ways, validation, selection and querying, and creation for a specific purpose. In our app, we are primarily leveraging specifications in our queries. Create explicit predicate‑like value objects for specialized purposes. A specification is a predicate that determines if an object satisfies some criteria, according to Eric Evans. The most basic specification simply provides a method typically named IsSatisfiedBy, which accepts some object and returns a Boolean. These methods perform their logic in memory, and unfortunately, in remote data querying scenarios, this approach would require every row to be transferred to the application before the specification logic could be run against it. ‑However, more sophisticated specifications can be used in conjunction with ORMs like Entity Framework Core to encapsulate the details of a query while still allowing EF Core to translate the query into SQL that executes on the database server. Our sample application uses such a specification in the form of a NuGet package, ardalis.specification, which is maintained by, guess who, Steve Smith. ‑Recall that one of the benefits of using the repository pattern and abstraction was that it prevented query logic from being spread throughout the application. This was also the reason for not returning IQueryable from repository methods. The same logic can be applied to repositories that accept arbitrary predicates since, again, that means the complexity of these predicates would need to live in the code calling the repository, which might be in the user interface for example. Using repository interfaces that accept specifications instead of custom predicates addresses this problem very elegantly. ‑What about the issue we learned about earlier in this module where generic repositories weren’t suited to aggregates with custom query needs? So, individually typed repository interfaces were required, and each additional custom query needed to be added to this new specific interface. Well, specifications solves that problem too. Generic methods accepting generic specifications allows for custom queries where needed for any given aggregate. ‑A few more benefits of specifications. They’re named classes that live in your domain model. You can easily unit test them in isolation, or if necessary, integration test them with a test database. They’re highly reusable. They keep persistence logic out of your domain and your user interface. They keep business logic out of your database and persistence layer. They help your entities and aggregates follow the single responsibility principle by keeping complex filtering or validation logic out of them. You can easily create your own specification interface and implementation. Feel free to look at the source for ardalis.specification on GitHub and take just the bits you find useful. Or, you can reference that package and leverage all of its features and just start adding the specifications that your domain needs. It’s up to you. Either way, you will need to write the specifications themselves. These belong in your domain model. When you don’t have many of them, you might just put them in a root specifications folder. However, as your model grows, if you’re using aggregates, it may make sense to have each aggregate include in its own folder the specifications that go with it. This makes them easy to locate as they grow in number. ‑Each specification class is a value object, so it should be immutable. Generally, they do all of their work in their constructor. Any variable part of the specification should be supplied as a constructor argument. And once constructed, the specification needs to be supplied to your query implementation. You can use specifications directly with EF Core or you can use a repository abstraction that supports them. In either case, pass the specification to the query object and it will be used to build the query, which is then executed and results are returned. The resulting code for most queries turns into one line to create the specification and another line to execute the query by passing the specification to a repository or a DbContext method. Note that our sample is built on top of a repository abstraction that’s provided with the ArdalisSpecification package, and so it’s fully compatible with its specification types. We’ll look at the code more in the next section. ‑Here’s an updated mind map that I have created which shows how specifications work with repositories to define the queries for aggregates and entities. If you’ve been using repositories without specifications and have experienced any of the pain points we’ve described in this module, try refactoring to use specifications and I’ll bet you’ll be surprised what a positive difference it makes.\nUsing Specifications with Repositories in Our App Now it’s time to see just how specifications are implemented in the sample app. While the application code does lean on Steve’s specification API, there is still plenty to see. Most of what you’ll see here is the application’s code, but occasionally you’ll also see some of the code that’s in the Ardalis.Specification API. Once again, Steve is going to walk you through this demo, and he’ll do so from the perspective of how the app retrieves data, starting with the front‑end. ‑When we first load the schedule page in the FrontDesk app, it loads our Blazor WebAssembly application, which then makes some API calls to fetch the appointments and related data. One of those calls is shown here. It’s used to get the list of appointments for the schedule. Looking at Swagger, we can see there are a bunch of appointment endpoints. Our API is designed to serve the needs of the client app. Its endpoints won’t necessarily match up with how our domain model is constructed, so it’s perfectly fine to have an endpoint for appointments, even though appointment is not an aggregate root. It just means we need to pass in the aggregate root ID as part of the request so that we can get the schedule that owns the appointments. If we test the list AppointmentsEndpoint, we can pass in the same schedule ID that Blazor was using, and we get back a list of appointments as expected, and these are, in fact, the same appointments that are being used in the front end. Looking at the source code for this endpoint, you can see that, again, it’s in the API project in the Endpoints folder in an Appointment folder, and within that, we’re looking at the List endpoint. Now, when we pass in the request, we’re specifying a ScheduleId, and if that ScheduleId is missing or empty, then we’re going to return NotFound from this API. Otherwise, it uses the ScheduleByIdWithAppointmentSpec to encapsulate the query that it’s going to use. On the page in question, we only want the appointments for one day. It’s worth noting that this specification does not perform any filtering by date; it returns all appointments for this schedule. We’ve left a to do task here for you to implement this behavior by creating a new specification. Now, the specification that we’re using here is passed to the repository method, GetBySpecAsync. We’ll look at that in a moment. For now, let’s take a look at this specification. All of the schedule specifications are in the ScheduleAggregate folder in the Core project. The ScheduleByIdWithAppointmentSpec is pretty simple and has just three details worth pointing out. First, it has a WHERE clause, making sure it only matches schedules that have a matching ID. Second, it eager loads it’s associated appointments by using it .Include statement. And third, it implements another marker interface, ISingleResultSpecification. This interface is used to mark specifications that are expected to only return a single result. It is required when passing a specification to a repository method that only returns a single instance of a type rather than a collection or enumerable. Considering that this is being called from a List endpoint on the API, this may seem strange, but remember, we are only loading a single schedule aggregate, and it is then just the container for the set of appointments that the endpoint is going to return. The method the endpoint is calling, GetBySpecAsync, is defined in Ardalis.Specification, as shown here. Note that it has a generic constraint requiring any specification passed to it to have that ISingleResultSpecification marker interface. The sample code is calling this first method, which just works with one entity type and then returns it. If you need to use projection, though, you can use the second method, which operates on your entity type, but returns a different type using a .select. You can use this to optimize queries to return only needed properties. Remember that specifications are useful to define the expected shape of returned data in a query. This doesn’t just mean filtering the number of rows using a WHERE clause, but also determining which associations should be brought back with the query, and even which columns should be included. Let’s see an example of that. Returning to the specifications for the schedule, there’s another one called ScheduleForClinicAndDateWithAppointmentsSpec. One of the newer features in EF Core is “filtered includes,” and so by adding an include filter, we can make sure that this schedule, which is being used with a particular ClinicId, will only load in its appointments where they are for a given date that gets passed into the specification. You can use this specification, by the way, as an example when you complete that to do task that we just saw in the list endpoint. Compare this code to how we solve this problem in the previous version of this course using custom SQL queries and a custom ScheduleRepository. The specification has replaced all of that with a single specification class containing all the query logic, and the calling code simply needs to create the specification and then pass it to the repository. Unlike custom LINQ expressions that might be anywhere in our application, specifications are easily tested in isolation. In the IntegrationTests project, you’ll see several different tests that demonstrate the various schedule specifications and ensures they work as expected. These tests use a real database, since .include logic can’t be tested with an in‑memory collection. For the last specification that we looked at, which only includes the appointments for a given date, you’ll see that there’s an integration test that adds a number of appointments on different dates and then uses a repository to fetch back a schedule using the ScheduleForClinicAndDateWithAppointmentsSpec and a specific date, and it verifies that we only get back the appointments for that date and not the appointments that are on different dates, which verify the behavior of many of the abstractions and implementations in our domain model.\nReview and Resources Once again, let’s begin a review with some of the important terms you learned in this module. First, and most importantly, the focus of the module, repositories, which encapsulate the data persistence logic, add, update, delete, and retrieve. In the case of domain‑driven design, we use repositories to focus on aggregate roots. Key to building flexible repositories is the specification pattern, which guides you to encapsulate business rules in a way that they can be passed around and acted upon in other methods, classes or APIs. You learned about persistence ignorance, which describes objects being ignorant about how they are persisted into data storage. It’s another critical aspect of domain‑driven design. Steve and I also talked about ACID, an acronym to describe transactions as being atomic, consistent, isolated, and durable. Another acronym we talked about is SOLID, which is a collection of software design patterns. ‑After introducing you to repositories and how they fit into the DDD mind map, you learned about their benefits and some tips for designing them. ‑We also addressed some of the debates around repositories, not only if you should even use them, but how to use them, for example, whether or not to return IQueryables. Many of these debates exist because of the complexity of balancing clean repositories with repositories that help you achieve the variations of queries required by your domain. ‑We introduced you to an often overlooked pattern, the specification, that plays a critical role in solving this problem with DDD. Remember that you are not on your own building specifications. You can lean on the NuGet packages that I created or just dig into my GitHub repo to pick and choose what you want to adopt. Links are coming up. ‑Steve gave you a great tour of how repositories are implemented in the FrontDesk application and then more deeply to see how these repositories are using specifications to provide the rich querying needed in the application. ‑Here are a number of links to not only my GitHub repo and NuGet packages, but a number of other resources we referenced, as well as some additional ones that we think you’ll find useful. ‑In the next module, you’ll learn about two more critical pieces of the DDD mind map, domain events and anti‑corruption layers, both which help provide some data pathways between the various parts of your software. Thanks again for watching Domain‑Driven Design Fundamentals. I’m Julie Lerman, ‑and I’m Steve Smith. Thanks for watching.\nAdding in Domain Events and Anti-corruption Layers Introduction and Overview Hi, this is Steve Smith. ‑And this is Julie Lerman. ‑In this module of Domain‑Driven Design Fundamentals, you will learn about domain events and anti‑corruption layers, two patterns for decoupling how the domain model communicates internally and with other systems. ‑We’ll start with domain events, which can be used to separate concerns, allowing different areas of the application to evolve independently, and sometimes helping with scalability as well. You’ll learn how to identify domain events in your system, and how to design domain event classes. Then we’ll show you domain events being used in a simple application, so you can get a feel for the structure and the workflow. ‑Then, you’ll get to see the domain events we built in our sample application, which are a bit more realistic. After this, we’ll turn our attention to another important element of domain modeling, anti‑corruption layers, which can be used as translators between bounded contexts and Legacy APIs.\nIntroducing Domain Events Domain events are a critical part of a bounded context. They provide a way to describe important activities or state changes that occur in the system. Then, other parts of the domain can respond to these events in a loosely coupled manner. ‑In this way, the objects that are raising the events don’t need to worry about the behavior that needs to occur when the event happens. And likewise, the event handling objects don’t need to know where the event came from. This is similar to how repositories allow us to encapsulate all of our data access codes, so the rest of the domain doesn’t need to know about it. ‑We can also use events to communicate outside of our domain, which we’ll look at in just a moment. Another thing that’s worth remembering is that domain events are encapsulated as objects. This may be different from how you’re used to coding events. It certainly was different for me when I first started learning about them. For example, in a user interface, events are more commonly written as some form of a delegate in another class, but here they’re first class members of the domain model. ‑Right. Although you can implement domain events using techniques, like the event keyword in C#, the domain events themselves should be full‑fledged classes. In fact, all of these parts of domain‑driven design are defined as objects in our domain model. ‑Vaughn Vernon describes domain events simply, saying we should use a domain event to capture an occurrence of something that happened in the domain. The domain events should be part of our ubiquitous language. The customer or domain expert should understand what you’re talking about when you say when an appointment is confirmed, an appointment confirmed event is raised. ‑You may already be familiar with the idea of events from working with user interfaces. ‑Many user interface clients, like .NET Windows Forms, Electron, or web pages, like the one shown here, make heavy use of events and event handlers. In this example, there’s a single page with a single button, and in the markup, you can see there’s an onclick attribute in the button that leads to a little JavaScript method defining what the app should do in response to a user clicking the button. ‑Events are helpful because they let us avoid a lot of conditional logic. Instead, we can write code that signals a certain thing has happened, and we can have other code in our system listen for these signals and take action accordingly. So in this kind of code, you don’t have a separate class for an onclick event, and it may take some getting used to that now in our model, we’re going to create a whole class to represent an event. Domain events offer the same advantages to our model as the events in the user interface. Rather than having to include all of the behavior that might need to occur whenever the state of one of our objects changes, instead, we can raise an event. Then, we could write separate code to deal with the event, keeping the design of our model simple, and helping to ensure that each of our classes has only one responsibility. Essentially, a domain event is a message, a record about something that occurred in the past, which may be of interest to other parts of our application, or even other applications entirely.\nIdentifying Domain Events in Our System ‑Be especially attentive to these kinds of phrases when discussing the application with your domain experts. When this happens, then something else should happen. If that happens, notify the user when, or inform the user if, these types of phrases frequently refer to situations that are important to the domain expert, the system, or the user. It might therefore be worth modeling these types of things as domain events. You may also discover behavior in the application that will benefit from being treated as domain events that may be the domain expert isn’t initially aware of. ‑Remember that domain events represents something that happened. Since we can’t generally alter history, this means they should be immutable. It’s a good idea to name the event using terms from the bounded context’s ubiquitous language describing clearly what occurred. If they’re fired as part of a command on a domain object, be sure to use the command name. Here’s some examples. ‑Depending on the application, it might be important to have events to represent when a user has authenticated, when an appointment has been confirmed, or when a payment has been received. Be sure to only create events as you need them in your model. You should follow the YAGNI principle, that’s you ain’t gonna need it. In other words, don’t create domain events unless you have some behavior that needs to occur when the event takes place, and you want to decouple the behavior from its trigger. You really only need to do this when the behavior doesn’t belong in the class that’s triggering it.\nDesigning Domain Events Here’s some more things to keep in mind when you’re creating domain events. We’ve already mentioned that domain events are objects, but to be more specific, each domain event should be its own class. It’s also usually a good idea to note when the event took place since frequently the code that’s handling the event might run some time after the event occurred. It can be helpful to create an interface or a base class that defines the common requirements of your domain events. For example, capturing the date and time the event occurred. ‑Also, when you’re designing your event, you need to think about the event‑specific details you want to capture. If it’s related to an entity, you might want to include the current state of the entity in the events definition. Think about what information you would need to trigger the event again. This can provide you with the set of information that is important to this event. Similarly, you may need to know the identities of any aggregates involved in the event, even if you don’t include the entire aggregate itself. This will allow event handlers to pull the information back from the system that they might require when they’re handling the event. Ideally, domain event objects should be lightweight, so you want to be sure you capture sufficient information to handle the event, but not so much that the event object itself becomes bloated. Since the main events are immutable, they’re typically fully instantiated via their constructors. And since they’re simply noting that something has happened in the system, they don’t usually have any behavior or side effects of their own.\nApplying Domain Events to a Simple App We’ve put together a simple console application that we’re going to use to demonstrate the value that domain events can have in your application. The idea behind this is to strip things down to as small a level as possible. Then, we’ll also show how domain events are playing a real role in a more real‑world way when we get to our veterinary scheduling application. This is a .NET console application with dependency injection. The main program just loads the needed services and runs the app. The app has a simple run method, which goes through the following steps. We can step through it with the debugger, so you can see the output in real time. The app loads services and starts running. It shows what happens when an appointment is created using a service. The service calls a factory method that creates the appointment. After instantiating the appointment, the factory method sends an email, which you can imagine includes code like what is in the comments here. Then, it similarly sends a notification to the user interface, again, with code like what’s in the comments before finally returning to the service. The service, then saves the new appointment in the database. Then, the app creates a different appointment and saves it directly using a repository instead of a service. And once more, the notifications and the save occur in the same order. Finally, the appointment is confirmed, which triggers some UI notification, and then that change, too, is saved. The main thing to take away from this example so far is that the Appointment class has a lot of concerns. The act of creating an appointment, especially, involves a lot of code that could fail. It’s also worth noting that notifications and emails are going out before the state of the entity is saved. So if something goes wrong, users will have been told the operation was successful, and people may have been notified via email when, in fact, the update itself might never go through. ‑The reason we’re showing the behavior both from a service and with the appointment directly is because our domains should be designed to work either way. Earlier in this course when you learned about domain services, we explained that forcing all operations on your domain to go through a set of services tends to lead to an anemic domain. Ideally, your aggregates and entities should behave correctly, whether they’re being used directly or through a set of services. One way we can improve this design would be to move the responsibilities of actually sending emails or updating the UI to help our methods or other services. Then, we could call them from appointment.create instead of having all the code in here. This would make for less code inside of Appointment. ‑That would definitely be better, but it would still mean that appointment would need to be updated every time a new requirement came along. There’s a principle we can use to avoid that, though, called the Hollywood principle. ‑I love the name of this principle. Its name comes from an old saying from Hollywood agents, don’t call us, we’ll call you. ‑Exactly. Applied to software, the principle is closely related to dependency inversion from solid. Instead of forcing appointment.create to have to know about and call every possible thing that might be involved in the appointment creation workflow, instead, it can just let the app know something happened and let the app respond by calling handlers. ‑Instead of putting all the logic into this method, potentially making it huge and complicated and really hard to read, we move that logic into handlers, and the app calls the handlers. We don’t call the handlers, the app calls us. And beyond just reducing the amount of code and responsibility inside Appointment, this approach also lets us make sure that notifications to the user don’t occur until persistence is successful. And it still keeps the model’s behavior consistent without requiring a service to perform any of the work. Let’s see how it works. ‑Domain events is a pretty simple pattern, but you do need to have some plumbing code to support it. You also need to think about whether you want your events to fire before or after persistence. In many cases, what you really want is postpersistence events for the reasons we mentioned above. You want to make sure your persistance succeeds before you send any notifications outside of your app. Also, although occasionally I’ve used them for validation in the past, ideally, your domain events and handlers should never fail. That is, don’t build your behavior around exceptions that might be thrown from event handlers. Use a different pattern if you need that type of behavior. ‑In this simple demo, which mirrors how our sample app works, we just need a collection of events on each entity. We’re creating simplistic types to represent domain events and the respective handlers. You can implement the logic to find and call handlers whenever an event is dispatched in a number of ways. For this sample, we’re using the MediatR NuGet package created by Jimmy Bogard. Steve mentioned that you’ll need some plumbing to start, and that plumbing is the interfaces or base classes, if you prefer, for handler and domain event classes. In our example, we’re using interfaces. Here’s the IDomainEvent interface and the IHandle interface. ‑Once you’ve set up your event and handler interfaces or base types, it’s time to create some events and their associated handlers. ‑For this scenario, there are two things happening, an appointment is scheduled or created and an appointment is confirmed. An event is something that already happened. So we name our events in the past tense, and we have AppointmentCreated and AppointmentConfirmed. The event classes are pretty simple and just include the instance that triggered them, so handlers have access to any properties they might need from it. Once the events have been defined, you just take each individual responsibility out of the original method and create a separate handler for it. It’s fine to have multiple handlers for the same event. Ideally, your design shouldn’t depend on the order in which the handlers execute. But if it does, you can think about adding a sequence to your handler interface and ensuring they’re called in sequence order. ‑The last thing you need to do is register or record the events on the entity. In this sample, that just means adding them to the list of events that are on that entity. The actual implementation for dispatching the events is done in the repository after the save is successful. And in our veterinary sample, this work is done in the DbContext SaveChanges method. ‑Let’s step through the code again now that it’s using domain events. ‑The app starts up as before. We enter the appointment.create method. ‑And look how much smaller that method is now. ‑Definitely. It’s way easier to see what’s going on here. Now the domain event is added to the collection, but notice that when we step over this, nothing actually happens yet. ‑Right, it’s just holding it until after the entity is persisted. ‑Which is now. Notice that we’re in the repository Save method. And for every event that we have stored on this entity, we’re using MediatR to publish it at this point in time. ‑This is still in process on the same thread. There’s no out‑of‑process queue or anything involved here. ‑Right, there’s nothing to install using this pattern except for MediatR, and that just runs in‑memory. And, of course, you could wire this up with your own code that simply loops over your set of events and then dispatches out to your handlers. There’s nothing that says you have to use MediatR. Notice in the output that the DATABASE Saved occurred, and then the UI and email notifications. ‑As expected, we only triggered side effects outside our domain after persisting. Now let’s see the version that uses the repository directly and doesn’t bother going through the service. ‑We basically see the same behavior, DATABASE Saved, UI, EMAIL. ‑All that’s left now is the confirm and save, which should look similar, entity saved, and then the UI is updated. ‑That’s basically it. I created a small GitHub repo, which has just this sample in it. It’s at github.com/ardalis/DomainEventsConsole. There’s a branch there showing how things work without events. Of course, you can also download it from the course details. ‑If you want to start your solution with all of this plumbing already in place, you can use Steve’s CleanArchitecture solution template, which is also on GitHub. He is one productive guy. Everything shown here is already in place in the template, which is designed for you to use as a starting point for your app.\nExploring Domain Events in Our Application Now let’s look at how we’re leveraging domain events in the veterinary FrontDesk scheduling app that we’ve been working with. Again, we’ll start by showing you the code, and then we’ll debug through it so you can see it in action. ‑In our Appointment class, we’re going to record a domain event when certain changes are made to the appointment. So, if we scroll down and take a look at the UpdateRoom method, you’ll see that it creates and saves an appointmentUpdatedEvent. The same is true for the other update methods like UpdateDoctor, UpdateStartTime, etc. They each will create an appointmentUpdatedEvent and pass it the current instance of the appointment, and then this is saved into the entity’s Events collection. ‑In the case of the Confirm method, it’s similar, but it creates a different event, an appointmentConfirmedEvent. Essentially, the appointment entity can trigger two kinds of events directly, change and confirmed. And you’ll notice it only does so if an actual change takes place. Calling an update that doesn’t change the current value will not trigger a new event. ‑Let’s take a look at the appointmentUpdatedEvent, and this is similar to the one we saw in the simpler console app in the previous demo. It inherits from BaseDomainEvent, which is defined in our shared kernel, and it adds a UTC timestamp property called DateOccurred that is set when the event is created. This can be useful for debugging purposes. The only other property the class takes is the appointment itself. The AppointmentConfirmedEvent, shown here, is similar. ‑Notice that these domain events are all defined in the core project with our domain model. For this sample, they’re in an Events folder in the root. However, in a large application with many events, it might make more sense to put them with the aggregate that they correspond to. In this case, the ScheduleAggregate. There’s one more domain event in our sample, which is the AppointmentScheduled event. It’s similar in structure to the others, but it’s actually created elsewhere. ‑Once you start working in event‑driven applications, it can be a bit more difficult to follow the flow of execution in the app where events are concerned. It really just takes some getting used to, and then you’ll find it to be second nature. The best way to see where events are raised and where they are handled is by looking at an individual event and examining its references. Looking at AppointmentScheduled, you can see that it is handled in the API project and in the core project. It is only created inside of the ScheduleAggregate itself. Let’s have a look at where that happens. ‑In Schedule, the AddNewAppointment method creates and saves the AppointmentScheduled event after adding the appointment to its collection and marking whether or not it’s conflicting. Once the schedule is saved, any appointments that have had domain events added to their respective collections will have them dispatched after the save to persistence is complete. ‑Before we step through the code, let’s have a look at one of the AppointmentScheduledEvent handlers. The thing to notice is that these handlers don’t get created or called anywhere in our code. That’s that Hollywood agent again from the Hollywood principle saying, don’t call us, we’ll call you. The event dispatching logic, in this case, using MediatR, is what calls these handlers at runtime. But at compile time, nothing references them directly. ‑Now let’s see the flow of domain events in our application when we change an appointment. We’ll modify this appointment for my little baby, Sampson, and change the appointment from a wellness exam to a diagnostic exam. But a diagnostic exam takes more time, and this will automatically change the duration of the visit, which should trigger a conflict with one of Sampson’s other appointments. Yes, he likes to go to the vet quite a lot. ‑The change initially hits the AppointmentUpdate endpoint. It loads the schedule and the appropriate appointment and calls its Update methods. In this case, the only one that has a change is the change to the appointment type. This intern adds an appointmentUpdatedEvent. Once the change is saved, the event is dispatched. The API project also has a handler, AppointmentUpdateHandler, that responds to this event by sending a message to the Blazor client using a SignalR hub. This will trigger a real‑time notification in the app. ‑What about communication between bounded context or apps using events? Applications and microservices frequently use events to communicate, too, but these aren’t domain events since they extend beyond a single domain. They’re frequently called integration events, and they may be defined as part of your domain or in a separate project or package. For simplicity, ours are here in this IntegrationEvents folder. ‑The FrontDesk has just two integration events, the AppointmentConfirmLinkClickedIntegrationEvent is published by another app and consumed by this one, and AppointmentScheduledIntegrationEvent is an event this app publishes and another app consumes. It’s important that the structure of the published and consumed types match, which is why frequently a shared package is used to define these kinds of events. ‑We don’t have time to dive deeply into distributed application architecture, but one thing you need to remember when designing integration events is that they typically will be enriched and denormalized when compared to a similar domain event. For instance, the AppointmentScheduled domain event just has a reference to appointment, and that only has IDs for the client, patient, and doctor. However, the integration event includes many more details like client name and email, patient name, and doctor name. The reason for this is to ensure that consumers of the event have enough information from the event to perform whatever actions they need to without having to immediately call back to the publishing app to ask it for more details. You can imagine that the performance of a system would suffer if every time an appointment event was published, one or possibly many apps that were consuming that event, turned around and immediately had to make calls to this app’s API asking for client details, patient details, and doctor details. Hence, we have a handler that is responsible for taking in a domain event and enriching it with the additional details shown here on the integration event. We’ll put these integration events to use in the next module.\nIntroducing Anti-Corruption Layers The last topic we want to discuss in this module is anti‑corruption layers. An anti‑corruption layer, as the name implies, helps to prevent corruption in your domain model. ‑Right, just like superheroes help to fight corruption, these layers provide a sense of security to your model when it needs to interact with other systems or bounded contexts. ‑Returning to our mind map, you can see that the anti‑corruption layer is used to translate and insulate as part of a context map, mapping between a bounded context and foreign systems. ‑When your system needs to communicate with other systems, especially legacy applications that weren’t written or modeled as well as your current system, you need to be careful not to let assumptions and design decisions from that system bleed into your model. For instance, if the other system’s model includes a customer, even if that customer refers to the same actual business customer, it’s likely that it will be modeled differently than a customer in your system. It’s best to have a layer that can translate to and from other systems’ models. In DDD, this is the job of an anti‑corruption layer. ‑Right, like we mentioned in the beginning of the course, even other bounded contexts in your own system may be different enough to merit having an anti‑corruption layer in place to protect the two distinct models from one another. And, of course, legacy applications frequently use very different models from newer systems. An anti‑corruption layer isn’t a design pattern, however, it’s usually comprised of several design patterns. The job of the layer is simply to translate between the foreign system’s model and your own. ‑In addition to translating the objects themselves, the anti‑corruption layer can also clean up the way in which you must communicate with the other system. It may provide a façade to simplify the API or an adapter to make the foreign system behave in a way that is known to your system. You can learn more about these design patterns in the Design Patterns Library on Pluralsight. ‑We’re usually most concerned with having an anti‑corruption layer in place when communicating with legacy systems. Eric Evans notes why that’s important. ‑Even when the other system is well designed, it is not based on the same model as the client, and often the other system is not well designed. ‑Since this is a fundamentals course, we’re not going to dig deeply into anti‑corruption layers, because they can be fairly complex, as well as very customized to each scenario, but here’s an example structure of one which comes from Eric Evans’ book, showing how an anti‑corruption layer can connect your beautiful system on the left with a not so beautiful system on the right. ‑I really like this diagram. I think Eric had some fun putting it together. ‑Gee, what gives you that impression, Steve? ‑Of course, in the middle you can see how the anti‑corruption layer is using a façade and some adapters, but on the right it’s protecting us from a big complicated interface, some messy classes, and some things we just don’t even want to know about. ‑Right, and of course, your own system is comprised of an elegant class, a very expressive class, and of course even more good stuff, and maybe even some stuff we should be refactoring as well. ‑There’s no one way to create an anti‑corruption layer. Whatever you need in order to insulate your system from the systems it works with is what you should put inside of this layer, which should allow you to simplify how you interact with other systems, ensure that their domain decisions do not bleed into your design, and ensure any necessary translation is done along the way.\nReview and Resources We’ve covered some new topics in this module, and there’s a few new terms that we want to make sure we review. Domain events are a type of object that actually represents something that occurred within the domain that other parts of the system may find interesting and want to tie their behavior to. And this is a great way to keep your system decoupled and to keep your individual objects simpler because they don’t have to know about all of the behavior that might occur when some event takes place. We also referred to the Hollywood principle, which can be summed up as don’t call us, we’ll call you. This principle is related to the dependency inversion principle from SOLID and is frequently used to decouple systems from one another. Instead of us putting all the logic we need in our code, we architect the system so that it calls back to us at the appropriate time. And we put our code into handlers that the app calls, rather than directly coupling our model to these actions. ‑And finally, we looked at anti‑corruption layers, which can be used to ensure that our model that we worked so hard to produce doesn’t become polluted by the models of other systems we work with based on objects they wanted to return to us or the type of API that they want us to code to. So we put anti‑corruption layers in place to shield our model from those other systems or bounded contexts that we might work with from our bounded context. ‑In this module, we introduced domain events, and hopefully, you have a good idea of what they are at this point. ‑We’ve talked about how you can identify opportunities to use domain events based on the kinds of requirements your customers give you, as well as when you see code in your model that’s doing too much and could be more loosely coupled. ‑We gave you some tips for designing and naming domain events, and then we showed them in action, both in a relatively simple console app, as well as in our much larger veterinary clinic sample application. ‑Finally, we introduced the concept of anti‑corruption layers, which use a variety of design patterns to insulate our model from the design choices of other applications or bounded contexts. Here are a number of resources where you can learn more about domain events and anti‑corruption layers. Some of these, including a few Pluralsight courses, we mentioned in this module, but there are others that we find to be relevant, even if we didn’t explicitly mention them. ‑Up next, we’re going to wrap up this course by adding a new feature to the application. Because of our clean architecture and well‑designed domain model, it’s going to be pretty easy to integrate into our existing app. I’m Steve Smith, ‑and I’m Julie Lerman, and thanks for watching this module of our Domain‑Driven Design Fundamentals course.\nEvolving the Application Easily Thanks to DDD Introduction and Overview Hello, this is Julie Lerman, ‑and this is Steve Smith. In this module, we’re going to wrap up our course on Domain‑Driven Design Fundamentals by showing how we can reap the benefits of our design when it’s time to add additional functionality to the system. ‑In this module, we’ll first review our current system design and see how it incorporates DDD patterns and practices. Then, we’ll circle back to our customer, Michelle, to see how the new vet clinic appointment management system is working out. ‑During that quick conversation, we’ll learn about a new feature, and we’ll show how we can implement that feature. ‑We’ll leverage message queues to implement this feature, so we’ll definitely be sure to share with you some of the basics about message queues before we show you that code. ‑The main benefit of our design choices is the ease with which the system can be extended and maintained in the future. And we hope you’ll agree that adding to the current design is quite straightforward.\nReviewing Our Current System Design So far, our system is pretty simple, though it’s fairly complex, as most course demo apps go. ‑The system is currently two different web applications, although the user interface makes it look like a single app. Our main focus has been the application used by clinic employees to schedule appointments. There’s a lot of complexity with scheduling, so this benefited from domain‑driven design. There’s also a clinic management application that’s used to do simpler data‑in/data‑out tasks like record keeping and maintaining information about doctors, clients, patients, and more. Let’s review the scheduling app a little more closely. ‑We have a single aggregate for a schedule, which contains a number of appointments. We limit access to the schedule through the schedule repository class, which is responsible for retrieving and storing the schedule in our database. We’ve identified a couple of value objects that allow us to better model concepts in the domain, and we’re making use of domain events to allow our domain in other parts of our system to respond to changes in the state of our model. ‑It’s taken us a while to get to this point, but now that we’re here, the design of the system is very clean, and it reflects the customers domain, as well as we’ve been able to model it so far, of course, given some time constraints. ‑Yes, we do have to ship the app, I mean, this course, at some point. ‑Right, of course, as we build on this application, our model would continue to evolve. But we’ve shown you techniques you can use to ensure that you can grow the application without being overwhelmed by the complexity you’re trying to model. ‑Actually, as it turns out, the customer does have one more request for us. She said something about customers forgetting their appointments. Let’s have another quick conversation.\nAddressing a New Feature with the Domain Expert As it turns out, the customer does have one more request for us. She said something about customers forgetting their appointments. Let’s have another quick conversation. ‑Hey, Michelle, great to see you. How are things going with the new scheduling application? ‑It’s been fantastic. We’re really able to see very easily who scheduled each day, and book new appointments, and move things around is needed, and the front desk folks really appreciate that it highlights the appointments that are conflicting or unconfirmed. That makes it much easier for them. But one thing that’s still a problem is the fact that sometimes our clients forget their appointments. It probably happens at least a couple of times every day, and our staff really don’t have the time to call every client to make sure they remember ahead of time. ‑So, you’d like the system to call them then? ‑Well, we understand there’s services that’ll do that sort of thing and we might move to that eventually, but for now, if we could just send an email that would probably help remind clients to put it in their calendar. ‑Oh, okay, so, do you want an email to go out when they schedule the appointment or on the day before they’re scheduled to come in, or maybe even both? ‑Oh wow, if we could do both, that would be great, one to let them know when they’ve booked so that they know that we’ve got it in our schedule and another one to remind them that they have an appointment the next day, just in case they forgot. ‑That shouldn’t be too hard. Our model already handles certain events that occur, like when appointments are scheduled, and appointments already support being marked as confirmed too. ‑Sure, and I think all we’ll really need to build that’ll be new is some kind of service for sending the emails and some way for clients to click a link in the email so they can confirm the appointment. Since it’s email, it shouldn’t be a problem to send these out the day before, even if that day isn’t a week day or a work day, right? ‑No, I think that should be fine. It shouldn’t hurt anything to send an email on a Sunday or a holiday, and of course, we’ll ask our clients to opt into these reminders so we’re not sending anything unsolicited. ‑Sounds good. We’ll get started, and should have something for you to review real soon.\nPlanning Our Implementation Steps Before we get into the gory details of the implementation, we just want to make sure that you understand the very high level of what we’re doing here. The first thing is triggered when the appointment is scheduled. And in response to that, our system will send a confirmation email to a client. ‑Once the client gets that confirmation email, they can click a link to confirm that they’re going to make it to the appointment, and the system will then mark that appointment as confirmed so that on the schedule, the staff will see that it’s got a green box around it, and they should expect the client will actually show up. ‑What’s nice about this implementation is that it benefits so much from a lot of the infrastructure we already have in place. And thanks to our DDD‑based architecture, it’s just as easy to add in a few extra features that we need to make this work. ‑So as we go through this, you’ll see us using some existing and some new domain events, some application events, a number of event handlers and services. One new tool you’ll see is something we haven’t talked about yet, messaging queues to communicate between separate applications. The application we’ve been working with will need to communicate with a public website that the customers will interact with when they confirm their appointment.\nIntroducing Message Queues Before we go any further, we did just mention something new, which is message queues. And we just want to talk about that a little bit. It’s a pretty advanced topic for this fundamentals course, so we’re going to talk about it at pretty much a high level. ‑Message queues are nice to use between applications for a number of reasons. They can help decouple them and make it so that one of the applications can just drop off something into a message queue and continue on with its work and not have to worry about what happens to the message after that. ‑Right, or if whichever application or applications it’s trying to communicate with, it doesn’t need to worry if that application is available and listening at that very moment. The message can sit in the queue and when the other application is ready to grab it, it does. With a message queue, we’re really just dealing with a single message. One application drops it, and the other one takes it, and then the message is gone. ‑Yeah, and there’s lots of different implementations of message queues that you can find online. Some of them are free. Most of the cloud services that are out there now have these types of things built in as well. ‑And what we’re doing here is dealing with a single message at a time in something of a silo app since we control both applications that are communicating with each other. But sometimes you need to have a lot more flexibility than that, you might actually have a number of applications that are interested in that message and you may not even know in advance or control those applications. So this is when something called a service bus comes into play. ‑Right, so you’ll frequently hear about something called an enterprise service bus. And there’s, again, a number of examples of these that you can find available. It usually sits on top of message queues and other features. And one of the responsibilities it has is making sure that messages get delivered to the different applications that care about that message. ‑It might even be an application that didn’t even exist or you didn’t know about when you were first setting up the message queue. So even at that point, because service bus allows you to decouple the routing of the message, it’s possible to go ahead and hook up other applications to listen to the queue. ‑Right, so you’ll see in our scenario that we have our scheduling application raising an event that an appointment was created. And it might be that maybe in the future we would want to add some other application that wants to react to that event. ‑We could publish it to social media, hey, I’m going to go see the vet. ‑Exactly. If we had a service bus, we could simply wire up in our service bus for this new social media notifier service, pick up that event. But with just message queues, as you’ll see in our implementation, we would have to change our scheduler application to know about this new app and write to its queue because we don’t have any advanced routing, everything’s hardcoded in our simple scenario. The message queue we are using is RabbitMQ. It’s a mature, open‑source message broker that you can get set up and running with zero install by using a prebuilt Docker container. It has a lot of capabilities, but we’re keeping it simple and just using it to define a few specific queues, which are separate bounded contexts we’ll use to publish and consume events.\nSending a Message to the Queue Now let’s take a look at how we’re adding message queues into our solution. The first part of the process happens when the appointment is scheduled. And you’ve already seen our AddNewAppointment method inside the schedule aggregate root. And you saw how the domain uses domain events and domain services to notify the user interface if there’s a conflict in the schedule. In the previous module, we showed you MediatR, which we’re using to publish these domain events. And we also talked about integration events, which are structured to be shared between different applications. So what we’re going to do in our system is add RabbitMQ into the mix at the same point where MediatR is publishing the domain events. But we’ll ask RabbitMQ to publish our integration events. These events will be formatted as JSON data before they’re inserted into the queue. So let’s see what this looks like in the application. We’ll be looking at the code that makes all of this work a little further on in this module. We’ll go ahead and create a new appointment. Let’s bring Sampson in to see Dr. Jones again. So there’s the appointment. Nothing has changed from the perspective of the user. RabbitMQ includes a user interface to inspect the queues, and in the Front Desk app the menu has a link so that you can open up this admin page and see what’s going on with the queues that are associated with this application. We’ll head to the Queues page and then drill into the vetclinicpublic queue, which is a queue that we set up to handle communication between the Front Desk app and the VetClinicPublic app. And you can see that the one and only message that RabbitMQ is tracking is in that queue. So we’ll drill into that queue and then scroll down to see the details of the message itself. And the most interesting part, the payload, which is the JSON expression of the event data. You can see the GUID value of the AppointmentId, the ClientName is Julie Lerman, an email address, which is not really my email address, the PatientName is Sampson, and other relevant details that came from the integration event. So the Front Desk app knew to publish the message to this queue, and our VetClinicPublic app knows to read from this very specific queue in order to perform the task of emailing the client.\nReading From the Message Queue and Acting on the Message Now that the message is waiting in the message queue, it’s time to read the message and act on it. And acting on it is the next step in a workflow, sending an email to the client to let them know about the appointment they’ve just scheduled. We can’t do this easily from our scheduler application because we need for the user to be able to click on a link that specifies that they want to confirm their appointment, so it needs to be publicly accessible. So we’ve decided to put this on the veterinary clinic’s public website, and so that will be responsible both for sending the emails and for hosting the link that the customer will click. The public site uses a hosted service to periodically check for new things in its queue. Once it finds a message on the queue, it will retrieve the information from that message to create a confirmation email using code like what you see here. One of the most important pieces of this email is a link back to the public website, not really localhost, which includes the GUID that represents the appointment ID. The website then sends the email. That’s what the user will end up clicking on in their email and trigger a confirmation using the website. Alright, so now we’re looking at the vet clinic public website, which is a super simple demo solution that we put together. And one of the things it does when it starts is start checking for messages, which you can see here. But we don’t have it running quite yet because it would’ve already pulled the message out of the queue. First, we’ll show you the code that’s making this all work, and in a bit, we’ll step through while debugging. The public website has a hosted service called FrontDeskRabbitMqService, which periodically checks the message queue to see if anything new has arrived. As soon as it finds one of those messages off of the message queue, it’s going to send an email, and we’re going to use a tool called Papercut, which will emulate a local email server for the purpose of testing. Rather than installing this on our dev machines, we’re running a Docker container to host Papercut. You can view emails Papercut has received by clicking the Sent Emails link from the FrontDesk app’s menu. Currently, there aren’t any emails in Papercut, but as soon as we start the web application, it’s going to check our message queue and then send an email that we should see appear in Papercut. There’s a message, the same message that we sent out for Sampson’s appointment. There’s a hyperlink that leads us back to being able to confirm. Let’s see first, high level, what happens when we click on that CONFIRM button, and then we’ll come back and click it and watch it in action. So now the user has the email, and their beautiful CONFIRM link in the email. When they click that, it opens up the website, browsing directly to the GUID that was their appointment. And in response, the website calls its own method called confirm, which takes the relevant appointment ID and pushes it into another one of the queues. You’ve seen the message queue that was used for relaying the message from FrontDesk to the public website, and that was named fdvcp‑vetclinicpublic‑in. Try to say that five times fast. But you can have as many queues defined in your system as you need. And one of the other queues that we’ve defined is for relaying messages from the public website, in other words, when the client has clicked on the button to confirm their appointment back to the FrontDesk app.\nUsing Multiple Queues to Handle Various Communications Now that the email’s been sent, let’s see what happens when the client clicks on the CONFIRM link in that email. ‑When we click on that, we’ve now confirmed the appointment. Once the user clicks on the CONFIRM link, it drops the message with the confirmation back into the scheduler queue, and you can see that message right here. ‑Yeah, this middle queue shows that there’s one message. Let’s look at it. We’ll scroll down to the Get Message(s) button, and the message is retrieved and displayed. We’ve seen this before where the payload is the JSON data we’re looking for, and this one contains the appointment ID that’s just been confirmed. Now you can see that the two different applications are communicating back and forth with each other using their two separate message queues. We’ve named the queues so that it’s clear which applications are using them to communicate and in which direction. The initial acronym specifies which two applications are involved. Fdvcp means frontdesk and vet clinic public. The latter part of the queue’s name says which app is listening to it. The last step now is for this confirmation information that’s sitting in the queue to get back to the scheduling app. ‑Now in our scheduler application, we have implemented a hosted service just like you saw in the public website This one is called the VetClinicPublicRabbitMQService, and it listens to the appropriate queue to see if there are incoming messages that it needs to deal with. When it finds one, it responds to the AppointmentConfirmLinkClickedIntegrationEvent, yes, it’s a long name, with the email confirmation handler. The handler looks up the appointment from the AppointmentId that was contained inside of the message, and from there, it calls Appointment.Confirm. Appointment, as you recall, is our entity, and its confirm method also then triggers some domain events, which for instance, our user interface listens to. And when it sees that that event has been fired, it triggers a change in the UI, enhancing the appointment with a green bar across the top to show that the appointment has been confirmed. Okay, so all that’s going to happen at this point is that when the message comes through, it’s going to make the Sampson appointment right here have a green border and pop up a dialog to let us know that a change has occurred. ‑It’s very slick. This is actually really easy to implement because we already had the website listening for events. Remember how it was able to display new appointments and display conflicts? We’ve implemented another design role based on a particular property of the appointment, which is confirm. All we did was set up another event handler. ‑We wrote the original sample for the first version of this course in 2013. At the time, things like SignalR and WebSocket, as well as emails with confirmation links were relatively rare, although we certainly didn’t invent these kinds of app interactions. ‑Right, but now, every time I make an appointment for my dentist or hair and even for Sampson in real life to go to the vet, I’m getting texts or emails with exactly these kinds of confirmation links. ‑I know, I guess maybe a lot of businesses watched our course.\nDebugging to See the Detailed Implementation in Code Now we’re going to take a deep dive into the code that makes all this work, and we’ll go through it step by step so that you can see how all this is wired together. And we’ll do that by literally just debugging through the whole process, so you can see how all the code links up. Remember, all of the code for this sample is available on GitHub, and we encourage you to run it yourself to really understand how it works. The README file has instructions for running the solution using Docker, which is the recommended approach if you just want to see it running. There are also instructions for using Visual Studio or VS Code, which you will need if you want to debug the apps as we’re about to do. For instance, I need to run RabbitMQ and PaperCut using the Docker commands shown here, before I can debug the app, as we’re about to see. We’re back in the vet manager, and the user is on the phone with Steve who wants to make an appointment with Darwin. Everything works just the same way it’s worked before. We’ll go ahead and add a new appointment and save the appointment, which triggers the ScheduleAggregate root’s AddNewAppointment method. We’ll leave the Locals window open while we’re debugging so that if you want to pause the video and take a look at any of those values, you can do that. We haven’t changed anything in the method. The only thing that’s different is that now we’ve got an additional subscriber that’s listening for this domain event, this particular domain event, the AppointmentScheduled event, to be raised. So we’ll go ahead and raise the event and watch what happens. At this point, we’re looking at a new class that we created, which is this RelayAppointmentScheduled service, and what it’s responsible for is creating the event that is going to get pushed onto the message queue that the public website is listening to. This is the new piece of logic that’s listening for the event that we just raised. You can see it’s listening for AppointmentScheduledEvent, a domain event, and in the method, the first thing we do is to create the AppointmentScheduledIntegrationEvent that represents our cross‑domain message that will be sent using RabbitMQ. The functionality we need from this event right now is to be able to send an email to the client, so we make sure to include all of the data that such an email would require. Now we’re in the Publish method that lives inside of RabbitMessagePublisher, and that’s inside of an infrastructure project. We’ve moved out of the core domain, but this is still part of the main front desk scheduling application. Yes, and what it’s responsible for doing is actually getting that message into a structure, a format that RabbitMQ can use. That means putting things into JSON format in this case, and then actually sending the message. Once this fires, we should be able to inspect the message queue in RabbitMQ, and verify that our message has actually been queued up for the VetClinicPublic input queue as expected. That’s what we did before, but this time we’re actually seeing the code that’s making all of this happen. Alright, so that completes the actual thread of the UI. The response is complete for this part of the application. Now we’ll pause this and switch over to the VetClinicPublic application. We’ve just started it up again, and we’ve shown this to you before. Now we’re going to watch the flow of the code after the hosted service starts up. Jumping to the next breakpoint, you can see now we’re inside of the actual HandleMessage method, which gets the message as a string. It’s responsible for parsing the string using JSON, and deserializing it into an appropriate type. This is just demo code, so it’s not the most reusable or elegant, but it works for this app. Remember that any change to the integration event in the front desk app will require changes here as well, which is one reason why a shared package can be useful for keeping applications in sync. Once we’ve deserialized the message into a command, we use mediator to send the command, and a separate handler to actually send the email. This keeps extra code out of the hosted service, and lets the handler use dependency injection to get any services it needs. In this case, it’s an implementation of, I send confirmation emails, called ConfirmationEmailSender. It’s the service that builds the email with its details, including the URL behind the CONFIRM link in the email that the client receives. Remember, the whole reason why we need a separate app to implement this feature is that the end user needs to be able to click a link that goes to a public location on the internet. The front desk app is an internal app that runs inside the vet clinic’s network so it’s not accessible. The public website is a good place to send users, and while they’re there, they can get more details about the clinic, or buy something from its theoretical online store, etc. After the email has been sent, we can see it in PaperCut, and opening it, we can see the CONFIRM hyperlink. Clicking the link brings us back into the VetClinicPublic application’s, AppointmentController class. This endpoint simply creates a new event. This is the one with a really long name, AppointmentConfirmLinkClickedIntegrationEvent. Unlike the name of the event, the message itself is really simple, and just includes the appointment ID that was confirmed, and when it happened. The controller action then sends the event using a RabbitMQ messagePublisher that’s identical to the one we just saw the front desk app use. However, this publisher’s destination is actually a different queue, the front desk input queue. Technically, the front desk has two input queues, one for messages from the ClinicManagement app, and another for messages from the VetClinicPublic app. In this case, we’re talking about the VetClinicPublic one. Back in the front desk scheduling app’s hosted service, it discovers the message on the queue, and calls into the HandleMessage method in the service we’ve seen a number of times, the VetClinicPublicRabbitMqService. Here, it parses the message and extracts the appointment ID, which it then uses to create and publish that really long‑named event again, AppointmentConfirmLinkClickedIntegrationEvent internally. This integration event triggers a call to the EmailConfirmationHandler, which loads the schedule aggregate, then locates the appropriate appointment, and calls its Confirm method. Finally, it saves the schedule. The appointment.confirm method makes an appointmentConfirmed domain event, which is fired once the aggregate is saved, and this event in turn triggers a handler in the UI. The appointmentConfirmed handler in the FrontDesk UI sends a message via SignalR, indicating the message was confirmed. This results in the browser showing a notification, and changing the format of the appointment to have a green border. You already saw similar logic used for the AppointmentUpdate and AppointmentScheduled handlers. That’s the full round trip for how creating an appointment, getting an email, clicking a link, and confirming that appointment works for this application.\nConsidering Microservices Since we published our original version of this course, which if you haven’t watched, you’ll find a link from either of our author pages, microservices have become incredibly popular. There are some benefits to microservices, even if they’re probably a bit overhyped at the moment, and there are some obvious parallels between microservice design and DDD. ‑Microservices should be self‑contained and should not depend on other microservices. They should be independently deployable. Changing the internal behavior of a microservice should not break services that work with it, as long as it maintains compatibility with its external APIs and message interfaces. ‑So, basically what you’re saying is each microservice should have a boundary around it, and within that boundary it should focus on a specific set of behaviors that its free to model however it sees fit. ‑That’s right. ‑It’s almost like each microservice can be considered its own context, and it has its own terminology and even language for how it’s designed. ‑It is a lot like that, it’s true, and it’s not unusual for teams to treat individual microservices like bounded context with their own ubiquitous language and everything else that goes along with being a bounded context. But, beware of assuming that microservices and bounded context always have a perfect alignment. There can be plenty of scenarios where this could be a problem. My brilliant friend, Vladik Khononov, not to be confused with the also brilliant Pluralsight author, Vladimir Khorikov, has shared his experiences along these lines in his blog and also in recorded conference presentations. We’ll include links to his content in the resources at the end of this module. ‑Now, this isn’t a microservices course, but obviously if you’re working on microservices, it would be helpful for you to have a good understanding of DDD concepts, because many of the problems that microservices solve are also solved by domain‑driven design. ‑In our sample application, there is an obvious candidate for a microservice. In fact, it’s almost there already, the confirmation email sending logic that currently runs inside the public website. ‑We put the hosted service in that existing web application because it was convenient and because the two are loosely related since the emails include a clickable link that goes to a page on that public website. ‑But we could easily move that hosted service into its own process and treat it like a separate microservice, and that would simplify the public web app, so it would no longer need to have a two‑way relationship with a front desk app by way of message queues. Also, the front desk app is likely to be updated more frequently than the confirmation email logic, so it’s possible that changes to the front desk application could break the email logic. ‑Yes, one of my favorite benefits of carving out a microservice is that if it’s something stable and working, you get the benefit of just leaving it the heck alone. Updates to other parts of the app or system are much less likely to break a microservice that is in production and working, and not being deployed frequently. ‑Right, and the email sending logic is about as micro as a microservice can get, but in the future we might want to add other kinds of customer emails to send, and it would be a logical place to hold that logic. ‑Exactly, and since it has no user‑facing logic, it’s a pretty simple change to make. Maybe some of our students could do that as another exercise.\nSharing Some Tips for Extending and Running the Sample Application As we wrap up the course, we want to remind you, once more, that there are a number of to‑do items in the sample that you can use as ideas for ways to extend this demo app. Doing so would help you gain real experience working with the architecture and patterns you’ve learned in this course. You’re sure to learn and retain more from actually working with the code than from just listening to us or watching us show you the code. ‑We do have detailed instructions in the README for how to run the app. You can run the individual solutions in Visual Studio, but if you do so, keep in mind, you’ll also need to make sure you have a local SQL Server running, and you’ll need to update the connection strings and app settings for the applications to access it. You’ll also need your own RabbitMQ and Papercut or similar test email server running, either as Docker containers or locally‑installed services. There’s definitely a bit of effort involved in getting all of this set up and running the first time. ‑Alternatively, if you just want to run the app and see everything working, you should be able to do so with just two commands, assuming you have Docker installed. Just run docker‑compose build ‑‑parallel and then docker‑compose up. Each of these commands might take a few minutes. It usually takes about 2 minutes for the build step on my machine, and it’s normal to see some errors when the docker‑compose up command runs until all of the services are up and running. Once the process stops outputting messages to the log window, you should be able to hit the application. To do that, take a look at the ports that are shown in the README file. And in the Docker column, you’ll see the ports for all of the different applications and utilities that are used.\nConsidering the UI in the Domain Design The control we used solved a number of the problems we thought we were going to have when embarking on this application. But the fact that the UI kind of impacted how we designed our domain begs the question about, well, if you’re totally focused on the domain, why would you even be thinking about the UI? But thinking about the UI while we’re working on the domain is not the anti‑pattern you may think it is. ‑Yes, we’ve been focusing on the domain, but frequently the user interface needs to be considered, especially in the early stages of planning. You don’t want to try to flesh out the whole domain design before you start thinking about the UI. ‑In a TechEd session I attended in 2013, Jimmy Nilsson, who’s the author of the book Applying Domain‑Driven Design and Patterns, talked about the importance of thinking about the UI in the early stages of planning and revisiting it while modeling the domain, rather than ignoring it until the end. In his session, he describes how even the UI sketching he does in the early stages of his application planning can affect the whole design of the system. As we were building this scheduler sample for this course, we actually discovered a huge benefit to considering the UI early in the process. We initially had expected to encounter a lot of complexity in the appointment scheduling problem, but we found a UI control that helped visualize the schedule for the user, such that the system no longer needed to be as complex. In our scenario, scheduling is a big part of the application, but it isn’t our domain, our domain is the veterinary clinic. We consider scheduling to be more of a cross‑cutting concern, and one that could be partially solved through a rich user interface. ‑By considering and using a rich user interface, we were able to do things like allowing conflicting appointments while making it obvious to the user that this had occurred. This gives the user more information, and they can make decisions about whether or not they need to correct the problem. When we initially considered the problem of appointment conflicts, we had thought the domain model would throw exceptions anytime something like that occurred. But this would have resulted in a much worse user experience. Frequently, in domain‑driven design, you need to consider the user experience, which at times may need to allow for models that are, at least temporarily, in an invalid or incomplete state. Keep this in mind as you design your domain model, and be careful not to make it too rigid to support scenarios your users may benefit from. ‑Thinking about the UI up front and discovering this kind of solution kept us from wasting a lot of time trying to solve certain scheduling problems in our domain. Of course, you don’t want your UI to totally drive how you model your domain, but as Jimmy Nilsson notes, you shouldn’t ignore it, either.\nModeling with Event Storming and Other Techniques When you’re developing apps using DDD, it can be helpful to visualize how processes communicate both within a bounded context and between context as part of a business process. As we mentioned earlier in this course, Alberto Brandolini has done a lot of work on a related practice called event storming. Event storming can be used by all parts of a business, not just developers, to describe how a part of the business works and to make the whole thing visible. Once this is done, later iterations of the diagrams and artifacts produced can be useful for modeling the software that will be used by the business. ‑You might recall the image we showed earlier of Julie facilitating an event storming workshop with a client. The result of that first iteration, called chaotic discovery, is not so easily captured, but it provides guidance for the later modeling you might do. ‑There are many ways to model your system. Another method, Event Modeling, championed by Adam Dymitruk, is another process, and this focuses on the inputs and outputs of events and how each of those events changes the system and changes state. And you can describe an entire system with this flow. ‑We’ve used the wonderful online tool called a Miro board at miro.com to show one perspective of the scheduling system as information flows through the front desk application and into the VetClinicPublic website bounded context. The colors used here correspond to different things in our model, like aggregates, events, and other processes. ‑And there are other modeling processes that have been invented, adopted, and adapted within the DDD community. And many of us rely on a combination of processes and tools to help us and help our clients better understand their systems before embarking on design. But as always, balance is important. You’ll want to beware of analysis paralysis. ‑Definitely. That reminds me of something Eric Evans talked to us about.\nEric Evans on the Fallacy of Perfectionism Steve and I believe that it would be fitting to leave you with one last thought from the father of domain‑driven design, Eric Evans. Eric was kind enough to talk to us about DDD when we originally created this course so that we could share with you some of his wisdom. Eric talked about the fallacy of perfectionism, which aligns with our own sentiments about considering what you’ve learned here to be guidance to help you solve complex software problems, not a roadblock to productivity. ‑Eric shared with us that what he’s noticed is that there seems to be something about DDD that brings out the perfectionist in people, and they say, this model is not really good enough and churn and churn, trying to improve it. He says, no model is ever going to be perfect. ‑Eric goes on to say that we need to know what we’re doing with this thing, the scenarios we’re trying to address. We want a model that helps us do that, that makes it easier to make software that solves those problems. That’s it. ‑This reminds me of the saying, all models are wrong, but some are useful. Our domain models don’t need to be perfect. They just need to help us build the software that helps people solve problems and get work done. Don’t strive for a perfect model, but rather just aim to develop a useful one.\nLessons Learned Since Our 2014 Course Julie and I wanted to finish this course by spending a couple of minutes talking about some of the things we’ve learned since we published the first edition of the course in 2014. ‑We’ve received a ton of positive feedback from so many of you over the last few years, and we really appreciate it. So we did our best not to change the overall flow of this course too much since we know the last one was so well‑received. ‑Definitely. If you watched the original version, hopefully you found this one to be fresh, but familiar, and I suspect a lot of students will end up watching both as a way to cement some of these concepts or just to spend more time with us, right, Julie? ‑Maybe. Now let’s highlight some of the things that have changed in the last few years. From a strict DDD perspective, there are a lot of new resources and techniques that have emerged as more and more companies are adopting DDD. Things like event storming an event modeling, which we’ve touched on in this course, are starting to become mainstream parts of DDD for many organizations. ‑Yes, and the industry’s use of some patterns have shifted too. There’s a lot of pushback against the repository pattern these days. I think, in part, because it became very popular, but was often used without the context of DDD or other complementary patterns like the specification, and these can really help it shine. Our first course didn’t really talk much about specification as a core DDD pattern, but it’s something I use on most of my projects now. ‑From a technology perspective, our previous course was built for .NET developers, and at the same time, that meant .NET 4. The original veterinary application used ASP .NET, MVC, and Web API, and an early version of SignalR. And for data access, we used Entity Framework 6. ‑Since then, .NET Core, which is now .NET 5, has shipped and become the new standard for .NET developers, and the latest versions of EF Core have added a number of features that we’re leveraging to help improve the design of our model like owned objects and filtered includes. We also shifted our use of domain events from being prepersistence to postpersistence. There are valid use cases for both kinds of domain events, but the latter is safer for any events that communicate outside of the domain, so we’re defaulting to that this time around. ‑Right, especially since one of our key demos involve sending emails to the client. The original sample also used SQL Server for its message broker, which we chose because we didn’t want to force our students to have to install a custom tool. But Docker is another technology that wasn’t mainstream in 2014, but it is today, and it makes it a breeze to use custom bits of infrastructure. In this update to the course, we’re definitely leveraging Docker to provide RabbitMQ messaging with 0 install, as well as to capture emails during development using Papercut in another Docker container. ‑Yeah, Docker should really make it trivial for students to run the application locally, even though it has a bunch of moving parts. If you don’t have Docker, you can still run it in your IDE or from the command line, but with Docker, it’s just a lot simpler to get going. ‑And along with Docker and containers, microservices have become a huge buzzword in the industry. Of course, Docker makes it much easier to deploy microservices, and DDD principles really shine when designing them. So all of these things, I think, are really complimentary. ‑Definitely, although I do think some companies are too quick to jump to microservices without fully understanding their domain and where to separate out different contexts. And on the topic of separation, our previous sample put everything in one giant solution, too, mostly to make it easier to find things. ‑This time, we went with something that should resemble a real‑world application even more with separate solutions for each bounded context. We even published the shared kernel as a NuGet package, in our case, hosted on nuget.org, although typically, your organization would probably have a private NuGet feed. ‑If you’re still working with .NET Framework apps and you haven’t watched the previous course, we encourage you to give it a look. Its samples are geared more toward that framework, and you should find a link to it on Julie or my author page here, on Pluralsight, or at this bit.ly link here. ‑And don’t feel bad if it feels like there’s still a lot you have to learn about DDD. It’s a big topic. And as we’ve just shared, Steve and I are constantly learning new ways to apply it, too. Be sure to check out other DDD courses here, on Pluralsight, and if you need direct help for you or your team, you can reach out to Steve or me, directly.\nReview and Resources If you remember nothing else from this particular module, the one thing to keep in mind is how simple it was for us to add in what was potentially a really complicated feature. Because of our DDD implementation and some of the infrastructure we had already built, it wasn’t really very challenging to plug these new puzzle pieces into the application. ‑Right, we introduced a couple of new concepts. We talked about message queues, and those fit really nicely into our existing architecture because we were already using events to correspond to interesting things happening within our application. ‑And the message queue allowed us to stick a message in an external place by one application, and another application can come along and retrieve that message. So the message queue allows our applications to communicate with each other, but they can do it in a disconnected way. ‑And then we mentioned, but we didn’t show, this concept of a service bus, often called an enterprise service bus, which you may want to introduce if you start having more than just a couple applications needing to talk to one another. ‑At the risk of being redundant, let’s just pay homage one more time to how the decisions we made earlier on, when implementing the vet clinic solution, allowed us to add in a potentially complicated new feature, email notifications and responses into the application. ‑While we had used mediator to transfer domain events within the FrontDesk application, this time we took advantage of message queues to help us move events back and forth between applications. ‑Using RabbitMQ’s API, we created three different queues that were specific to the cross‑application communications we needed. For example, a queue that the vet clinic public app could publish messages into for the FrontDesk application to retrieve so it could update the UI. ‑It’s also important to note that we leveraged existing tools like RabbitMQ and Papercut to perform certain tasks. In DDD, we would refer to these as generic domains. You’ve got to look under the covers to see how the code was making all the communication between the apps and the message keys possible, but without our domain model having to know about any of the details. ‑And then we shared some additional knowledge as we wrapped up the course. We talked about modeling practices like event storming and tools like MURAL. We talked about all of the new ideas that have evolved since we first published this course in 2014 and how they impacted this new version of the course and the sample application. ‑And we ended with some more wisdom from Eric Evans, to whom we are eternally grateful not only for bringing DDD to the software community, but also for spending time with us when we created the original course so that we could share his perspective and insights with you. ‑Like the end of a fireworks display when they shoot up many, many fireworks at once, we’re sharing here a lot of resources and links because of the great many topics we brought into this last module. There are two pages of links here to articles and videos and other Pluralsight courses, so you might want to pause the video to be sure that you see them all. ‑So, from me, Steve Smith, ‑and from me, Julie Lerman, thanks so much for taking this journey with us through Domain‑Driven Design Fundamentals.\n",
  "wordCount" : "97557",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2021-05-15T01:00:00+05:30",
  "dateModified": "2021-05-15T01:00:00+05:30",
  "author":{
    "@type": "Person",
    "name": "Sachin Sunkle"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/domain_driven_transcript_from_pluralsight/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Learnings in IT",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Learnings in IT (Alt + H)">Learnings in IT</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://gist.github.com/sachinsu" title="Gists">
                    <span>Gists</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/links/home" title="Useful Links">
                    <span>Useful Links</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Domain driven Design: Learnings
      <span class="entry-hint" title="Draft">
        <svg xmlns="http://www.w3.org/2000/svg" height="35" viewBox="0 -960 960 960" fill="currentColor">
          <path
            d="M160-410v-60h300v60H160Zm0-165v-60h470v60H160Zm0-165v-60h470v60H160Zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22q0 11-4.5 22.5T862.09-380L643-160H520Zm300-263-37-37 37 37ZM580-220h38l121-122-18-19-19-18-122 121v38Zm141-141-19-18 37 37-18-19Z" />
        </svg>
      </span>
    </h1>
    <div class="post-meta"><span title='2021-05-15 01:00:00 +0530 IST'>May 15, 2021</span>&nbsp;·&nbsp;459 min&nbsp;·&nbsp;Sachin Sunkle

</div>
  </header> 

  <div class="post-content"><p>Course Overview
Welcome to Pluralsight. My name is Julie Lerman, and this is Steve Smith. Together, we&rsquo;d like to welcome you to our course, Domain‑Driven Design Fundamentals. Steve is a trainer and architect with NimblePros and spends a lot of time helping teams write better code, faster. And Julie is well known in the DDD community for helping reluctant teams embrace domain‑driven design. In this course, we give you a strong foundation for learning how to build applications and microservices using domain‑driven design. DDD has proven to be a very effective approach for managing complex requirements. The original version of this course has helped many thousands of learners leverage domain‑driven design, and they have shared amazing feedback. Now, we&rsquo;ve updated the course and its sample application to reflect ideas and tools that have emerged since that first version. Some of the major topics that we&rsquo;ll cover include what are the essential ideas of domain‑driven design? What are the main patterns used in domain models? We&rsquo;ll also talk about how to break up concepts into smaller parts and how these smaller aggregates and contexts communicate with one another. By the end of this course, you&rsquo;ll know how to break down customer requirements into a maintainable domain model and structure a solution using domain‑driven design. Before beginning the course, you should at least be familiar with software development, ideally using C#. From here, you should feel comfortable diving into DDD and design patterns with courses on the DDD learning path and the design patterns learning path. We hope you&rsquo;ll join us on this journey to learn domain‑driven design with the Domain‑Driven Design Fundamentals course, at Pluralsight.</p>
<p>Introducing Domain-Driven Design
Introduction and Overview
Hi, this is Steve Smith ‑and this is Julie Lerman. Welcome to our course, Domain‑Driven Design Fundamentals. ‑We&rsquo;re looking forward to sharing our experience with DDD and how it&rsquo;s helped us and our clients. You&rsquo;re welcome to reach out to us online. ‑You can find me online at thedatafarm.com or on Twitter @julielerman. ‑And I&rsquo;m online at ardalis.com or on Twitter as @ardalis. ‑Eric Evans coined the term Domain‑Driven Design in his groundbreaking book with the same title published in 2004. Since then, other titles have followed, including great books expanding on the subject by Jimmy Nilsson and Vaughn Vernon and so many who are now also great experts at DDD. And there are also now a number of fantastic DDD conferences and even a well‑established virtual meetup. ‑There&rsquo;s definitely continued and renewed interest in Domain‑Driven Design as both the demand for and complexity of software continues to grow. Domain‑Driven Design is commonly referred to as DDD and even has its own Twitter hashtag, dddesign. Although DDD has been around for so long, it continues to be a great approach to building software that we both enjoy employing and sharing with others. And as more minds have gotten involved in DDD, it continues to evolve.</p>
<p>What to Expect from This Course and This Module
Domain‑Driven Design is a huge topic. Our focus will be on the developer perspective and the technical and coding aspects of DDD more so than architectural concerns. We&rsquo;ll start by talking about why we think you should even be watching this course. Next, we&rsquo;ll jump right into an existing solution so you can get a concept of what the code and the architecture of an application written using DDD practices looks like. Then we&rsquo;ll start digging into the big DDD concepts like modeling problems of the domain, what the various technical components of DDD are, and how you can use DDD to manage complex projects. Throughout the course, we&rsquo;ll use the existing solution so you can see how some of this process works. ‑With this in hand, we&rsquo;ll walk through extending the sample based on a new request from the client. Since this is a fundamentals course, we certainly don&rsquo;t expect to turn you into an expert by the end of it; however, you should be well on your way to understanding the value behind Domain‑Driven Design and how some of the practices can be employed to improve your success with complex software projects. Right now, if you&rsquo;re new to DDD, you don&rsquo;t even know what you don&rsquo;t know yet. However, once you&rsquo;re done with this course, you&rsquo;ll know more about DDD, but of course, you&rsquo;ll also realize how much more there is to learn. That&rsquo;s one of the great things about our industry. The more you know, the more you realize how much more there is you don&rsquo;t know. ‑In this module, we&rsquo;ll focus on the value of Domain‑Driven Design. You&rsquo;ll learn what the term represents and what problems DDD can help you with in your software building process. ‑Not only will we share the benefits of DDD, but we will be sure to highlight some of the potential drawbacks. Finally, you&rsquo;ll get a look at a small application that we&rsquo;ll be using throughout the course as you learn DDD.</p>
<p>Understanding the Value of Domain-Driven Design
Domain‑Driven Design focuses on the problems of the business domain that you&rsquo;re attempting to solve. Its a critical shift from decades of focusing on how to store your data and then letting that drive how the software is designed. But that workflow added a lot of unnecessary complexity to the task of building software. So why should you watch this course? Why should you care about learning Domain‑Driven Design. Steve and I have both been designing and developing software for a very long time. Without giving away our ages, we&rsquo;ve got over 40 years of experience between the two of us, and we&rsquo;ve both been very inspired by Domain‑Driven Design. In many ways, it aligns very naturally with ideas that we&rsquo;ve each come to from our own experience. It also takes these ideas and lays them out in a way that&rsquo;s not only illuminating, but it&rsquo;s repeatable. When Eric Evans wrote his book, his goal was to understand what was behind the successes he had achieved with large‑scale, complex software projects and what were the patterns. That&rsquo;s what he laid out in the book. ‑This is why we care about DDD, and we hope that you can gain from our experience, which is why we put together this course. DDD provides principles and patterns to help us tackle difficult software problems and even business problems. These are patterns that are being used successfully to solve very complex problems. The more we&rsquo;ve learned about DDD, the more we found these ideas aligned with the approaches we&rsquo;ve learned from our many combined years of experience. DDD provides us with a clean representation of the problem in code that we can readily understand and verify through tests. We developers live to code. When starting on a new project, we&rsquo;re eager to jump in and start coding so that we can build some software. But you can&rsquo;t build software unless you truly understand the client&rsquo;s needs. DDD places as much emphasis on not only comprehending what your client wants, but working with them as full partners through a project. The ultimate goal isn&rsquo;t to write code, not even to build software, but to solve problems. ‑You need to realize that nobody really wants your program. They want what it can give them. There&rsquo;s a famous saying in sales. Buy a quarter‑inch drill, they want to buy quarter‑inch holes. Your client&rsquo;s not interested in building software, but in being successful at their mission. Software provides a more efficient means to this end.</p>
<p>Gaining a High-Level Understanding of DDD
Domain‑driven design is for solving complex problems. Evans put a lot of thought into the subtitle of his DDD book and came up with Tackling Complexity in the Heart of Software. But DDD itself is a complex topic. To start with, we think it&rsquo;s helpful to look at it from a very high level. We call it the 10,000 foot view here in the US, but that&rsquo;s probably 3,048 meters to the rest of you. ‑One of the critical pieces of DDD is to encourage better interaction with domain experts. These are the people who live and breed the business or process or whatever you are targeting with the software you&rsquo;re planning to write. You may be thinking, but we already talked to them. Perhaps, but probably you&rsquo;re using your terms, not theirs, and maybe talking in the language of tables in a database rather than domain concepts. Or you may presume that after some standard requirements gathering, you can infer enough about the problem at hand to design the solution on your own. After our own history in the business of developing software, we know that that rarely ends well. DDD guides us to engage with the domain experts at much greater length and through much more of the process than many software teams are used to doing. ‑When talking with Eric Evans about this, he told us that you really need to cultivate your ability to communicate with business people in order to free up their creative modeling. Another core theme in DDD is to focus on a single subdomain at a time. Say you&rsquo;re asked to build software for a spaceship manufacturer. They describe their business tasks such as purchasing materials, engineering, managing employees, advertising their spaceships and share with you their dreams about mass producing spaceships when the market&rsquo;s ready. Each one of these tasks are in themselves a complex subdomain filled with their own specific tasks, terminology, and challenges, and those subdomains may have only minimal interaction between them. Many applications just try to do too many things at once, then adding additional behavior gets more and more difficult and expensive. With DDD, you&rsquo;ll divide and conquer. By separating the problem into separate subdomains, each problem can be tackled independently, making the problem much easier to solve. This lets us focus on the problem of employee management separately from the problem of sourcing materials for producing the spaceships. The term modeling is important in DDD and refers to how you decipher and design each subdomain. You&rsquo;ll learn much more about this as you progress through the course. ‑The final theme in our high‑level perspective of DDD is writing the code to implement each subdomain. The principle of separation of concerns not only plays a critical role in identifying the subdomains, but within each subdomain, we use it as well. Many applications spread the domain logic between the persistence layer and the user interface, making it much more difficult to test and to keep all of the business logic consistent. DDD applies separation of concerns to help steer you clear of this problem by focusing on the domain and not on details like how to persist data into a database or how to connect to a service in the cloud. Those become implementation details that you can worry about separately. While implementing these subdomains, the focus is on the subdomain, the problems of the subdomain you are trying to solve with your software. You don&rsquo;t get bogged down worrying about infrastructure concerns.</p>
<p>Exploring the Benefits and Potential Drawbacks of DDD
Domain‑Driven Design is a big commitment. While Steve and I have both chosen to leverage pieces of DDD as we learn more about the wider scope, one thing we&rsquo;re both confident about is that it&rsquo;s providing a lot of benefits to our work. Because DDD guides us to focus on small, individual, nearly autonomous pieces of our domain, our process and the resulting software is more flexible. We can easily move or modify the small parts with little or no side effects. It even lets us be more flexible with our project resources as we&rsquo;re building the software. ‑The resulting software also tends to be more closely mapped to the customer&rsquo;s understanding of the problem. DDD gives you a clear and manageable path through a very complex problem. When you look at the code, you can see that it&rsquo;s generally well organized and easily tested, and the business logic all lives in one place. Even if you don&rsquo;t use full DDD for a project, there are many patterns and practices that you can use by themselves to benefit your application. So keep watching, even if you don&rsquo;t think you&rsquo;ll need all of it. ‑We often describe DDD as a way to take big, messy problems and transform them into small, contained, solvable problems. But DDD is not a path for every project. It&rsquo;s real benefit is for complex domains. Even Eric Evans explicitly states that DDD isn&rsquo;t suitable for problems when there&rsquo;s substantial technical complexity, but little business domain complexity. Using DDD is most beneficial when the complexity of the domain makes it challenging for the domain experts to communicate their needs to the software developers. By investing your time and effort into modeling the domain and coming up with a set of terminology that&rsquo;s understood for each subdomain, the process of understanding and solving the problem becomes much simpler and smoother. ‑But all this comes at a cost. You&rsquo;ll spend a lot of time talking about the domain and the problems that need to be solved, and you&rsquo;ll spend plenty of time sorting out what is truly domain logic and what is just infrastructure. The easy example there is data persistence, or for the sake of our spaceship manufacturer, maybe it&rsquo;s how to communicate with an external service that helps to verify that potential buyers are properly vetted for space travel. ‑You&rsquo;ll have a big learning curve as you learn new principles, patterns, and processes. There&rsquo;s no question about that. DDD is a big topic and gaining expertise from end to end is a big commitment. This course doesn&rsquo;t aim to make you an end‑to‑end expert in DDD, but to give you a big step forward that will allow you to not only comprehend the concepts, but you&rsquo;ll gain a lot of new tools that you can use right away, whether or not you choose to dig further. And it&rsquo;s worth restating that DDD is not always the correct path for your applications. And it&rsquo;s helpful to keep in mind some of the scenarios where DDD is just going to be overkill. For example, if you have an application or a subdomain that&rsquo;s just a data‑driven app and doesn&rsquo;t need much more than a lot of CRUD logic, there&rsquo;s really no need to use DDD. It would be a waste of time and effort. ‑And be clear about the difference between complexity in your business domain and technical complexity. DDD is designed to help with complex domains. If your domain is simple, even if you have a lot of technical challenges to overcome, DDD still may not be the right path. For example, if you are writing a tic‑tac‑toe game for a touch screen with a new complex API, the complexity lies in the touch interactions of the two players on the screen. The domain itself is well known and just comes down to Xs and Os. Getting others to follow the DDD approach can also be a drawback. There may be some politics involved in this decision. It really depends on your team and your organization. We hope that another takeaway from this course will be to help you understand the concrete benefits of DDD, which you can show to your coworkers to help convince them.</p>
<p>Inspecting a Mind Map of Domain-Driven Design
In his DDD book, Evans included a really useful diagram of how many of the concepts and patterns of DDD are interrelated. Let&rsquo;s take a look at that mind map. ‑Evans refers to this as a navigation map, and it lays out all of the pieces of Domain‑Driven Design and how they relate to one another. We want you to see it so that you have a concept of the big picture, even though in this course we&rsquo;ll spend most of our time on a subset. We will be defining many of these terms later on in the course, so don&rsquo;t panic. We&rsquo;ve mentioned modeling the domain and subdomains a few times. Modeling is an intense examination of the problem space. Key to this is working together with the subject matter experts to identify the core domain and other subdomains that you&rsquo;ll be tackling. Another important aspect of modeling is identifying what&rsquo;s called bounded contexts. And within each of these bounded contexts, you focus on modeling a particular subdomain. As a result of modeling a bounded context, you&rsquo;ll identify entities, value objects, aggregates, domain events, repositories, and more and how they interact with each other. ‑In the image, there&rsquo;s more than just these subdomains, however. For example, there is a concept of an anti‑corruption layer, which allows subdomains to communicate with one another from behind their boundaries. The model also has notes for each element, such as free teams to go separate ways. This is something that can be accomplished once you&rsquo;ve identified the boundaries of each subdomain. Or avoid overinvesting in generic subdomains. That could be something like a credit card verification service that you could choose to use rather than building yourself. As you begin focusing on specific subdomains, another very important DDD concept surfaces, driven by the need for clear, concise communication. It&rsquo;s called the ubiquitous language. A simple definition of a ubiquitous language is to come up with terms that&rsquo;ll be commonly used when discussing a particular subdomain. And they will most likely be terms that come from the problem space, not the software world, but they have to be agreed upon so that as discussions move forward, there is no confusion or misunderstanding created by the terminology used by various members of the team. ‑We invite you to pause this video to look over this map and read the notes associated with the various elements and contemplate what they might mean. We&rsquo;ll revisit this throughout the course, and we hope that the map will make more and more sense as you work through the course.</p>
<p>Introducing Our Sample Application
Now we want to switch over and show you a relatively small DDD‑based solution that we&rsquo;ll be working on for the rest of the course. This app represents an appointment scheduling system for a veterinary clinic. It&rsquo;s &ldquo;small&rdquo;, but since DDD requires a certain amount of complexity to warrant its use, it&rsquo;s bigger than most demos you&rsquo;ll see in other courses or presentations. For this course, we decided that we would use a veterinary clinic management system because it has a decent amount of complexity, and that means that we can apply some of the DDD principles, but it also gives us an excuse to show off pictures of our pets. ‑And our friends pets too. We&rsquo;ve got a whole bunch of pet pictures from other Pluralsight authors in here, and they&rsquo;re all so cute. ‑We&rsquo;ve got Ben Franklin here from Michael Jenkins. We&rsquo;ve got Patrick Neborg&rsquo;s dog here, Sugar. Aren&rsquo;t these guys cute? And, of course, Julie&rsquo;s got Sampson. ‑Oh, my handsome boy. ‑And I&rsquo;ve got Darwin, the silly poodle. He was just a puppy when we recorded the first version of this course, and he&rsquo;s got a new friend, Rosie. Rosie is just a puppy. I guess every time I get a puppy we have to update this course. ‑So the idea behind this application is that if you&rsquo;re working at the front desk of a vet clinic and someone walks in, maybe they want to schedule an appointment, or the phone rings with someone who wants to schedule an appointment for their pet, the first thing you&rsquo;re going to do is look that client up, the person, in the system. ‑So the user starts by looking up the client, and from there, they can choose which of the clients, animals or patients, they&rsquo;re going to schedule. So here&rsquo;s Julie with Sampson. Here&rsquo;s Kim with Roxy. Next, the user is just going to click on an open slot in the schedule, which opens up the create appointment window. ‑Oh, Roxy, you&rsquo;re such a cutie. We can set up Roxy for a wellness exam with Dr. Smith. ‑Now notice before we save this appointment, it isn&rsquo;t yet confirmed. We&rsquo;ll get to that in a minute. So we save, and the appointment shows up. Now the complexity in this system comes into play when we have to do some checks for certain things. We want to make sure, for instance, that Roxy isn&rsquo;t already scheduled in one of the other rooms at this exact time. We also want to send an email notification to Kim to let her know that Roxy has this appointment scheduled. We&rsquo;ll add a link in the email the client can click to confirm. And in a real system, perhaps it would add it to their calendar of choice. The idea is to cut down on no‑show appointments for the clinic. ‑Of course, there are other features of this application. We&rsquo;re focused on the schedule right now, but we do need to be able to manage client data and manage their pet data, the clinic&rsquo;s patients, and things like that. Admins need to be able to manage doctors and rooms and appointment type since these all might change over time or from one clinic to another that uses the same software. But those are mostly CRUD tasks, which means we&rsquo;re just talking about adding and removing records and maybe making some edits without a whole lot of complexity. We&rsquo;ll talk about those tasks in a different compartment of the application than the schedule, which, of course, has a lot more complexity.</p>
<p>Exploring the Sample App&rsquo;s High-level Structure
So why don&rsquo;t we take a look at the structure of our app? This is a distributed application built with ASP.NET Core on .NET 5. It&rsquo;s running Blazor WebAssembly in the front end, which is talking to APIs running on ASP.NET Core. There are three different web apps that the system uses. Two are used internally by client staff, and then there&rsquo;s the public‑facing website for the clinic, which is needed for the confirmation links that users will click. The two clinic apps, Front Desk and Clinic Management, each have their own database, and all three apps communicate with one another using messages transported by RabbitMQ. Like I said, it&rsquo;s maybe a little more complicated than most demos. We want the sample app to be something you spend some time with and extend as part of your experience with this course, so please be sure to check it out and run it locally. It should just work if you have Docker installed. ‑Now let&rsquo;s take a quick look at how the code is organized. The full solution is hosted on Steve&rsquo;s GitHub account. Here&rsquo;s the URL, but we&rsquo;ll definitely also have that URL in the resources slides at the end of this module. PLURALSIGHT DDD FUNDAMENTALS is the name of the root of our GitHub repository. In here, you can see the three web apps, ClinicManagement, FrontDesk, and the public‑facing website, VetClinicPublic. ‑There&rsquo;s also a folder for SharedKernel, which we&rsquo;ll talk about a little bit later. The first app we&rsquo;re going to focus on though is the FrontDesk app. ‑Our main focus for this course is going to be the front desk application and its scheduling functionality. Looking at the solution, you can see it&rsquo;s broken up into seven projects, which seems like a lot, but three of them are just there to support Blazor The server‑side code, where our domain model resides, is just three projects. ‑The most important project is FrontDesk.Core. That&rsquo;s where the domain model is defined. All of the app&rsquo;s infrastructure needs, like how it talks to its database or RabbitMQ, are kept in the FrontDesk.Infrastructure project. In the front end, in this case, ASP.NET Core and its API endpoints, is in the FrontDesk.Api project. This is the front end from the server&rsquo;s perspective. The system is using a clean architecture design which you may also hear referred to as onion architecture or ports and adapters. I cover this in my N‑Tier Applications in C# course, and I have a popular GitHub solution template you can use to set up a new project using this approach. ‑With clean architecture, the project dependencies all point towards the domain model in the core project, so both the API and infrastructure projects have a dependency on Core. Core should never depend on infrastructure concerns, but it can leverage NuGet packages that don&rsquo;t couple it to infrastructure concerns. ‑In this case, it&rsquo;s using a couple of utility packages, as well as the SharedKernel package that&rsquo;s shared by other apps. We&rsquo;ll talk more about SharedKernel later. The ClinicManagement app uses the same kind of structure and also has a Blazor front end because why not? It&rsquo;s pretty much just CRUD, so we don&rsquo;t focus too much on its domain model, but it is a distinct app with its own database, and we do need to build into our design a way to propagate changes from it to the FrontDesk app. ‑Finally, there&rsquo;s the public web app. It&rsquo;s just one project, and it&rsquo;s pretty simple. This is responsible for sending emails, which this demonstration fakes using a tool called PaperCut, and it hosts the link that clients click to confirm appointments. The public web app also needs to communicate with the front desk, but it doesn&rsquo;t have a database of its own, nor does it access any of the other app&rsquo;s databases. ‑That&rsquo;s it in a nutshell. We&rsquo;ll demonstrate the confirmation emails and more complex use cases later in the course. But for now, that should give you an idea of how the ideas we&rsquo;re sharing are put into practice.</p>
<p>Review and Resources
So, as we&rsquo;ve talked about, creating applications is not about writing code, even though often that&rsquo;s a really, really fun part for us developers, but it&rsquo;s about solving problems. And the more complex the problems are, the more difficult the whole project becomes. So Domain‑Driven Design gives us some great patterns and practices for attacking these more complex problems, and they get us to really focus on interacting with the domain experts, breaking apart our domain, and working on things in smaller units and in a very organized fashion. And in the end, it gives us a much more efficient and effective path to success in creating our solutions. ‑Yeah, we talked about some of the benefits that Domain‑Driven Design provides, as well as some of the drawbacks. Specifically, your team just needs to know Domain‑Driven Design, and your domain experts need to be available to work with you on these systems. Domain‑Driven Design is a big topic. We looked at some of the different concepts that are involved in DDD, and we&rsquo;re going to look at a lot more of them in depth through this course. But remember that this is just an introduction to Domain‑Driven Design, so some of these aspects that are a little more advanced, we&rsquo;re not going to be able to cover with a great deal of depth. ‑In the next module, we&rsquo;ll start exploring the process of discovering and modeling domains. Here are some links to resources that we mentioned this module and others that we find relevant. ‑This is Steve Smith ‑and this is Julie Lerman, and thanks for watching Domain‑Driven Design Fundamentals.</p>
<p>Modeling Problems in Software
Introduction and Overview
Hi. This is Steve Smith. ‑And this is Julie Lerman. Welcome back to our Domain‑Driven Design Fundamentals course. This module will focus on modeling problems in software, and you&rsquo;re welcome to reach out to us online. You can find me online at thedatafarm.com or on Twitter @julielerman. ‑And I&rsquo;m at ardalis.dot com or on Twitter as @ardalis. In this module, we&rsquo;re going to take a look at how we decompose the model for the veterinary office domain. We&rsquo;ll talk about the importance of domain experts in DDD. ‑We&rsquo;ll drive this point home with a play in which we&rsquo;ll consider a few different scenarios for how the project might have gone, which should provide you with examples of ways to involve the domain expert in the design of the system. ‑Next, we&rsquo;ll talk about the domain model and some of the elements that typically are found in this part of the application. It&rsquo;s important to separate the core domain model from related subdomains, and we&rsquo;ll talk about how bounded contexts can help us accomplish this separation. ‑And then we&rsquo;ll wrap things up by talking about ubiquitous language and how this seemingly small thing with a big name can have a large impact on your model, your design, and, of course, your application. So let&rsquo;s get started.</p>
<p>Introducing Our Domain
Steve and I both have a love for animals. In fact, Steve&rsquo;s wife, Michelle, is a veterinarian. In thinking about a sample application we could use for this course, we wanted to use something complex enough to justify the use of DDD. The veterinary clinic management domain made a lot of sense, allowing us to leverage our own experience as pet owners, as well as having a domain expert available in the form of Michelle, or Dr. Smith as we&rsquo;ll be referring to her in the course. ‑There are many different pieces involved in managing a typical veterinary clinic. The staff needs to be able to schedule appointments. They likely need to schedule their own working shifts as well. They need to be able to invoice for their services and collect payments and, in many cases, send out bills. They&rsquo;ll also need to be able to store and retrieve medical records, as well as work with external labs and specialty clinics. Most veterinary practices also have products for sale and may need to track inventory, as well as sales. And there are often follow‑ups and reminders that may need to be sent by mail, phone, or perhaps email. There is certainly sufficient complexity in this domain to merit the use of domain‑driven design.</p>
<p>Planning Ahead to Learn About the Domain
Of course, it&rsquo;s a good idea to speak with a domain expert about the systems requirements before diving in and beginning to code a solution. Whether you&rsquo;re tasked with building a full system or just adding a new feature, an overall understanding of the client&rsquo;s business is a critical start. Of course, it&rsquo;s just the beginning. It&rsquo;s also important that you have a continuous conversation with the domain expert throughout the development of the system. The simple system we showed in the last module needs some updates. So we&rsquo;re going to share some conversations we had with the domain expert to help validate our initial assumptions. ‑An important part of this conversation is going to be identifying the things that aren&rsquo;t included in the scope of the project or feature. To that end, we&rsquo;ll try to identify subdomains within the overall problem domain and then determine whether or not we need to concern ourselves with these subdomains at the moment. If not, we can consciously remove them from the scope with the customer&rsquo;s approval and avoid confusion and possible missed expectations later. To get started though, we do want to know a little bit about the big picture.</p>
<p>Conversation with a Domain Expert: Exploring the Domain and Its Subdomains
As Julie already mentioned, my wife, Michelle, is a veterinarian. In addition, she has a deep understanding of software development processes, having successfully managed software teams at NimblePros and Teller. She has graciously agreed to play the role of domain expert for our course. In real life, she knows quite a bit about software and technology, but for the purposes of this course, she&rsquo;s playing the more traditional role of a veterinarian with little background in software development. Hi Dr. Smith. Thanks for your time today. Julie and I would like to learn more about what goes on in your veterinary clinic. Can you share some of the big picture processes involved in the day‑to‑day operation of a clinic? ‑So the biggest thing is probably scheduling patients and keeping track of them once they arrive. Clients will usually call ahead unless it&rsquo;s an emergency, and then we need to get them entered into our system. Of course, surgical procedures need to be scheduled in advance. And when they&rsquo;re here, we need to record information about the patient, our observations, notes, and diagnoses. ‑Wow, that&rsquo;s quite a list. Probably not what you were dreaming about when you started vet school. So many of these are all secondary to the core reason for being a vet, keeping pets healthy. And, I think it sets you apart from other businesses that have to manage clients and schedule appointments. But, you can&rsquo;t run a business without it. Is that all? ‑So when the appointment is over, they also have to pay. So most of the time that&rsquo;s done immediately, but we do have some billing that&rsquo;s done after the fact, and when they&rsquo;re checking out, they may need to buy some things for their pets, toys or prescriptions, or maybe some prescription food as well, and we need to track all of that as well. For some of the lab work, we need to send that out and get the results back, and some prescriptions go out to outside pharmacies as well. So we need to manage all of those through the system. ‑Okay, so payments, billing, point of sale, labs, prescriptions, anything else? ‑I think that&rsquo;s about it. Oh, we also use the system to note which staff members are working when, and right now our website isn&rsquo;t integrated into the system at all, but we were thinking it would be great if clients could view information about their pets, maybe schedule appointments, look up prescriptions, and we can make updates to the site without having to go through our computer contractor. ‑Okay, great. So, we&rsquo;ll add staff scheduling and content management to the list. I don&rsquo;t want to assume you know what a content management system is. We also call it a CMS, you might have heard of that. It&rsquo;s a type of software system that lets the owner, that&rsquo;s you, be in charge of the information that&rsquo;s displayed. A blog is a really good example of a CMS that can be managed by its owner. ‑I have a blog, so I understand exactly what you mean. Something like that would be really great for us to have so we can make updates right in‑house. But it&rsquo;s kind of like a blog, especially something that&rsquo;s more professional than my personal blog. ‑Cool. So I think that&rsquo;s probably enough of a big picture view for us to consider at the moment. Now let&rsquo;s try and think about which of these are connected to the others so we can determine which ones we need to worry about for our application&rsquo;s needs. ‑We started with this fairly complicated view of the overall problem domain, but now we&rsquo;ve segregated these into different areas and we know which ones we need to focus on right now and which ones we can treat as external collaborators. ‑Determining where we can safely draw the line between what problem our immediate application needs to solve and what is outside of its area is certainly helpful. It&rsquo;s also important that this be well understood and communicated among everyone involved in the project.</p>
<p>Conversation with a Domain Expert: Exploring the Scheduling Subdomain
Now that we have a better understanding of the domain and the other subdomains around the scheduling system, it&rsquo;s time to focus more on understanding the scheduling subdomain. We had another meeting with Dr. Smith, and you can listen in. ‑Hi guys, welcome back to the clinic. How are things going with the computer system? ‑We&rsquo;re making good progress, and now we&rsquo;re ready to look at another more complex feature. ‑We know there&rsquo;s a lot that goes on here, but today we want to focus on appointment scheduling because we realize we&rsquo;re still a little confused about it. ‑Since we&rsquo;ve both owned pets for a long time, we figure we probably have a rough idea of what&rsquo;s needed, but it&rsquo;ll be good to talk through it with you. Do your patients usually schedule their appointments over the phone? ‑Okay, so yeah our patients aren&rsquo;t usually involved in the scheduling. Usually, it&rsquo;s the clients that call in for appointments for their pets. And yeah, usually it&rsquo;s on the phone or in person when they&rsquo;re checking out after an office visit. Julie and I talked about that earlier. ‑Yeah, so Steve, the patients are the animals, and the clients are the people or the pet owners. ‑Right, right, of course, that&rsquo;ll be important to get right. ‑Remember, we talked about that. So the client needs to make an appointment for their pet. They&rsquo;ll talk to a staff member who will schedule the appointment. What kind of information do they need in order to do that? ‑So that really depends on the type of appointment. It could be an office visit, or it could be a surgery. Why don&rsquo;t we talk about the office visits first. If it&rsquo;s just for a wellness exam, that&rsquo;s pretty standard. They just need to choose an available time slot with one of the doctors. Some of the visits can be scheduled with just a technician though, so if they need just their toenails trimmed, for example. ‑Or painted, like Samson. He gets his toenails painted. ‑Does he really? ‑No, I&rsquo;m joking. I just want to, pink. ‑I&rsquo;m sure he&rsquo;d love that. Okay, so office visits might be an exam requiring the doctor or another kind of appointment that only requires a technician. ‑Right. We also have to worry about our rooms too. We only have five exam rooms available, and we try not to overbook. We don&rsquo;t like for our clients to have to wait too long in the reception area, especially if we have a lot of cats and big dogs out there at the same time. It makes them all really nervous. ‑What about other staff? ‑So our technicians will float between the exam rooms and other areas of the clinic as needed, except, of course, for those scheduled technician visits. We do have a schedule for the staff, but it&rsquo;s separate from how we schedule our appointments. ‑Okay, so what about the surgeries? ‑Well, if it&rsquo;s a surgery, those are only scheduled on certain days, and they require that the operating room be available, as well as some recovery space in the kennel area. It also depends on what kind of surgery or procedure we&rsquo;re going to be doing. Something simple like a dental cleaning takes less time and fewer people than a caesarean section for a bulldog. ‑Okay, so an appointment is either an office visit or a surgery. Office visits happen in the exam room; surgeries require the operating room and recovery space. Is that right? ‑Right. And depending on the reason for the visit or the surgery, different staff might need to be involved. ‑So we&rsquo;ll probably want to have separate classes for appointments and surgeries. ‑Classes? No, we refer our clients to obedience and puppy preschool classes at other facilities. We don&rsquo;t actually schedule any of those in the clinic themselves. ‑I&rsquo;m sorry. That&rsquo;s a software term. In software, we have different classifications of concepts in the program, which are called classes. I&rsquo;m just getting ahead of myself here. Sorry. ‑Don&rsquo;t worry. We&rsquo;re not going to make you learn our software terms. Steve and I will try to have a little bit more self control with that. We do want to make sure we&rsquo;re all speaking the same language when it comes to concepts in the application though. ‑Okay, so I have another quick question. Do we have to worry about multiple staff members scheduling appointments at the same time? ‑No, there should only ever be one person doing the scheduling at a time, although I could see if we grew in the future that could change. But I don&rsquo;t think that&rsquo;ll happen in the next couple of years. Okay, then we don&rsquo;t have to worry about the rare occurrence of two people creating a conflict if they&rsquo;re trying to schedule an appointment for different patients in the same room or with the same doctor. That&rsquo;ll keep things a lot simpler. And we need to know before an appointment if certain resources are available, like rooms and doctors. And then if they are and we want to schedule the appointment, then we need to be able to book the doctor, the room, and any other resources. Hey, is it okay if we refer to doctors as resources? ‑Sure, that makes sense. You know, I think it makes sense to use the term resources to refer to the doctors, the rooms, and the technicians since those are all things that can affect whether or not an appointment can be scheduled. But remember, sometimes it&rsquo;ll be just a vet tech in a room, and other times it might be the doctor in the room, but sometimes you might need the doctor, the technician, and a room. ‑Wow, this is a lot more complicated than we&rsquo;d realized, but it&rsquo;s interesting. This is going to be cool to model in the application.</p>
<p>Reviewing Key Takeaways from Meeting with Domain Expert(s)
Some of the things we learned in that initial high‑level discussion with the domain expert included the fact that patients and clients are not the same thing to a veterinarian. ‑Yeah, that&rsquo;s pretty obvious in hindsight. But in most other medical professions, it is the patients who make appointments and pay the bills. It&rsquo;s good we were able to get on the same page with the customer on that early on in the process. ‑I think it helped Dr. Smith put some of the processes she uses into explicit terms that we could program against also. A lot of times just describing the process to someone who is unfamiliar with it can really help improve the understanding of it. It&rsquo;s like that idea that when you have to teach something to someone else, it makes you learn it a lot better. Listen to what Dr. Smith had to say at the end of our conversation about this. ‑Yeah, I never really thought about the details of how we do some of these things since it&rsquo;s just something we do, and we don&rsquo;t really think about it. Being more explicit about what the rules are that determine how we do are scheduling could help us avoid some of the occasional scheduling problems we&rsquo;ve had. This is going to be great. ‑We also need to remember not to use too much programmer jargon, especially when there are programming terms that might have a different meaning in the customer&rsquo;s domain. ‑I agree. It&rsquo;s a little early for us to be worrying about how things might end up looking in the code anyway. At this stage, the main focus is on understanding the domain. We&rsquo;ll get to building the software soon enough. But first, we want to make sure we know what problem it&rsquo;s going to be solving. One of the most important things we can do as we explore the problem with the domain expert is to try and make their implicit knowledge about the process they use now explicit. Once we&rsquo;re able to capture the process and its rules and exceptions with some detail, we can start to work on modeling a solution using this information. Building software is hard. One of my favorite sayings is as software developers, we fail in two ways. We build the thing wrong, or we build the wrong thing. By making sure we understand what the customer needs and, of course, working closely with the customer throughout the development process, we can dramatically reduce the likelihood of the second kind of failure, which is much harder to fix typically. ‑Hey, Steve. I like the way you quote yourself here, but it really is a great quote.</p>
<p>Taking a First Pass at Modeling our Subdomain
After talking to Dr. Smith about how appointments work, we&rsquo;ve identified a few high‑level elements of our model. The central concept in this application seems to be the appointment itself. Typically, an appointment is scheduled by a client for a patient. Booking an appointment often requires an exam room and a doctor, but may involve other resources. Appointments might be for office visits or vaccinations, or they might be surgeries, which are a separate kind of thing entirely with their own rules which involved different kinds of procedures. Surgeries require different resources too, like operating rooms and recovery rooms. ‑That&rsquo;s a pretty good high‑level view of the model we have so far for the appointment management part of our application. I think it&rsquo;s worth noting that some of the concerns of this application are going to also play a part in other subdomains. For instance, I&rsquo;m pretty sure we&rsquo;re also going to be working with clients and patients in a lot of the different parts of this application. ‑Yeah, I think it&rsquo;s time we introduce the idea of bounded contexts.</p>
<p>Using Bounded Contexts to Untangle Concepts that Appear to Be Shared
As you develop your model, remember to identify its bounded context. That is, where is this model valid? If you don&rsquo;t put boundaries around your model, eventually, pieces of it will be used where they don&rsquo;t fit. Concepts that make sense in one part of the application may not make sense in another, even if they have the same name and sometimes even if they literally refer to the same thing. ‑For example, as we built out the appointment scheduling portion of this system, we needed to know some very basic information about clients. But in the context of appointment scheduling, these are very simple concepts with little behavior beyond their names. However, in the billing context, we&rsquo;ll want to include contact and payment information for clients, but that&rsquo;s information we don&rsquo;t care about back in the appointment scheduling context. If we try to reuse the same exact client model in multiple places, it&rsquo;s likely to cause inconsistent behavior in our system. ‑That&rsquo;s right. For instance, we might decide to include some form of validation on clients to ensure we have enough information to bill them. If we&rsquo;re not careful, that validation might inadvertently prevent us from being able to use clients to schedule appointments, which certainly isn&rsquo;t the desired behavior. Maybe the billing system requires that clients have a valid credit card in order to save changes for them, but it wouldn&rsquo;t make sense for a lack of a credit card to prevent us from saving an appointment for a client in the appointment scheduling system. In this example, we have two contexts, but the boundaries between them are blurred and overlapping. Eric Evans notes that models are only valid within specific contexts. Therefore, it&rsquo;s best to explicitly define the context within which a model applies. We should be able to avoid compromising the model within this context, keeping it strictly consistent within these bounds and avoiding distractions or confusion from outside issues. ‑Once we explicitly define our bounded contexts, we can easily see whether or not we have elements of our model that are trying to span multiple contexts. In this example, we&rsquo;d want to keep a simple view of a client in the appointment scheduling up and a richer version of the client with contact and billing information in the billing context. We would define these two views of a client in two separate classes, and they will most likely live in separate applications. In fact, Evans recommends that bounded contexts maintain their separation by giving each context its own team, codebase, and database schema. ‑While this is ideal, in many real‑world apps, we need to work on systems where this level of separation is not present, usually due to resource constraints or for political reasons within the organization. Remember though, if you have multiple contexts, you&rsquo;ll want to keep them bounded. And one way to maintain this separation is to keep their data, code, and team members distinct from one another, although in real world, I&rsquo;ve never seen something with that level of separation. ‑Yeah, but I think even if it&rsquo;s not possible to literally do that with your company and your team, just having that concept in mind really helps in your brain have that idea of separation. ‑I agree. I know that just thinking about the fact that these things ought to be separated and trying to figure out a way to do it means that even if you can&rsquo;t get to the ultimate level where everything is is completely separate, you can still introduce separations through things like namespaces, separate folders, separate projects, anything you can do to make it clear that these are different contexts that shouldn&rsquo;t be sharing too much information. ‑You know, I think that&rsquo;s also really important point about this course in general and DDD in general. For me, it&rsquo;s really hard to think of all of these things we&rsquo;re learning as hard and fast rules, like you have to do it this way or you&rsquo;re not doing it right. I like to see all of this as really good guidance. So, you know, it helps me keep my eye on the prize, and when there&rsquo;s places where I can&rsquo;t truly achieve exactly what DDD kind of directs me to do, you know, I&rsquo;m using my own experience, my own intelligence to make decisions about how to do things, and I&rsquo;m letting DDD guide me in a lot of scenarios. ‑Sure. And some of these ideals, I think of like 100% test coverage. It&rsquo;s almost impossible in most real‑world applications to achieve 100% test coverage. But just because that ideal is not something you can ever achieve doesn&rsquo;t mean that you shouldn&rsquo;t strive for more test coverage. ‑Yeah, yeah, totally, totally agree with that.</p>
<p>Conversation with Eric Evans on Subdomains and Bounded Contexts
When learning about DDD, most of us have a hard time understanding how subdomains and bounded contexts are different. We asked Eric Evans about this and got some great insight. He explained that a subdomain is a view on the problem space, how you&rsquo;ve chosen to break down the business or domain activity, whereas a bounded context represents the solution space, how the software and the development of that software has been organized. Quite often, these will match up perfectly, but not always. ‑Eric helped us understand this further with the example of a room that you want to cover with carpeting. The room is the problem space, so it&rsquo;s like a subdomain. You could install a wall‑to‑wall carpet that matches the shape of the room perfectly. This would be like when the subdomain and the bounded context encompass the same thing. But other times you might just use some area rugs to cover the floor, and the area rugs solve the problem. They cover the part of the floor where you walk, and you don&rsquo;t have to worry about cold feet in the winter. And that&rsquo;s a scenario where the area rugs are like bounded contexts that don&rsquo;t match the subdomain, but they solve the problem even though they&rsquo;re not an exact match to the shape of the room.</p>
<p>Introducing Context Maps
If your organization has multiple bounded contexts, and ideally these are separated, there can be confusion when the different teams are talking to one another. Again, DDD focuses at least as much on effective communication as it does on anything specifically related to the code we produce. Evans recommends using context maps to visualize and demonstrate to all teams where the boundaries between their context lie. ‑Think about a complex topographical map. It will frequently include a legend, like the one shown here, in order to explain what each of the lines and symbols on the map mean. However, this legend is only valid within the context of the map with which it appears. Trying to use this legend on another map would be confusing at best. ‑A good first step for an existing application is to create a map that shows how things are. Remember that the names of your contexts are also important as you&rsquo;ll refer to them frequently when discussing different parts of the application. It may be that things are not as separate as they should be, and that&rsquo;s worth noting. If you have separate teams responsible for different contexts that share resources, it&rsquo;s important that each team understands which aspects of the application they can change on their own and which are shared dependencies they&rsquo;ll need to coordinate with other teams to avoid breaking things. If we look at these two sets of concepts, we can see some obvious overlap. For one thing, Client appears in both contexts, but we know that for appointment scheduling we really only care about the client&rsquo;s name, whereas in the billing system they&rsquo;ll want additional information like address and payment details. However, although the details involved vary, we know that Mr. Jones, the client on the left, is the same actual person as Mr. Jones, the client on the right. However, we also have a concept of notifications on both sides, and in this case, they&rsquo;re referring to different things. On the left, we&rsquo;re talking about sending a notification when an appointment is booked as a reminder, and on the right, we&rsquo;re talking about notifying the client that their payment was received or perhaps that it&rsquo;s past due. ‑Especially in smaller organizations, it&rsquo;s common to have one team responsible for several contexts of the same overall application. In such cases, it&rsquo;s also common for the team to use a single codebase for the bounded context that they&rsquo;re working with and store it in a single repository, such as GitHub. Usually, there will also be a shared database. As we&rsquo;ve already noted, this is not ideal since it makes it much more difficult to maintain the boundaries between the separate contexts. ‑Part of creating a context map involves explicitly identifying its boundaries. If we try to draw the boundaries around these two bounded contexts, we can see there are now several resources that belong to each bounded context. This isn&rsquo;t ideal if the two contexts really are meant to be kept separate. ‑In the ideal case for a large complex system, we would have bounded contexts like these, with their own teams, codebases, and database. For instance, on the left, we have an appointment scheduler application. It&rsquo;s being worked on by Team Awesome, and they&rsquo;re storing all of their code in their own repository called vet‑app‑sched. And, of course, this application has its own database. This team is free to change anything they want with their model or any other part of their system without worrying about breaking anything outside the boundaries for the team on the right, which is working on a billing system, and their team has decided to call themselves Team Ultimate, store their code in a repository called vet‑billing, and, of course, using their own database. By having this separation, this can greatly increase team velocity and reduce integration bugs. ‑Of course, you&rsquo;re probably wondering how the two systems will interoperate. There are a number of patterns that can be applied to enable this kind of integration. We won&rsquo;t be covering all of them in this course, but one question that frequently comes up is how to share cross‑cutting concerns like blogging and shared abstractions such as people names that are used by multiple bounded contexts. For this scenario, a common approach is to designate these shared concepts or resources as what we call a shared kernel. Team Awesome and Team Ultimate agreed to share the subset of the domain model. Since they&rsquo;re sharing it, they also agree not to change it without coordinating with the other team first. Frequently, the shared kernel will either be a part of the customer&rsquo;s core domain, or some set of generic subdomains, or even both, though it could be any part of the model that both teams require. Using a shared kernel is a tradeoff between code reuse and consistency and the overhead involved in integrating changes to the shared kernel across multiple teams and bounded contexts. It works best when the shared model is relatively stable.</p>
<p>Addressing the Question of Separate Databases per Bounded Context
The concept of having separate databases for each bounded context often throws people for a loop. But with the advent of microservices, which also, by definition, each have their own database, teams are beginning to get more accustomed to the idea. Here&rsquo;s what Eric Evans said to us when we talked with him about the problems created by trying to share a database across teams. &ldquo;If you&rsquo;re in a company where you share your database and it gets updated by hundreds of different processes, it&rsquo;s very hard to create the kind of models that we&rsquo;re talking about and then write software that does anything interesting with those models.&rdquo; Given that sharing a database across bounded contexts is really not a great idea, then we have another important question. ‑Another question that comes up often is how to sync data between the individual databases that are tied to each of the bounded contexts. Some different patterns you can use are publisher/subscriber, commonly referred to as pub/sub, and two‑way synchronization. Pub/sub is definitely simpler and preferable when you can manage it. You can use different implementations like message queues, database processes, batch jobs, or synchronous API calls. It&rsquo;s really up to you how you want to design your synchronization between bounded contexts. The point is just that you don&rsquo;t get the integration for free from using a shared database.</p>
<p>Specifying Bounded Contexts in our Application
We talked with Eric again to get his perspective on defining context boundaries. Some of the key points he shared were that first, it&rsquo;s important to understand that it&rsquo;s never a simple task whether you&rsquo;re new to it or not. And he&rsquo;s seen stumbling blocks of all sorts. The most common is not having a clear enough context boundary, so the effort of applying DDD isn&rsquo;t clearly separated from other tasks related to building software. ‑He also reminded us that the bounded context is such an essential ingredient that is probably the biggest stumbling block. And it&rsquo;s not often one that an individual on a project can usually addressed by themselves. It kind of has to be dealt with at the team level or even the organizational level. In our application, we&rsquo;ve organized the solution to make it clear where the boundaries are between our contexts. The main area that we are currently focused on is the appointment scheduling bounded context. ‑We&rsquo;ve identified two other bounded contexts that are involved in the overall application or will be eventually. For instance, it&rsquo;ll be important for users to be able to manage clients and their patients. The staff of the clinic also needs a way to manage their schedules so they know who&rsquo;s working on different days. We&rsquo;re referring to these two bounded contexts as client patient management and resource scheduling. ‑We also have a few parts of the application that are common to several bounded contexts. These are cross‑cutting concerns that we have consciously chosen to share. In DDD, we isolate such code into its own package referred to as a shared kernel, and it&rsquo;s worth noting that a bounded context does not always mean a separate application, even though we&rsquo;ve identified several different bounded contexts. ‑It&rsquo;s also a great opportunity to consider packaging logic up into microservices. Do keep in mind, however, that there&rsquo;s not always a 1:1 alignment between bounded contexts and microservices or applications. Also, let&rsquo;s not forget that our application will definitely need a front end.</p>
<p>Understanding the Ubiquitous Language of a Bounded Context
We&rsquo;ve mentioned already that an important part of DDD is an emphasis on effective communication among the stakeholders in the project. And remember, if you&rsquo;re a programmer, count yourself as one of the stakeholders in whatever you&rsquo;re working on since you certainly have a stake in its success. The language we use to describe the problem and how we choose to model it is key to the shared understanding we want to have with our domain experts in order to be successful. Having a single, shared, ubiquitous language helps avoid unnecessary confusion and translation within the team building the software and is one of the fundamental practices of Domain‑Driven Design. And when I talk about the team building the software, I don&rsquo;t just mean the programmers. I mean the whole team, including the business people that are deriving what the software should do. The discovery of the Rosetta Stone allowed us to unlock several different languages by showing the same message in three different texts. We don&rsquo;t want to have to have a Rosetta Stone or any other sort of tool to help us translate between what the business is talking about and what the programmers are talking about. We want to make sure that everyone is speaking the same language the whole time so that translation is unnecessary. ‑Think about if you&rsquo;ve ever used an online translation tool to round trip a sentence. You can run into similar communication issues in your application if you&rsquo;re constantly having to translate to and from the domain expert terms or the programmer&rsquo;s terms. Here&rsquo;s an example of a user story for a sample system about creating appointments. ‑We have a lot of developer friends in Nigeria, so I thought it would be fun to try out Igbo for our translation. We used a website to translate between English and Igbo a few times, and in the end, the user story has changed just enough to create confusion. Translation software is pretty good these days, and we were hoping for a more humorous result, but according to animal experts, it&rsquo;s close, but not the same as a veterinary technician. ‑But the point here, of course, isn&rsquo;t just relating to different international languages, but to the different languages spoken by business experts and programmers. ‑Incidentally, a great practice when you&rsquo;re discussing your system requirements with customers is to always try and explain back to them what you think it is they want the system to do so they have an opportunity to correct your understanding of what they think they just told you. ‑Definitely. Remember, one of the key benefits of using a ubiquitous language is that all parties can understand it without having to perform any translation. This means when you show a test or some code to a domain expert, you don&rsquo;t have to explain that in the system you call something an animal when the domain expert calls it a patient. ‑Evans cautions that a project faces serious problems when it&rsquo;s language is fractured. When domain experts stick to using their jargon while the technical team members have their own language tuned to discussing the domain terms in the design, translation errors will manifest as software bugs. Neither the customers nor the developer&rsquo;s language is sufficient for all parties to discuss the application effectively. What is needed is a shared common language that incorporates and uses terms defined in the domain model. The use of this language must be ubiquitous, and the more the language is used, the more will force deficiencies in the model into the open. ‑And by ubiquitous, we mean it must be used everywhere within the bounded context. The vocabulary of the language includes the names of model classes and prominent operations. The team should use these common terms in code, in diagrams, on the whiteboard, in design documents, and especially when discussing the system. ‑Yeah, pretty much ubiquitous means everywhere, all the time. Even in that one email you&rsquo;re sending off to another developer, stick to using the terms that you&rsquo;ve agreed makes sense for this bounded context.</p>
<p>Conversation with a Domain Expert: Working on our Ubiquitous Language
You&rsquo;ve heard some of our conversations that helped lead to a ubiquitous language for the scheduling app. There was another important one that happened early on between Michelle and me that we want to share with you now. ‑Pay attention to not only the clarification of the terms, but also to the fact that Julie and Michelle are equal partners in this conversation. Although Julie is trying to lead the conversation towards the goal of identifying the correct terms, she&rsquo;s careful not to make assumptions about Michelle&rsquo;s domain. ‑So Michelle, last time you and Steve and I got together to talk, Steve and I have been working on just kind of fleshing things out and planning things, and I realized that we had some confusion over some of the common terms, like things that, as real pet owners, we would kind of assume the terms are, but then when we&rsquo;re thinking about business and software, we&rsquo;re thinking of the terms a little differently. So I was wondering if we could just sort that out with you so that we&rsquo;re all on the same page and using the same terms and using terms that none of us have to stop and think about what we&rsquo;re talking about. We&rsquo;ll always know what they mean. ‑Sure. ‑The first thing is we have these clients, those are the people who own the pet. So when thinking about the software and business, we think of them as clients, but kind of in the real world, and me, I have a pet, I go to the vet all the time. I think of myself as a pet owner. So what do you refer to those people who bring the pets, pay their bills, call and make the appointments, etc? ‑Most of the time, I mean those would be listed as as clients. ‑Okay, so you do call them clients. You don&rsquo;t worry about calling them owners, and of course, it sounds kind of weird to say I own a dog, right? ‑He kind of owns you. ‑Yeah, that&rsquo;s more like it. You&rsquo;re the pro you know. So then what about that dog, like are they patients, are they pets, are they clients? What do you refer to the pets as? ‑So for the purpose of the medical record, we refer to them as the patient. ‑Okay. So it would be client and patient. ‑Exactly. And actually in veterinary medicine they talk a lot about this triad, the veterinary client/patient relationship, where all three are really important in that. ‑Okay. So those are actually terms that are commonly used in your industry. Industry, that sounds so weird, but with that. Cool. Alright, so the next one we were also going back and forth on was an appointment or an office visit. When somebody is scheduling a visit, scheduling to come in, how do you refer to that? ‑So there would be two big subsets of what they might be scheduling to come in for. They might schedule a surgery, which is an easy one to define. They&rsquo;re going to come in, we&rsquo;re going to do some sort of a procedure. Usually, there is going to be some anesthetic involved. That would be a surgery and that would be outside of our normal office hours. ‑Oh, okay. So what about when they just come in for regular stuff? ‑So when they come in for regular appointments, you could call those office visits or appointments, and there are a few different subsets of those. You may have an appointment that&rsquo;s a wellness exam, and in that exam, we would be doing, of course, a physical examination and generally wellness treatments like vaccination, some blood work, generally your healthy pet who is coming in for a routine checkup. ‑So that&rsquo;s an office visit and there is a couple other things that come under the umbrella of office visit, but if I, I&rsquo;m also thinking about scheduling because that&rsquo;s the thing we&rsquo;re really going to be focused on is the scheduling portion of the app. So we&rsquo;re always scheduling an appointment, an appointment for a surgery, an appointment for an office visit, whatever type of office visit that is, so is using the term appointment, does that make sense? Would you, if if I said appointment would you think that could be a surgery, that could be a checkup, that could be whatever. This thing to be scheduled is what I want to define. ‑Yeah, I mean I think you could call them all appointments, but I would differentiate between the surgery and something that&rsquo;s done in the office, but then I would further differentiate in the office between a wellness exam, an exam for somebody that&rsquo;s coming in with a problem, or an exam that doesn&rsquo;t need to see a doctor, but could just be done by a technician like a toenail trim. ‑Oh good. Yeah, we always need those, clickety‑clack on the floors. Alright, so I think then we&rsquo;ll use just the overall umbrella of we&rsquo;ll schedule an appointment and then we&rsquo;ll be more explicit about what type of an appointment that&rsquo;s going to be. Would that feel okay to you? ‑Yeah, that makes sense to me. ‑Great. Excellent. Alright, so I&rsquo;ll get back to Steve and then we&rsquo;ve got another meeting set up I think in a few days to just hash out some more details after Steve and I&rsquo;ve gotten some more of our ducks in a row. ‑Sounds great! ‑Excellent. Thanks Michelle. Bye bye. ‑Thank you. Bye. ‑Now we have a stake in the ground for our ubiquitous language. As we continue working with Michelle, not only will we learn more items for the bounded context, but there is also a chance that the ubiquitous language will evolve. Eric Evans guides us to pay attention to those changes because a change in the ubiquitous language is also likely to mean a change in the domain model. We have to update our design to accommodate what we&rsquo;ve learned.</p>
<p>Reviewing Important Concepts from This Module
We&rsquo;ve covered quite a few concepts in this module. One of the most important ones is just understanding the problem domain and the overall thing that your software is working within. ‑‑And breaking things apart. I know that when I started out, I had a really hard time really understanding differences between the core domain, the subdomains, and the bounded context, especially the subdomains and the bounded context because at first glance, they looked like the same thing to me. ‑‑Sure, it&rsquo;s really easy to have an application where you have some kind of a concept, like a customer that you know is used by every system that your organization uses. And it ends up becoming this like God object in your database and in your different applications where any given application might only care about a tiny subset of that concept. ‑‑Yeah. So, for me, I think the most important thing is really focusing on the bounded context. Getting down to that and understanding about the boundaries. One thing that helps me a lot is just stating within the context of this and then suddenly like, oh right, that&rsquo;s what a context is. It&rsquo;s not like some mysterious new term that Eric Evans invented. He just is leveraging what makes sense. Within the context of appointment scheduling, this is what a client looks like. Within the context of billing, this is what a client looks like. ‑‑Sure, I think that makes a lot of sense. And it&rsquo;s valuable, even when you have an application, like a legacy application that wasn&rsquo;t built with domain‑driven design. Let&rsquo;s go ahead and look at some more terms here. For instance, we&rsquo;ve got what you were just talking about, I think of as context mapping. And even in a legacy application, it can be valuable to kind of map out what are all the concepts in this application and where are the overlaps with different subdomains that maybe we haven&rsquo;t even defined in this legacy application. ‑‑Yeah. Even if you&rsquo;re not planning on making huge changes to it, it&rsquo;s still really, really helpful to just kind of update your perspective on things. Sometimes it just leads to new understandings. ‑‑I think the shared kernel is a really important part of this, too, because in almost every real‑world organization I&rsquo;ve worked with, there are different types of cross‑cutting concerns, and we talked about one of them being the authentication piece, and that&rsquo;s definitely a really common one. But there are usually others too that you want to share. ‑‑Yeah, and, again, it&rsquo;s another one of those things that sounds like it might be a big, scary, mysterious thing because you haven&rsquo;t referred to it that way, but if you really just start out thinking of it as the common stuff, but then‑‑‑I think one of the important things, though, is even within the context of domain‑driven design, we have a ubiquitous language because if I say common, you might have a different idea of what I mean by common, but if I say shared kernel, we&rsquo;ve got an agreed‑upon understanding of what we&rsquo;re talking about there. So at first, I really kind of pushed back against using these terms because I felt like a lot of the DDD experts were just throwing them around all the time. And then I started really getting a better understanding of why it&rsquo;s important to use those terms. It&rsquo;s about‑‑‑it&rsquo;s the ubiquitous language of domain‑driven design so everybody&rsquo;s on the same page. ‑‑Yeah, I do agree that that&rsquo;s an important part of learning about DDD and other areas of software development, like, for instance, design patterns. These things give us these terms that we can use that are very, very dense. If we talk about shared kernel, it would take me three or four sentences to describe what I meant by that. But in these two words, you know exactly what I mean, just like if I talk about using a strategy design pattern, that is much easier to convey than if I were to try and describe it with words and have to draw a UML diagrams to say what I mean. ‑‑And it&rsquo;s the same, again, with the ubiquitous language because now I really have a better understanding of the fact that what it means is the language is ubiquitous throughout a particular bounded context. When we&rsquo;re talking about a scheduling app, we&rsquo;re going to use these terms all the way through, like you were saying before, we use it not just when we&rsquo;re talking to the domain expert but in our class names, in our methods, it&rsquo;s just ubiquitous throughout all of the pieces of the things that are involved in that bounded context from one end all the way to the other of it. ‑‑And I think as we&rsquo;ll see when we look at the code again, some of the constructs in .NET, like namespaces, are really appropriate to ubiquitous language because when you prefix that same term in your code with a particular namespace, that tells all the other programmers that if I say SchedulingApp.notification, we know that that has a different meaning that if I&rsquo;m talking about EmailReminder.notification. ‑‑Or SchedulingApp.client versus Billing.client. ‑‑Exactly.</p>
<p>Review and Resources
In this module, we learned about our domain, in this case, a veterinary practice. We talked about it at length with a real live domain expert and identified the core elements of our domain model. We identified a variety of subdomains and focused in on the key area that we would be addressing first with our application. ‑We spent some time designing the system based on our conversations with Michelle, identifying boundaries between different contexts, and noting how sometimes the same object with the same name might mean something different within a different context. ‑Finally, we talked about the importance of communication in general and in particular having a ubiquitous language. We know that Domain‑Driven Design can help us avoid many design errors and wasted time miscommunicating as we work on a complex project. ‑Steve and I are so grateful to Eric Evans for spending time with us while we were creating this course in order to share his luminous advice and insights. In the next module, we&rsquo;ll drill into the domain model so you can have a good understanding of its critical elements. ‑This is Steve smith, ‑and this is Julie Lerman. Thanks again for watching Domain‑Driven Design Fundamentals.</p>
<p>Elements of a Domain Model
Introduction and Overview
Hello, this is Julie Lerman, ‑and this is Steve Smith. ‑In this module, we&rsquo;re going to focus on the elements of a domain model which are in our bounded context. ‑You&rsquo;ve seen these in the mind map. It&rsquo;s patterns like entities and aggregates and more. ‑You can find me online at ardalis.com or on Twitter as @ardalis. ‑And you can find me online at thedatafarm.com or on Twitter at @julielerman. ‑In this module, we&rsquo;ll focus on the technical aspects involved when modeling a bounded context. We use these terms while modeling, and these same terms refer to patterns we&rsquo;ll use when we code. The concepts flow through the entire process, which is great. You don&rsquo;t have to keep switching hats or mindsets. ‑We&rsquo;ll start by grounding ourselves in the domain and understand why it&rsquo;s important to stay focused there. DDD models are driven by behaviors, not classes and properties. This is another very cool shift in thinking for those of us who have always focused on objects. Then you&rsquo;ll learn about some terms used to describe domain models, rich and anemic. You learn what the terms mean at a conceptual level and what the code that they&rsquo;re describing looks like. ‑Entities are the key types in your system, but not every type in your system is an entity. ‑You&rsquo;ll learn how entities fit into DDD, how to differentiate entities that have complex needs from simpler entities that might only need some basic CRUD logic, and you&rsquo;ll be able to see how we&rsquo;re implementing all of these concepts in our code.</p>
<p>The Importance of Understanding DDD Terms
Domain‑Driven Design is filled with lots of specific terms. Much like the ubiquitous language that we use to make it easier to communicate while working within a bounded context, understanding and using the terms of DDD makes it easier to talk about the process. We&rsquo;ll spend the bulk of this module focusing on some of the concepts behind modeling bounded contexts, concepts that are critical to this process, but, unfortunately, often misunderstood. ‑I&rsquo;ve definitely had my challenges with some of the DDD concepts. Some of my issues were because the terms overlap with other technologies I use. For example, I do a lot of work with Microsoft&rsquo;s ORM called Entity Framework. Entities are a key element in Entity Framework, and they&rsquo;re also a key element in DDD. So I thought my understanding of entities from Entity Framework was enough to translate to DDD entities, but it really wasn&rsquo;t, and my less than solid grasp on DDD entities caused problems when I was trying to model domains and implement the model and code. We also have the concept of a context in Entity Framework. While the real goal of that context is to provide interaction with the database, it also does provide a boundary around a model. But it&rsquo;s very different than the concept of a bounded context, and that definitely confused me for a while. Another important element in a DDD model is value objects. These got me pretty confused at first, and my ego was saved by discovering that others have also been confused by value objects. But I&rsquo;ve worked on my DDD education and sorted these problems out, so in this module, it&rsquo;s really important to both Steve and I that you start off on the right foot with a proper understanding of entities, value objects, and some of the other DDD puzzle pieces so that Domain‑Driven Design can help you with your complex problems, not complicate them even more.</p>
<p>Focusing on the Domain
It&rsquo;s important to remember that first D in DDD stands for Domain, and yeah, the other two Ds, Driven and Design. But we really want to focus on Domain here. ‑By now, you&rsquo;ve probably heard us talk about this plenty, but both Julie and I find that we constantly have to remind ourselves to focus on the domain. We hear ourselves begin to talk about the user interaction with the app and have to ask, well, what part of the vet clinic domain is this user? Yeah, obviously we care about the user and how the actual application will work from their perspective, but that&rsquo;s for another conversation, and we have to draw ourselves back to focusing on modeling the domain. ‑I have quite a long history with data access, and I catch myself worrying about how our domain model will translate to the database so that things definitely get persisted correctly. That&rsquo;s when Steve needs to give me that look, you&rsquo;re doing it again, Julie, and I have to bring my focus back to the domain of the vet clinic again. So while it may seem redundant to harp on domain, domain, domain, this diligent focus will help you avoid the complications and distractions that come from thinking outside of the domain or the subdomain that you&rsquo;re focused on. ‑Here&rsquo;s an important quote from Eric Evans&rsquo; book about this focus on the domain. &ldquo;The Domain Layer is responsible for representing concepts of the business, information about the business situation, and business rules. State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure. This layer of the domain is the heart of business software.&rdquo; ‑Just to reiterate, the domain model is the heart of the business software. This is the whole point behind Domain‑Driven Design. Focus on the domain, not the technical details of how the software will work. ‑In a typical database‑driven app, we&rsquo;re used to focusing on properties or attributes of classes. Our apps sometimes become all about editing property values and the state of our objects. However, when we are modeling a domain, we need to focus on the behaviors of that domain, not simply about changing the state of objects. ‑Michelle didn&rsquo;t talk to us about setting the name of a dog or editing the time of an appointment. She told us that she needs to schedule an appointment, and when she does that, she needs to book a room and create a schedule item on a doctor&rsquo;s calendar as well. So scheduling appointment is a lot more than setting the attributes of the objects involved, the appointment time and identity of the pet we&rsquo;re making the appointment for. We&rsquo;re talking instead about how the system behaves. In response to scheduling an appointment, the system should also book a room and do something to the calendars of the doctor and any vet techs that might be involved.</p>
<p>Identifying Events Leads to Understanding Behaviors
An important way to identify behaviors in your system is by focusing on events. Doing so gives you a great path to understanding the behaviors of your domain. Alberto Brandolini devised a great way to brainstorm with clients, which is referred to as event storming. It begins by having a somewhat chaotic brainstorming session with a good number of domain experts writing events on Post‑its and sticking them on a wall. The format of what they write is in the past tense. For example, an appointment was booked, a client contacted the office, or a dog was weighed in. I facilitated quite a few event storming workshops with clients, and I&rsquo;m a big fan of using this process to help get a picture of the domain, discover bounded contexts, and even discover key problems that should be addressed. Another interesting methodology for modeling a system based on events is called Event Modeling. Adam Dymitruk came up with this workflow and has had great success using it to help teams collaborate on learning about the domain and designing the flow of software. I was fortunate to participate in a three‑day workshop with Adam to learn about Event Modeling. We won&rsquo;t be teaching you about event storming or Event Modeling in this course, those are beyond the scope of our goals here, but we did want to be sure you were aware of them. You&rsquo;ll find links for more information about event storming and Event Modeling at the end of this module.</p>
<p>Comparing Anemic and Rich Domain Models
In order to understand the difference between design that&rsquo;s focused on attributes versus design focused on behaviors, it will help to understand two commonly‑used terms in domain‑driven design, anemic domain models and rich domain models. An anemic domain model is a domain model that is focused on the state of its objects, which is the antithesis of DDD. While the term is somewhat negative indicating a deficiency, you don&rsquo;t need to perceive it that way. There is nothing wrong with anemic classes when all you need to do is some CRUD logic, but if you are creating a domain model, you&rsquo;ve already made the decision that your domain is too complex for simple CRUD. So anemia in a domain model is considered an anti‑pattern. ‑Martin Fowler writes about anemic domain models with such drama that you may never mistakenly use them in your domain model. He says the basic symptom of an anemic domain model is that at first blush it looks like the real thing. There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have. The catch comes when you look at the behavior and you realize that there is hardly any behavior on these objects making them little more than bags of getters and setters. Indeed, often these models come with design rules that say you are not to put any domain logic in the domain objects. Instead, there are a set of service objects would capture all the domain logic. These services live on top of the domain model and use the domain model for data. ‑What we aim for then is rich domain models, not anemic domain models when we are modelling our domain. Rich domain models will represent the behaviors and business logic of your domain. Classes that simply affect state are considered an anti‑pattern in a domain model, and therefore, get the nasty label of anemic, even though they are perfectly fine in a CRUD model. Martin Fowler doesn&rsquo;t mince words when it comes to anemic domain models saying the fundamental horror of this anti‑pattern is that it&rsquo;s so contrary to the basic idea of object‑oriented design, which is to combine data and process together. I have to say I agree and I&rsquo;ve worked with many teams who have had to deal with the self‑inflicted pain of treating their domain entities like DTOs lacking any encapsulation or behavior. That can work for simple CRUD apps, but it&rsquo;s often a disaster in a DDD model. ‑While Martin Fowler and other DDDers have strong words to say about anemic domain models, we&rsquo;d like to share a gentler message, which is to strive for rich domain models and have an awareness of the strengths and weaknesses of those that are not so rich.</p>
<p>Understanding Entities
Even though a DDD app is driven by behavior, we still need objects. DDD expresses two types of objects, those which are defined by an identity and those which are defined by their values. We&rsquo;ll focus first on the objects that are defined by their identity. These objects are called entities. ‑An entity is something we need to be able to track, locate, retrieve, and store, and we do that with an identity key. Its properties may change, so we can&rsquo;t use its properties to identify the object. If you&rsquo;ve done any type of data persistence in software, you&rsquo;re probably pretty familiar with entities and their keys. When we are modeling a problem, we can talk about entities without having to think about how they are implemented in the resulting software. But when it is time to start coding, there are patterns to follow to ensure that these objects have the technical attributes of Domain‑Driven Design entities. ‑As you can see from this section of the DDD navigation map, entities are pretty integral to our software. So, before we can learn about these other elements, domain events, repositories, factories, and more, you should have a very good understanding of an entity. ‑The most important entity in our model is Appointment. This is what we will be creating, editing, and retrieving in the context of scheduling appointments. Appointment inherits from a base class we&rsquo;ve created called Entity. We&rsquo;ll look at that more in just a bit. Notice that all of the classes shown here are inheriting from the identity base class. However, although the other classes are entities, after our discussions with Michelle, we came to the conclusion that we would like to have a separate utility for managing client and patient information and to manage information about staff and staff scheduling. Thus, we don&rsquo;t need very much information or behavior related to these collaborating entities within the bounded context of appointment scheduling.</p>
<p>Differentiating CRUD from Complex Problems that Benefit from DDD
‑Let&rsquo;s take a closer look at that data that supports scheduling appointments in our system. ‑We determined that managing the client, patient, and staff information, which is external to this model, was well‑suited to just simple CRUD. We didn&rsquo;t identify complex rules or behaviors for creating and editing that data. Thus, the concepts of doctors, rooms, clients, and patients are managed outside of the scheduling bounded context. ‑For comparison, look at the CRUD classes for Patient and Client in the other bounded context. They&rsquo;re very simple. They don&rsquo;t inherit from our entity base class, and most interestingly, their ID properties are integers. We&rsquo;ll let the database assign the IDs when we create these classes. So these classes are not designed using domain‑driven design. Now let&rsquo;s go back to the appointment scheduling context. The client, patient, doctor, and room classes here are completely different from the CRUD classes we just saw. However, they do have a subset of the same fields from those CRUD classes. All we need to know about these objects when we&rsquo;re scheduling is their IDs, their names, and maybe a few other details. But here, they&rsquo;re simply used as look‑up data, and they&rsquo;reread‑only.</p>
<p>Switching Between Contexts in a UI
Even though our domain is split up into a number of bounded context, the user interface can be designed in a way that moving from one context to another is seamless to the end users, they don&rsquo;t need to know that these things are in separate bounded contexts. While maintaining client and patient data is a completely separate task from scheduling appointments, Michelle wanted to be sure that anyone working at the front desk is able to easily move between these tasks in the software without disrupting their workflow. So let&rsquo;s say the person at the clinic who does the scheduling is on the phone with Kim and about to make an appointment for Roxy to come in, but then the other line rings, they put Kim on hold, and it&rsquo;s me. And in the nicest way possible, I&rsquo;ve called to just let her know they&rsquo;ve got my last name spelled wrong. That happens all the time. People just want to put that h in there. Even though they&rsquo;re in the middle of scheduling and scheduling has its own backend, its own bounded context, and is totally separate from client management, they can still drive the app right over to the Client Management area and very quickly fix my name and save that. Then they can just flip back to the schedule. Notice that Kim is still the active scheduling client that&rsquo;s showing up in the left‑hand corner and the change to the spelling of my last name is already visible on the schedule. And so now that person can go ahead and finish up with Kim scheduling the very adorable Roxy for a wellness exam. To the user, there is no real difference between doing the scheduling and doing the client management, it&rsquo;s just a nice smooth flow between the two, it doesn&rsquo;t feel like, oh, now we have to open up a different application in order to do this other thing and doesn&rsquo;t break everything they&rsquo;re in the middle of, but for the purposes of designing our application, everything is bound within its own individual context. And when designing this context, we don&rsquo;t have to worry about switching from one context to another. ‑So remember, we&rsquo;re talking about what makes these all entities. An appointment object needs to be located and tracked and we need to be able to edit them easily. Using a unique identity allows us to persist and retrieve an appointment even if some of its values change. Appointment is definitely an entity in our system. We actually had to think a little more about client, patient, doctor, and room in this particular context. Our discussions highlighted the fact that when creating appointments, we only need access to some of the high‑level information about the client, patient, doctor, and room, but these objects won&rsquo;t be edited. So we wanted these stripped down read‑only types that give us minimal amount of detail for each. We do still need to be able to uniquely identify them though, they do have some identity. If the client&rsquo;s name changes, a change we would make in the client management system, that new name will need to be reflected when we look at the appointment scheduling for that client. There should only ever be one record to represent a particular client in this bounded context. So client and the other types that are reference types in this context are still entities. We triple checked our decision with another kind of domain expert, Vaughn Vernon, a DDD expert, and we were happy to get his thumbs up on this particular decision. So Julie, Michelle, and I also talked about how to name the types that are simply reference types in this particular bounded context. At first, we were worried that we might get confused by having different definitions of client, patient, doctor, and room. We wanted to call them client details or client view or something like that, but thanks to the ubiquitous language, the fact that we are in the scheduling context drives our comprehension of what a client means in this particular space. ‑A client in scheduling is still a client, so we use the same name, even though it&rsquo;s a differently defined pipe than the client we work with in the Client/Patient Management app. ‑Right, and thanks to namespaces in our code, we&rsquo;re able to keep it clear which ones are which in the code.</p>
<p>Using GUIDs or Ints for Identity Values
So, all these types inherit from our base entity class. However, notice that those reference types use int for their base entity&rsquo;s ID and not the GUID that&rsquo;s used by appointment. That&rsquo;s because all of the management of those other types happens to be done using CRUD, and with CRUD, it&rsquo;s easy to just use database‑generated ints. Appointment is built using DDD principles, and you&rsquo;ll see that it&rsquo;s much easier to use GUIDs when building DDD entities and their related logic rather than relying on the database to provide the identity values. Not only is it easier, but it follows DDD principals more clearly, since we will build all of our domain logic around appointments without involving the database. We would have a hard time working with appointments in our model and in our unit tests as we develop the application if we always needed a database to assign their IDs. ‑So that&rsquo;s not to say that you can&rsquo;t use integer IDs If you&rsquo;re going to use a DDD style of application; it just makes it a little harder. Wouldn&rsquo;t you say, Julie? ‑Yeah, yeah, and I&rsquo;ve definitely come up against that. With the stuff that I do with Entity Framework, I&rsquo;ve made sure that I show patterns for continuing to use the database‑generated ints because I didn&rsquo;t want to give people the impression that they had to throw away, like, for me like 25 years of this dependency. And like all of a sudden I have to go cold turkey and move over to GUIDs. ‑Sure, I mean, there&rsquo;s trade‑offs in what you choose to use for your ID, but having an ID that we can generate in the client and just in our code has a lot of value. ‑Every time we&rsquo;ve been working on some of our different unit tests and we needed as part of the test to instantiate something that was an int, we were like, ugh, now we have to find another way to get that in there because we were protecting it and it was a problem. As our own experience grew, we realized there&rsquo;s another way to bridge this conflict by using both GUIDs and database‑generated ints in an entity. This way, while creating objects, you&rsquo;ve got the control over key generation with the GUIDs, and they&rsquo;re not depending on the database. However, once the data has been created in the database and int keys exist for it, then you can benefit from those when adding indexes and performing queries in the database.</p>
<p>Talking with Eric Evans About the Responsibility of Entities
We talked with Eric Evans to gain some additional insight into entities. Specifically, I asked him how entities align with the single responsibility principle. ‑‑If you&rsquo;re not familiar with this object‑oriented programming principle, you can learn more about it in Steve&rsquo;s SOLID course right here, on Pluralsight. ‑‑One of the questions that I&rsquo;ve heard is, What is the single responsibility for an entity? Or to put it another way, does having an entity that has a lot of business logic in it violate the single responsibility principle? ‑‑Eric told us that entities are very central, and so it&rsquo;s natural that they get heaped up with lots of functionality. ‑‑But there&rsquo;s a downside to this. As you build out the system, there are more and more conflicting demands for these central entities, so they end up being huge. Evans said that the main responsibility is the identity and the lifecycle. ‑‑Eric also told us that single responsibility is a good principle to apply to entities, and it points you towards the sort of responsibility that an entity should retain. Anything that doesn&rsquo;t fall into that category, we ought to put somewhere else.</p>
<p>Implementing Entities in Code
Let&rsquo;s take a look at an entity in our veterinary appointment scheduling application, FrontDesk. We&rsquo;re going to look at the Appointment class, which defines all the information that we need to schedule an appointment for a particular animal or patient. It associates the patient with the doctor, room, and appointment type, and also includes the start and end time for the appointment. Now, the Appointment class inherits from BaseEntity<T>, which is a generic base class. In this case, it&rsquo;s BaseEntity<Guid>, as you can see here. The GUID is defining the type of our identity property, our ID. ‑Right. And we talked about that earlier when we were looking at the structure of the different entities in this model. We wanted Appointment to have a GUID because we&rsquo;re creating new appointments on the fly. So, let&rsquo;s take a look at that BaseEntity class. First of all, it&rsquo;s an abstract class. So we can&rsquo;t just create a BaseEntity object, we have to create something that is a BaseEntity, such as an appointment. And using generics, we&rsquo;re saying that the BaseEntity is going to use whatever type we ask it to, and that type is for defining the ID. So for Appointment, we said BaseEntity is going to be using a GUID as its identity. I mentioned this earlier, why I would need GUID for appointment in this context because I need to be able to create new appointments in this context, and I&rsquo;m not going to be waiting for the database to generate the ID for me. So using a GUID lets me create that ID right up front as I&rsquo;m creating that new appointment. So I&rsquo;m giving it its ID. The BaseEntity class also has a property to hold a list of domain events that will define explicitly for each of the types that inherit from this base entity. You&rsquo;ll learn more about domain events further on in this course. ‑All right, so let&rsquo;s take a look back at the rest of Appointment. Now, since Appointment has more behavior than just state, we don&rsquo;t want to have it just be a bag of properties that our application can get and set however they would like. ‑Because that would be an anemic domain model. ‑Yes, because that would tend to lead us toward a more anemic domain model. ‑And we want a rich one. ‑Now, in particular, we&rsquo;re also constraining how we create this appointment. We want to ensure we create appointments in a valid state, so that means passing in the minimum necessary elements an appointment needs to have. Sometimes we&rsquo;ll want to update an appointment. Remember, these aren&rsquo;t value objects. They&rsquo;re not immutable, so we can change them. When we need to modify an appointment, we&rsquo;re going to do that through methods. And so, for instance, if we decide we want to modify what room an appointment is scheduled in, we&rsquo;re going to do that through a method rather than just a setter. We do this because there&rsquo;s additional behavior we may want to do. In this case, we have some guards, again to ensure a valid value is being passed. ‑These guards are a set of reusable functions that you&rsquo;ll find in the shared kernel of our solution. ‑And we also want to raise an appointmentUpdatedEvent, that we might handle and send a notification or perform some other action as a result of what happened. ‑And that also gives us the flexibility in the future to change what type of logic we want to trigger. ‑And that&rsquo;s something we can&rsquo;t do very easily If we just let anybody in the application set the value. ‑Right. ‑By providing a method to use to update room explicitly and otherwise making the setter private, we force all interaction with the model to use this method, which gives us just one place to model behavior that should be associated with this operation. It&rsquo;s the same as with the constructor, we need to do our best to keep our domain model in a consistent state so the rest of the application can count on it being correct. ‑Right, because otherwise somebody could satisfy the requirement that they pass in the room ID, but they might pass it in as 0, which would be invalid. So, we&rsquo;re further constraining that they don&rsquo;t do that either. The appointment would be invalid if it had a room ID that didn&rsquo;t correspond to an actual room entity. And in any case, the database wouldn&rsquo;t let that fly since there&rsquo;s a foreign key relationship between appointment and room. ‑Yes, but we want to make at least some effort to catch such problems in our code, rather than relying on the persistent store to inform us of a user error. Overall, using guard clauses, like the ones you&rsquo;ve seen here, help us ensure our entities aren&rsquo;t partially constructed and inconsistent. Once we&rsquo;ve created an appointment, we need to record it as part of the clinic schedule, which involves some additional rich behavior. So, if we scroll down to the bottom, we have this method called Schedule. And this is where we&rsquo;re going to do the additional work involved with actually saving an appointment and ensuring it fits in with other appointments that have already been scheduled. We&rsquo;re not going to worry about the code at the moment, but the idea is that this method would query the database for other appointments that might be near this one and make sure there is an available slot in the schedule that this one fits into. Then it will save the appointment and raise an event, letting the rest of the app know that a new appointment has been scheduled. In the next module, we&rsquo;ll investigate this design further and revise it a little bit. Now, let&rsquo;s look at one more simple entity that this bounded context needs, the Doctor class. You can see that Doctor inherits from BaseEntity as well, but in this case it&rsquo;s using an int for its key. The only other property it has is a string Name property. ‑This is a minimal implementation of the Doctor type that satisfies the scheduling bounded context. It&rsquo;s essentially no more than a reference type. Doctor and the other similar types, Patient, Room, etc., are all organized into this folder called SyncedAggregates.</p>
<p>Synchronizing Data Across Bounded Contexts
Let&rsquo;s dig a little more into how these reference types in the scheduling bounded context are getting their data from the Clinic Management app, especially if the two BCs aren&rsquo;t sharing a database. If you recall from seeing the class descriptions of all of these classes, the AppointmentType, Client, Doctor, Patient, and Room, we had explicitly decided that these are reference entities where we&rsquo;re actually doing their maintenance elsewhere so they&rsquo;re not adding any unneeded complexity to the Front Desk application. ‑‑Right. And they&rsquo;re just READONLY. So we&rsquo;re never having to create or modify them. ‑‑And we&rsquo;re using the ints that were created by the database when we persisted these with a CRUD context in a different application, but there are still entities here, just entities of type integer. The Clinic Management bounded context is responsible for updating these types. When changes are made, application events are published by Clinic Management, and this Front Desk bounded context subscribes to those events and updates its copies of the entities. ‑‑One of the questions we get all the time when we describe how bounded contexts have separate databases is, How do we synchronize changes between these two apps? This is one of the simplest and most common approaches. One app is responsible for updates, and the other apps just subscribe to the changes and are notified when they occur. ‑‑This is an example of eventual consistency. The two systems aren&rsquo;t immediately kept in sync using a transaction or something similar, but through message queues, eventually the different bounded contexts are updated to the new state when a change is made.</p>
<p>Review and Resources
We&rsquo;ve covered a lot of ground in this module and you&rsquo;ve learned a lot of new terms, so we just want to review some of them with you before we move onto the next module. The first is a pair of terms that often go hand in hand, anemic domain models versus rich domain models. And remember the anemic domain models, while often looked down upon from the perspective of DDD, they&rsquo;re perfectly fine for CRUD. These are models that look a lot more like a database schema than a class that has lots of methods and rich behavior in it. On the other side of that is a rich domain model, which is what we strive for in domain‑driven design, and that&rsquo;s a model that really is focused on behavior, not just changing the values of properties. ‑Then we talked about entities and entities tend to be one of the core pieces of our domain model. The key thing that distinguishes an entity from other types in our model is that it has some kind of identity that we can use to track it over time and to bring it in and out of persistence. This module provided you with your first look at implementing a bounded context in code, an important part of tactical design. You learned about the difference between anemic models and rich models, and that while anemic models have their place, focusing on behavior with rich domain models is how DDD lets us solve complex problems. Entities are the classes in our domain models that are tracked by an identifier allowing us to build graphs and eventually persist and retrieve that data. ‑Sometimes we are working with entities whose behavior and rules are critical to the bounded context in which we&rsquo;re working. Other entities may only provide supporting or reference data. You learned how to help identify the differences between them. Then you got to look at the appointment class in our scheduling app to see how we have applied rules and behaviors in that entity. You also looked at one of the reference entities and learned how we use message queues to ensure the reference and the data that is maintained in the clinic management app is made available to the scheduling bounded context, even though they do not share a database. ‑In the next module, we&rsquo;ll focus on some more important elements of a domain model, value objects and domain services. We&rsquo;ve referenced a lot of interesting and helpful resources in this module and here are two pages of links for you to follow up with if you want to dig in a little further, including Steve&rsquo;s Pluralsight course on SOLID principles of object‑oriented design and information on event storming and event modeling. This is Julie Lerman ‑and this is Steve Smith, and thanks for watching our course, Domain‑Driven Design Fundamentals.</p>
<p>Understanding Value Objects &amp; Services in the Model
Introduction and Overview
Hello! I&rsquo;m Julie Lerman. ‑And I&rsquo;m Steve Smith. Welcome back to Domain‑Driven Design Fundamentals. In this module, we&rsquo;ll continue exploring the elements of a domain model as we dig into value objects and domain services. ‑Value objects are a confusing concept. So we&rsquo;ll begin by looking at where they fit into the mind map and introducing what makes an object a value object, and how they relate to entities in a model. ‑We&rsquo;ll share some more guidance from Eric Evans and Vaughn Vernon, and then show how we&rsquo;ve implemented value objects in our code. ‑Next, you&rsquo;ll gain a high‑level understanding of domain services, and solidify that by exploring their features, and then some examples of domain services.</p>
<p>Getting Acquainted with Value Objects
When introducing entities, Steve and I talked about objects that were defined by a thread of continuity and identity, not defined by their values. So, what about objects that are defined by their values? These are called value objects, and they play an equally important role in a domain model, as entity objects do. ‑A value object has very specific characteristics. It is an object that is used to measure, quantify, or describe something in your domain. Rather than having an identity key, its identity is based on the composition of the values of all of its properties. Because the property values define a value object, it should be immutable. In other words, you shouldn&rsquo;t be able to change any of the properties once you&rsquo;ve created one of these objects. Instead, you would simply create another instance with the new values. If you need to compare two value objects to determine if they are equal, you should do so by comparing all of the values. Value objects may have methods and behavior, but they should never have side effects. Any methods on the value objects should only compute things; they shouldn&rsquo;t change the state of the value object, since it&rsquo;s immutable, or the system. If a new value is needed, a new value object should be returned. Don&rsquo;t confuse the value object&rsquo;s pattern with C# and .NET support for value types and reference types. Custom value types in C# are defined with structs, while reference types are defined as classes. In DDD, both entities and value objects are typically defined as classes. Classes have advantages over structs when it comes to encapsulation and support for inheritance‑based extension and reuse.</p>
<p>Recognizing Commonly Used Value Objects
To help you better understand the basics of value objects, let&rsquo;s take a look at some value objects that you probably use all the time as a developer. The most commonly employed value object is a string. In .NET and many other languages, a string type is immutable, and you now know that immutability is one of the key attributes of a value object. A string is a collection of characters, and the combination of all those characters give that string meaning. For example, C‑A‑R in English, a car. If a string were mutable, we could change the R to T. Now the string is C‑A‑T, a cat, which has a very different meaning than a car. Or we could add a letter, maybe put an S in front of it, turning CAR to SCAR, also completely changing the meaning of car. But it&rsquo;s not just the array of characters that gives a string its meaning, the order of them is also critical. Just think of the word dog, d‑o‑g. Shifting its letters around gives us something with a very different meaning. ‑So one of the things that .NET makes it really easy to do is to modify strings, like you can change the length of it or make one all upper case. But when you call, for example, ToUpper on a string, it doesn&rsquo;t just change that string object, it gives you a new instance of a string that now has all uppercase characters. ‑Many developers say that monetary values in financial systems have been perfect candidates for value objects in their system. And Ward Cunningham provides us with a really helpful example, a company&rsquo;s worth. If a company is worth 50 million dollars, that means something, 50 million dollars. It&rsquo;s a very specific measurement. Fifty million on its own is not a measurement, it has no meaning without the unit, which in this case is dollars. But dollars alone doesn&rsquo;t describe worth either. In fact, dollars doesn&rsquo;t really help, does it, because is it US dollars or Canadian dollars, Australian dollars? It only makes sense when you put the two together as 50 million US dollars. There&rsquo;s actually one more factor to take into account, is the point in time of this 50 million dollars because of the way financial systems work and the fluidity of monetary values. ‑We could still just have the two properties in this Company class, but by creating a value object you also protect and constrain the measurement. For instance, we might have a class called Company. It might have one decimal property that represents the worth amount and another string property that represents the worth unit. The problem with this approach is that it doesn&rsquo;t tie these properties together in any way. These two properties appear to be independent of one another, but they&rsquo;re obviously closely related. If an update is made just to the Worth Unit string, it could obviously have a tremendous impact on the company&rsquo;s worth as a combination of these two concepts. Fifty million rupees has a very different worth than 50 million US dollars. To ensure nobody can set the unit without also specifying the amount, a separate value object can be introduced to represent the entire worth concept. This ensures the entire object must be updated as a whole. Since the worth type is immutable, the only way to make updates to the Worth property on the Company class is by replacing the whole instance with a new one, not just changing an isolated field. ‑A value object is not always for a measurement though. It can be another type of description. Eric Evans calls out dates as a great example for value objects. I&rsquo;ve used this one often, DateTimeRange, and it was perfect for the vet appointment scheduling app. We usually set a start and an end time together and can&rsquo;t really set one without the other. Also, we often need to pass the two values, start and end time, around from one method to another. So we&rsquo;ve encapsulated them in a value object called DateTimeRange. The properties have private setters, which makes the object immutable since we can&rsquo;t change them. We aren&rsquo;t showing the full logic of the class here, but when we look at the value objects in our application you&rsquo;ll see more of how we implement a value object in our software to ensure that it meets all of the attributes, not just immutability, but how we handle equality, comparison, and other logic.</p>
<p>Getting More Insight from Eric Evans and Vaughn Vernon
In his book, Implementing Domain‑Driven Design, Vaughn Vernon recommends that we should try to use value objects, instead of entities, wherever possible. He says, it may surprise you to learn that we should strive to model using value objects instead of entities wherever possible. Even when a domain concept must be modeled as an entity, the entity&rsquo;s design should be biased towards serving as a value container rather than a child entity container. What this means is that you&rsquo;ll find that your design will have a number of entities who have very little logic of their own or very few primitives as their properties, but instead will have a number of properties that each are themselves a value object. ‑So he&rsquo;s not saying everything should be value objects, but that it&rsquo;s probably our natural instinct to start by thinking of things as entities and then maybe once in a while go, oh, maybe that should be a value object. So what Vaughn is suggesting is really start by thinking every time should this be a value object and you will surprise yourself at how many times something that you originally might have thought of as an entity really does make a lot more sense as a value object. ‑Or sometimes when you&rsquo;re looking at an entity, there might be a couple of properties that seem to always go together, you might be able to bundle these properties into a single value object. It&rsquo;s interesting to note that identity values can be treated as value objects as well. In many systems, entities have a primitive type, usually int or GUID as their ID, but this means that it&rsquo;s easy to substitute a client ID for a patient ID if developers are not careful. By creating actual value objects for client ID and patient ID, which can still be stored as ints or GUIDs, it can eliminate this kind of error from our design. ‑Here is an example of a Client class that&rsquo;s inheriting from base entity, but specifying that the type will be ClientIdValueObject rather than a scalar type like int or GUID, that&rsquo;s followed by a service class that has a CreateAppointmentFor method which takes a clientId and a patientId. If those IDs were both GUIDs, the runtime code would allow you to accidentally pass them in in the wrong order because the signature is only constraining that you pass in two GUIDs and that could create a big problem when you&rsquo;re trying to build an appointment. But with the specialized value objects, you can tightly constrain the parameters to avoid this problem rather than adding a lot of extra logic elsewhere to protect you from making that mistake. For me, this highlights the beauty of DDD thinking. With this little bit of upfront work, you&rsquo;re removing the complexity of solving the kind of problem that could be created by accidentally transposing the client id and patient id. In our conversations with Eric Evans, we asked him for his thoughts on putting logic into value objects. He told us that he thinks value objects are a really good place to put methods and logic because we can do our reasoning without side effects and especially the complications that identity brings along, all those things that make logic tricky. We can put functions on those value objects and then do the pure reasoning right there in the value object. ‑Eric also called out date libraries as a good example of a value object. They perform common functions on dates so we don&rsquo;t have to keep coding them ourselves in our entities or services. For example, a date library could be used for calculating a person&rsquo;s age from their birth date. As long as the library causes no side effects to the date in question, it can work well as a value object.</p>
<p>Implementing Value Objects in Code
Our primary demo involves scheduling appointments. Appointments have a start and an end time. These two things always go together, so they make sense to extract as a value object. Here&rsquo;s a closer look at the DateTimeRange ValueObject we created for the course&rsquo;s demo. We also have a DateTimeOffsetRange, which is identical, but includes support for time zones. Because DateTimeRange is a pretty low‑level concept that could be useful in a number of different applications, it&rsquo;s implemented in the shared kernel package. The class inherits from a ValueObject base class that provides flexible equality checking behavior, so we don&rsquo;t need to clutter our class with overloads for Equals, GetHashCode, et cetera. It was written by fellow author and DDD expert, Vladimir Khorikov. ‑Because this is a ValueObject, you can see that all of its properties are read only. Recent versions of C# and Entity Framework Core do allow us to avoid even having a setter in there when we want to define read‑only properties, and we also now have the use of records in C#. EF Core can comprehend read‑only properties that don&rsquo;t have any setters at all, and it takes advantage of fields. But here we&rsquo;ve written our value objects in a more generalized way that&rsquo;s not taking advantage of any specific or specialized features. However, you can adapt these samples to benefit from those specific APIs and language versions that you&rsquo;re working with. The important goal here, though, however you implement it, is that the state of the value object should not be changed once it&rsquo;s been created and as part of the domain model. ‑Right. Value objects should get all of their state through their constructor, and any invariants that need to be checked should happen in a constructor as well. In this case, the date time range is guarding against having a start time that exceeds its end time. If it does, an exception will be thrown. The second constructor that takes a timespan calls the first one using constructor chaining, so in either case, the guard will always be enforced. Since the DateTimeRange is immutable and cannot be created in an invalid state, the rest of the domain model can count on it being valid. ‑Our DateTimeRange type does have some additional methods that let us create new DateTimeRange instances from existing ones, much like the DateTime type provides options to create new date times by adding time to an existing instance. In our type, for example, to change an appointment set to end at 10:30 instead of ending at 11:00, a new instance of DateTimeRange can be created using the newEnd method. Finally, the base ValueObject class requires overriding a GetEqualityComponents method. This is used when comparing two instances of the ValueObject, and it&rsquo;s up to you to decide which properties should or shouldn&rsquo;t be included. In the case of DateTimeRange, the start and end times are sufficient. If two DateTimeRange instances have the same start and end values, they should be considered equal. ‑Custom logic needed to determine whether one appointment overlaps with another is another area where the ValueObject can help. The whole appointment isn&rsquo;t needed to determine if there is an overlap in appointments. Only the DateTimeRange is used in such a calculation. Thus, the Overlaps method, shown here, has been moved out of the Schedule and Appointment classes and into the ValueObject, where it is more reusable, and it reduces the complexity and responsibilities of the other domain types. ‑We asked Eric to share his thoughts on moving logic out of entities into value objects. He agreed that it&rsquo;s a good idea. What he said was if there&rsquo;s logic that&rsquo;s really the classic software logic, I like to add that in value objects. You can really test value objects much easier than entities, and you can use them much more freely. So your entity becomes this critical piece of glue, an orchestrator among different value objects. But that doesn&rsquo;t mean that you won&rsquo;t have some logic in the entity. It&rsquo;ll just be very concise. ‑Eric also said that it&rsquo;s a nice way to work towards the ubiquitous language to the point where you look in the methods of the entity and you see higher‑level things. They read like use case level communication, rather than nitty gritty detail. My personal takeaway from this is to keep an eye on the properties of your entities, and specifically, their types. If you find that they&rsquo;re all primitive types, like ints and strings, think about if any of those primitive things could be grouped together as value objects instead. Another value object that we can point out here is the AnimalType. This is just to give you an idea that our value objects can be extremely simple. In this case, AnimalType is just a combination of the species and the breed of a particular pet or patient that we&rsquo;re dealing with at the vet clinic. And there&rsquo;s not a whole lot of other behavior here. But it does provide us with a container by encapsulating these two related properties together as a single value object.</p>
<p>Understanding Domain Services
When an operation is important to the model but doesn&rsquo;t necessarily belong on any one entity or value object, a service is often appropriate. But don&rsquo;t be too quick to give up on finding a natural home for the operation on an existing entity or value object or you may end up with a very procedural anemic model. Frequently, domain services serve as orchestrators for operations that require several different collaborating entities or value objects. Evans notes that good domain services must first and foremost not be a natural part of an existing entity or value object. Again, we don&rsquo;t want to shift all of our rich behavior from our entities and value objects to our services. Services should also have a defined interface that&rsquo;s comprised of domain model elements. And finally, domain services should be stateless, though they may have side effects. What this means is we should always be able to simply create a new instance of a service to perform an operation, rather than having to rely on any previous history that might have occurred within a particular service instance. But of course, the result of calling a method on a service might result in changes to the state of the system itself. These rules apply specifically to domain services which belong in the core of our application. Your software will likely also use services to perform work related to infrastructure or as part of the front end of the application. ‑Here are some examples of the kinds of services we might find in different layers of a DDD application. The UI layer represents the front end of the system and should have as little business logic as possible. It is frequently combined with the application layer, which should be concerned with behavior necessary for the application, but unrelated to the customer&rsquo;s problem domain. For example, the application may need to work with file formats or parse some XML, and it might have services for these purposes, but these are unrelated to the domain. In the core of the application where we store our core model and domain objects, we will define any domain services for operations that don&rsquo;t belong somewhere else. These services will frequently involve operations on multiple domain elements or may be responsible for orchestrating some kind of workflow. For instance, processing an order might involve a series of steps and multiple domain elements as the system checks inventory, verifies customer information, maybe charges a credit card, and then sends messages to ship the order, notify the customer, and reduce inventory. Finally, we have infrastructure‑level services. These will usually implement interfaces that are defined in the core of the domain, such as I send email. But since they require access to external dependencies, like file systems, databases, or network resources, they live in the infrastructure layer of the system. With respect to our domain, you may find infrastructure not very interesting, ‑although the people who create the internal workings of those services might find them quite fascinating. We&rsquo;ll look at implementing services in our application later on in the course.</p>
<p>Review and Resources
Let&rsquo;s review some of the important terms you learned in this module. You heard us talk about immutability, which is a really critical attribute for value objects. And immutability just means once an object has been instantiated, you can&rsquo;t change the value of any of its properties. ‑Another important term we learned about is the value object. A value object is an immutable class that is defined by the sum of the different properties that it has. We don&rsquo;t need an identity for a particular value object. In fact, a value object doesn&rsquo;t have any identity outside of the individual properties that it has. And in order for us to compare value objects, we simply compare all of its properties, and if they all match, then we can consider these two value objects to be equal. We also learned about domain services and these are interesting because domain services give you a place to put logic and behavior that you can&rsquo;t find a home for in the entities and value objects in your domain. ‑And the last term that we want to review is side effects. Side effects are changes that occur in your application or any kind of interaction with the outside world. Now, technically any change to the state of the application can be considered a side effect, but generally when we&rsquo;re talking about them, we&rsquo;re talking about things that changed other than the main intent of the operation that you&rsquo;re performing. For instance, it&rsquo;s often a good idea to keep operations that query information separate from those that change state, and if you follow this practice, then any queries that you make, that result in changes to state would be said to have side effects. That brings us to this module&rsquo;s key takeaways. Most of this module was focused on value objects, which are used in your domain model to measure quantify or describe something in the domain. Value objects typically don&rsquo;t exist alone, they&rsquo;re usually applied to an entity to describe something about it. ‑Value objects should be compared using only their values. They don&rsquo;t have an identity. Any two value objects that share the same values should be considered equal. And value objects in our domain should be designed to be immutable taking all of their needed values in their constructor and they shouldn&rsquo;t have any side effects. ‑We looked at a few examples of value objects in this module. We mentioned the .NET Framework string type that you&rsquo;ve no doubt used. Strings and datetimes are value objects that are available to any .NET application and can be used as a model for how you should design your own value objects. We also looked at a couple of custom value objects we used in our sample application, the datetime range and the animal type objects. ‑Finally, we wrapped up the module by introducing domain services, which are used to orchestrate operations between different parts of your domain model. Remember that domain services should generally only be used if you don&rsquo;t have an entity or value object where the behavior makes sense. Overuse of domain services can lead to an anemic domain model. In the next module, you&rsquo;ll learn how to build aggregates from entities and value objects while respecting their relationships. Here are some links and resources relevant to the topics of value objects and domain services that we discussed in this module. Thanks for watching Domain‑Driven Design Fundamentals.</p>
<p>Tackling Complexity with Aggregates
Introduction and Overview
Hello, this is Julie Lerman. ‑And this is Steve Smith. ‑Welcome back to Domain‑Driven Design Fundamentals. In this module, you&rsquo;ll learn more about aggregates and the associations between entities. ‑We&rsquo;ve talked about the domain model and the need to have effective communication in order to ensure the model is a useful representation of the customer&rsquo;s problem space. However, most problems that weren&rsquo;t using domain‑driven design can be quite complex. So now we&rsquo;re going to specifically look at some patterns and techniques that can be used to manage this complexity. ‑We&rsquo;ll cover several new terms along the way, including aggregates and aggregate roots. You&rsquo;ll learn about invariants and the aggregate roots&rsquo; responsibility for them. Aggregates often contain related data, so we will explore how to model relationships, often referred to as associations in DDD. ‑Then, we&rsquo;ll look at our application and see how thinking about the aggregate roots pattern helps us revise and simplify our model. ‑And finally, we&rsquo;ll walk through how we&rsquo;ve implemented this pattern in our code.</p>
<p>Tackling Data Complexity
Let&rsquo;s start by considering data complexity. If you&rsquo;ve ever worked on a relatively large or mature application, you&rsquo;ve probably seen some fairly complex data models. One way to reduce the complexity that we already talked about is using aggregates and aggregate roots, which you&rsquo;ve seen in the DDD mind map. Another is by limiting how many bidirectional relationships you have in that data model. ‑If your design doesn&rsquo;t have any clear notion of aggregates, the dependencies between your entities may grow out of control, resulting in a model like this one. And if your object model reflects a data model like this one, trying to populate all of the dependent objects of one object might result in trying to load the entire database into memory. And the same problem exists when it comes time to save changes. With a model like this, there&rsquo;s just no limit to which areas of the data model might be affected. ‑Even though in the real world at the highest levels of your system all of these things really do interrelate, we need to be able to separate them to keep the complexity of the system in check. ‑I&rsquo;ve gone into a lot of clients where their entity data model looks like this, and they&rsquo;re using this one big, huge single model throughout their entire system. So, one of the things that I work on with them is breaking this down and using the whole concept of bounded contexts to start looking at what makes sense for smaller models. ‑Yeah, a system that&rsquo;s designed like this is what we tend to call a big ball of mud because everything is just kind of slapped together, and it collapses under its own weight once it gets to a certain level of complexity. ‑Great. So, let&rsquo;s see how we can use aggregates to help solve the problem.</p>
<p>Introducing Aggregates and Aggregate Roots
Aggregates consist of one or more entities and value objects that change together. We need to treat them as a unit for data changes, and we need to consider the entire aggregate&rsquo;s consistency before we apply changes. In the examples shown here, the address is part of the customer and the component is quite literally a part of the product. We can treat a set of changes to a customer and their address as a single transaction. Every aggregate must have an aggregate root, which is the parent object of all members of the aggregate, and it&rsquo;s possible to have an aggregate that consists of just one object, in which case that object would still be the aggregate root. ‑In some cases, the aggregate may have rules that enforce data consistency that apply across multiple objects. For instance, maybe our product consists of a collection of components, but in order to be in a valid state, it needs to have a specific set of such components. As an example, if the product is a Lego minifig, the collection of parts won&rsquo;t be a valid product unless it includes a head, an upper torso, a lower torso, two arms, two hands, and two legs. If we allowed the collection of components to be modified independently of the product it was associated with, we could easily end up with consistency problems. If we want to modify the composition of a product, in this example, we should do so as a transaction, so that we start and end with a valid product. Data changes to the aggregate should follow ACID, that is they should be atomic, consistent, isolated, and durable. It&rsquo;s also the responsibility of the aggregate root to maintain its invariants, such as the number and type of components it requires in the example. An invariant is a condition that should always be true for the system to be in a consistent state. When considering whether particular objects should be treated as an aggregate root, you should think about whether deleting it should cascade, in other words, if you need to also delete the other objects in its aggregate hierarchy. If so, it&rsquo;s likely the object in question should be considered an aggregate root. ‑Another way to think about whether it makes sense to have an object as an aggregate root is to ask, does it make sense to have just this object detached from its parent? In the example shown here, if you&rsquo;re deleting the minifig, then you have to delete all of its parts. Conversely, if you have to delete a head, maybe it got broken, you don&rsquo;t need to delete the rest of the parts. Therefore it doesn&rsquo;t make sense for the head to be the root of this aggregate. ‑In the Domain‑Driven Design book, Eric Evans states this pretty simply, he says, an aggregate is a cluster of associated objects that we treat as a unit for the purpose of data changes.</p>
<p>Considering Associations in Aggregates
When considering aggregates, which, as Evan says is a cluster of associated objects, it&rsquo;s also important to think about relationships between those associated objects, especially those which exist within the aggregate. Before diving into how related entities participate in an aggregate, it&rsquo;s important to learn some important concepts that DDD brings to us when considering relationships among entities. ‑Many developers, myself included, tend to define relationships between classes in both directions. For example, an order has a line item and a line item has an order, a pet owner has pets and a pet has an owner. Many of us tend to think in bidirectional relationships by default. Because domain‑driven design aims for simplicity in the model, we start recognizing more quickly that the bidirectional relationships can often make things overly complex. For instance, I&rsquo;ve often found this to be true when it comes to adding in my persistence layer, and I happen to mostly use an ORM Entity Framework, which brings along its own behavior and assumptions about how relationships are managed. Sometimes the fact that my model includes navigation properties that may not be totally necessary can be the cause of some grief that&rsquo;s led me to take some time to consider if I really need that navigation or not. ‑Domain‑driven design guides you to default to one way, or unidirectional relationships. That&rsquo;s not to say that you shouldn&rsquo;t ever have bidirectional relationships, but that because of the extra complexity involved, you should spend some time considering if that complexity is justified. ‑A relationship, also known as an association, should be part of a type&rsquo;s definition, and we do that using properties that allow us to traverse from one end of the relationship to the other. In this example, we have a client type with a Patients property, and in a patient type, we have a Client property; not just an ID value, but a property that leads to a complete object or set of objects. If you introduce a bidirectional relationship, as shown in this code, using properties that let you traverse in both directions, you should only do so when neither object can be defined without the other. If that&rsquo;s not the case, then you need to be specific about the direction of the relationship, also called the traversal direction, to keep your model design simple. ‑Eric Evans puts it this way, &ldquo;A bidirectional association means that both objects can be understood only together. When application requirements do not call for traversal in both directions, adding a traversal direction reduces interdependence and simplifies the design.&rdquo; ‑So with a DDDI, we can look at our model and ask, can we define a client without identifying their pets? Can we define a pet without identifying the client who&rsquo;s responsible for them? ‑This may sound like a simple set of questions, but it could lead to a whole lot of debate. For example, why would a person be scheduling an appointment if they didn&rsquo;t have a pet? So in the context of scheduling appointments, a client doesn&rsquo;t make a whole lot of sense without one or more pets or patients. ‑Or from another perspective, a cat can&rsquo;t pay a bill or call to make an appointment, so how can we define a pet without a client? These are both pretty reasonable arguments, but neither one gets us anywhere. ‑So, let&rsquo;s start again with defaulting to a one‑way relationship. A client would need a patient to schedule an appointment. A client would not need a patient to pay a bill. ‑Okay, and if we started from the patient end, a patient doesn&rsquo;t schedule an appointment, so that becomes a moot point. Nor does a patient pay the bill. And, you know, because my dog doesn&rsquo;t have a credit card. He can&rsquo;t use the phone very well, either. So, when would you start with a patient and need to know something about the client responsible for that patient? That&rsquo;s an interesting question. So, in the context of scheduling an appointment, one could argue that we should define the traversal from client to patient and that we gain nothing by having a way to traverse from a patient back to a client. You may balk at that notion, but remember that all we care about right now is scheduling an appointment, not all the other possible scenarios where it might make sense to traverse from patient to client. ‑Sure. It&rsquo;s another example of YAGNI, you&rsquo;re not going to need it. In fact, we originally had owner as a property on patient in this context, but we realized it wasn&rsquo;t necessary, so we removed it. However, we kept the ID because we had some scenarios where it was useful. ‑So in the end, we chose to define relationships that traverse from appointment to doctor, patient, and client, and to define one that traverses from client to patients or their pets, but not the other way. ‑You may have experienced another type of bidirectional relationship problem if you&rsquo;ve seen related data gets serialized in your applications. When objects are serialized, the serializer typically traverses all of the object&rsquo;s properties recursively, If there is a bidirectional relationship, it can create a loop that will cause serialization to fail. You can think of saving aggregates in much the same way, and in fact, depending on how your persistence layer is implemented, serialization may actually be required as part of how your app persists its aggregates. In our aggregates, the single direction that we would use would go from the root to its dependents, and never the other way around.</p>
<p>Handling Relationships that Span Aggregates
Aggregates serve as boundaries between logical groupings within our application. We enforce these boundaries by prohibiting direct references to objects within an aggregate that aren&rsquo;t the root of the aggregate. Consider the customer with the address. It&rsquo;s perfectly okay for customer to reference address. Address might be an entity, or it might be a value object; it doesn&rsquo;t really matter in this scenario. What&rsquo;s important, though, is that the only way to get to the address in this aggregate is through the customer. We won&rsquo;t be referencing an address by some identity outside of this aggregate, but that&rsquo;s not the case for customer. Since the customer is the aggregate root, it can be referenced from other aggregates. ‑In this common example, an order might reference a customer. Depending on our context, it might make sense for a customer to reference an order. In this case, let&rsquo;s assume it only makes sense for the order to be central to the application&rsquo;s design. What&rsquo;s not okay is for the order to reference a customer&rsquo;s address directly. This violates the integrity of the customer aggregate. ‑Remember that aggregates and aggregate roots only apply to objects, not data. And when we&rsquo;re talking about references, we&rsquo;re talking about object references, properties that use an object directly. This is especially important with ORMs. For example, if you were to save an address that had a customer object attached to the customer property, there are scenarios in which Entity Framework would involve the customer in the database INSERT or UPDATE, possibly even a DELETE. And this behavior leads to a lot of confusion. I frequently advise developers to just remove the navigation property and use the foreign key ID instead. It&rsquo;s a little more work, but removing some of the ORM magic results in more control over the behavior. And this aligns perfectly with the fact that one common way to enforce aggregates is to replace direct navigation properties in the model&rsquo;s non‑root types with key references, and this reduces the number of dependency relationships within the model.</p>
<p>Evolving the Appointments Aggregate
Since we&rsquo;re dealing with appointment scheduling, our initial design might look something like this. An appointment involves bringing together a patient and a doctor in an exam room for a particular type of exam, and since we&rsquo;ll typically need to know the owner&rsquo;s information when we deal with the scheduling, it&rsquo;s important to have a reference to the client from the patient also. So if we model our system this way, any time we saved an appointment, it&rsquo;s going to scan all of these objects for changes and save them as well. So modeling it this way, the scope of our domain for appointment scheduling is much greater than it needs to be since, in our case, we don&rsquo;t expect to modify any of the other objects when we&rsquo;re creating an appointment. ‑Right, an appointment is basically just a list of resources tied to a particular timespan, it models who, what, when, and where, but it doesn&rsquo;t ever need to change any of these associated concepts. As a result, we can simplify our design by eliminating most of these object relationships from the appointment classes designed. Recall that for an object to be a good candidate for being an aggregate root, it should be the case that deleting an object should also delete the other objects within the aggregate. In the design shown here, if a customer cancels an appointment and we delete it from the system, it doesn&rsquo;t make sense that this should delete all of the associated objects. ‑So here is another perspective on that same model. By simply including the IDs of the related concepts rather than object references, we&rsquo;re able to ensure that creating and changing appointments has a minimal impact on our system when we persist the appointment. This relationship works because an appointment in the real world is really just a note that includes a place, time, and additional details. Adding and removing appointments shouldn&rsquo;t impact the people and places involved, and this revised design reflects this.</p>
<p>Using Invariants to Better Understand Our Aggregate
We do still have a bit more learning to do with this model though. Somewhere in our design, we need to enforce certain invariants about appointments like that they shouldn&rsquo;t be double booked. Our current thinking is that appointments need to include this rich behavior with regard to how they&rsquo;re scheduled. It&rsquo;s the aggregate roots responsibility to verify any invariance the aggregate may have, and in this case, the appointment is still acting as an aggregate root, even if we have eliminated the navigation properties to the other objects that it might be working with. Let&rsquo;s make sure we&rsquo;re clear on invariants and then we&rsquo;ll see how invariants in our application impact our design. An example of an invariant in the real world is the speed of light, which is a constant that you just can&rsquo;t break in terms of the physics of the universe as we know it. Some things in your system must be true in order for the model to be consistent or valid. Other examples of invariants might be that the total of the items on a purchase order do not exceed the PO amount, or that appointments do not overlap, or that an end date on an object must follow the begin date on that object. Sometimes an invariant only involves a single object, maybe a particular property or field such as name is required. In this case, we may model the system such that one can&rsquo;t even create the object without the required information. Our value objects are like this. For example, you can&rsquo;t create an instance of a datetime range object without defining both the start and end time. However, sometimes the invariants involved how multiple objects relate to one another. ‑In the example here, the purchase order and the individual line items would most likely be modeled as separate objects, however, the purchase order would be the aggregate root, and as such, it would be responsible for verifying this invariant. The individual line items on the purchase order probably don&rsquo;t know anything about one another nor should they, so it wouldn&rsquo;t make sense to put the responsibility for enforcing this invariant in the line item object. What about appointments? How does one appointment know whether it overlaps another?</p>
<p>Modeling Breakthroughs and Refactoring
As we focused on these invariants and where they belong in our design, it became clear to us that the appointment didn&rsquo;t really make sense as an aggregate root. If you apply this thinking to our appointment scheduling context, it follows that one appointment doesn&rsquo;t really know anything about other appointments, but the schedule knows about such things. Let&rsquo;s evolve our domain model to follow this pattern and see where that leads us. ‑This feels like a big change to the model, and these kind of epiphanies happen when you&rsquo;re working on the model. But that&rsquo;s not a bad thing. It&rsquo;s not like you&rsquo;ve wasted a lot of time focusing on appointment as an aggregate root. This is the beauty of modeling your domain, having conversations with different people, with the domain experts, because ideas like this bubble up, and suddenly, something big like this becomes clear. So, you&rsquo;re not going to get it 100% right the first time. Your understanding will evolve as you learn more about the domain. And from time to time, you&rsquo;ll realize there are big changes that can dramatically improve your design. In the Domain‑Driven Design book, Eric Evans talks about these breakthroughs in his section about refactoring toward deeper insight. This is really an important part of domain‑driven design, and about a quarter of the book is dedicated to it.</p>
<p>Recognizing Signs of a Misidentified Aggregate
Let&rsquo;s take a look at the signs that Steve and I eventually recognized in our domain, which led us to shift our appointment aggregate to a schedule aggregate. ‑Originally, our solution had the appointment as the central focus of the design. I had figured it would be its own aggregate with appointment at the root and its various properties as its children. As we&rsquo;ve just discussed, that doesn&rsquo;t really work as well as I&rsquo;d hoped, so now we&rsquo;re refactoring the design to introduce a new type, the schedule. Before we show that, though, let&rsquo;s review the original structure and some of the reasons it didn&rsquo;t work as well as an aggregate in our solution. ‑You can see the original structure had appointment in its own folder and marked with the IAggregateRoot interface, which is required for it to be accessible from our repository methods. It has essentially the same properties as the later version, except for ScheduleId, since there&rsquo;s no schedule type yet. And it has the same basic set of methods for modifying its room, doctor, time, and other properties. None of that really changed since all of those operations only had to deal with this single appointment instance. ‑However, when the appointment tried to enforce the invariant that appointments whose times overlap for the same pet should be marked as potentially conflicting, things were a bit messier. You see, this appointment doesn&rsquo;t actually have any association with any other appointments, so the only way to enforce this is to use a repository to get those other appointments for the same date as this one. Since entities don&rsquo;t support dependency injection through their constructor, this means an instance of the repository needs to be passed into this method. Creating this repository instance was the responsibility of the calling code, which may not otherwise have needed it. Note also that because the repository&rsquo;s interface is async, this method must now be async as well, even though no other methods on the appointment entity are async. ‑The real problem here, from a DDD perspective, is that cross‑aggregate invariants should not be enforced by any one aggregate. In the case of something like a unique constraint between all aggregates, you might need to use a domain service, or another approach. However, in other cases, the need to do this may indicate that you&rsquo;ve missed an important part of your model. ‑Right. In this case, the whole thing that the user is interacting with is the clinic schedule, but nothing in our original model referred to the schedule itself. Since some of our business rules, like what to do with appointments that conflict, only make sense at this higher level, it made sense to introduce a change to our model, the schedule aggregate.</p>
<p>Considering Schedule as Our New Aggregate
So, even though the initial design we had was about scheduling, the schedule itself was never part of our model. Once we include schedule as its own explicit object in our model, it makes the design much simpler. Appointments no longer need to know anything about other appointments. The responsibility for ensuring that appointments are not double booked and similar invariants can be performed by the schedule, which is the aggregate root. ‑So, let&rsquo;s see if this passes our other tests about defining aggregate roots. A schedule will certainly help us ensure that appointments don&rsquo;t overlap one another. When we save changes to a schedule, does it make sense to update any changed appointments? Yes, it does make sense. And if we were to delete an entire schedule, would it make sense to delete all of its appointments? Yeah, I think that would make sense also. ‑Yeah, I think this is the schedule for a particular clinic. At the moment, we only have one clinic, but if we imagine a scenario in which multiple clinics each have their own schedule, it wouldn&rsquo;t make sense to delete a clinic&rsquo;s schedule but then keep its appointments floating around. So I think that works. ‑Great. And if a schedule exists for each clinic, then it makes sense to persist the schedule, which means that it needs an ID, and therefore is truly an entity. And when we retrieve a schedule, we&rsquo;ll most likely be filtering which related appointments we want to look at, for example today&rsquo;s schedule or this week&rsquo;s schedule. That would mean we want all of today&rsquo;s or all of this week&rsquo;s appointments from a particular clinic&rsquo;s schedule. It really does make a lot more sense to me to tie the appointments to a schedule than directly to a clinic. Now, let&rsquo;s see how this effects our design.</p>
<p>Exploring the Schedule Aggregate in Our Application
Now I&rsquo;ll show you the new schedule aggregate implementation in our application. In the refactored solution, we&rsquo;ve renamed the folder so that now it&rsquo;s ScheduleAggregate. This folder only includes schedule and appointment, as well as related guards and specifications. In larger applications, it can help to organize your domain model by grouping everything related to a particular aggregate in its folder. Looking at the ScheduleAggregate&rsquo;s code, you can see that it inherits from our common BaseEntity type and uses a GUID for its id key, just like appointment. This lets us set the key ourselves, rather than relying on a database to do it for us. The class is also marked as an aggregate root with an interface. In the next module, you&rsquo;ll see how we use that to protect the integrity of our aggregates. ‑Right. We&rsquo;ll see how that works when we look at our repository and specification implementations. ‑Next, the Schedule&rsquo;s constructor just takes in its id, its dateRange, and its associated clinicId. In our sample, the clinicId is always hard‑coded but in a real application, there might be several clinics using the same software, and they would each have their own ids. The constructor is responsible for ensuring that the incoming values are valid so that it&rsquo;s always created in a consistent state. Schedule has just a few properties. There is the ClinicId, the associated set of appointments, and the DateRange. We&rsquo;re careful to only expose a read‑only IEnumerable of appointments because our aggregate must encapsulate its internal state. We don&rsquo;t want other parts of our application to add or delete appointments without going through the schedule&rsquo;s explicit methods designed for this purpose. Also, the date range isn&rsquo;t persisted since it can vary with any given instantiate ation of the schedule. ‑Yeah, and for performance reasons, you wouldn&rsquo;t really want to load the ScheduleAggregate with every appointment that had ever been made included in it. By using a property like this, we make it clear to the rest of the domain what set of dates this instance of the aggregate holds. The actual population of the appointments that match this range is left as a responsibility of the specification and repository classes that are used to retrieve the schedule from the database. ‑Yes. And the configuration of the aggregate&rsquo;s persistent details is done in the infrastructure project&rsquo;s Data Config folder. This is where every entity&rsquo;s EF Core‑specific mappings and configuration is performed, which keeps these details out of our domain model. You can see here that we&rsquo;re also letting EF Core know that we don&rsquo;t want the database to supply an id when we create a new schedule. We&rsquo;ve marked that property as ValueGeneratedNever. ‑Getting back to the schedule, let&rsquo;s have a look at its methods. The first method is for adding new appointments. Our design forces all new appointments to come through this method, so we don&rsquo;t have to have duplicate behavior anywhere else in the application to take care of whatever should happen when a new appointment is added. It&rsquo;s all right here in one place, easy to understand, and easy to test. The method validates the inputs to ensure we&rsquo;re not adding bad data to our aggregate, and then it adds the appointment. When a new appointment is added, the schedule is responsible for marking any appointments that might be conflicting. It&rsquo;s the right place for this behavior to live, since the schedule knows about all the appointments and knows anytime appointments are added or removed. After marking any conflicts, an appointmentScheduledEvent is added to the aggregate&rsquo;s event collection. We&rsquo;ll see how this works in the module on domain events. The DeleteAppointment method is similar. After deleting an appointment, the schedule needs to once more mark any appointments that might be conflicting. There&rsquo;s also a TODO comment here. These are left as exercises for you to learn more about how to work with the patterns introduced in this course. You&rsquo;ll find a number of TODO exercises scattered throughout the sample. ‑We hope you&rsquo;ll take some time to download the code, run it locally, and try implementing some of the TODO tasks using the existing functionality as a guide. There are a couple more in the MarkConflictingAppointments method, which, remember, was originally on the appointment type when we started out with that as its own aggregate. This method is responsible for detecting and marking appointments that might conflict. The basic rule, shown here, just checks whether the patient has two appointments that overlap. If any such appointments are found, they are updated to set their conflicting property to true. Then, the current appointment&rsquo;s property is set based on whether there are any other appointments that conflict with it. ‑This is an important part of the business logic for this application, and it&rsquo;s encapsulated right in our schedule aggregate. In a lot of data‑driven applications, this kind of logic might be in a stored procedure, or perhaps just implemented in the user interface. But in a domain‑driven application, we want these rules to be explicit and defined in our domain model. ‑The last method on schedule provides a hook for its appointments to use to notify it when changes are made to one of them. Because we don&rsquo;t have navigation properties from appointment back to schedule, we can&rsquo;t directly call methods on the aggregate root from appointment methods. There are a few different patterns we can use to accomplish this task. For this sample, we chose this one because it&rsquo;s simple and easy to follow. This handler simply calls MarkConflictingAppointments, but it&rsquo;s exposed as its own separate method because it could do other things as well, and we don&rsquo;t want to expose the internal behavior of the schedule to the rest of the app. To see how it&rsquo;s used, let&rsquo;s look at the appointment class&rsquo;s UpdateStartTime method. When the application needs to update the start time for an appointment, it will call this method. Because appointment is part of a scheduling aggregate, we know the app will already have loaded the schedule before calling this method. So the second parameter in the method asks for the handler on the schedule that will be called. The call to update the schedule is made after updating the TimeRange property on the appointment, so when mark conflicting appointments is called, it will use the new value for the time range. There are a lot of other ways you can set up this communication, using C# events, static domain events, or some kind of double dispatch approach. They all have trade‑offs, and when you need to do this in your apps, you should choose the one that works best for your app and your team. ‑Let&rsquo;s see the final result in the application. This change to our model of adding in a schedule aggregate made a big difference to how the domain model is organized. It gave us a much better place to put the logic of enforcing business rules around combinations of appointments and business logic that needs to run when appointments are added or removed. ‑Right. Without the schedule, we would have had to use a domain service or something to add behavior around the newly added or removed appointments. But with this design, we can go into the schedule, add a new appointment for Rosie, and then add another one, and you can see the notifications being triggered by the events, as well as the red outline representing the conflict in these two appointments. Not only is our domain model clean and easy to test, but even more important, it actually works! ‑And notice that as we move one of those conflicting appointments to another spot, the red alerts disappear. Good job, Steve! I am so grateful that you let me off the hook for working on the front‑end of this application. You know I&rsquo;m more of a back‑end developer.</p>
<p>Sharing Our Tips for Aggregate Design
So let&rsquo;s step back a moment and review some of the things we&rsquo;ve just learned about designing aggregates. First of all, aggregates exist to reduce complexity. You might not always need an aggregate. Don&rsquo;t add complexity just for the sake of using an aggregate. Another is that entities with an aggregate can only reference the root entity of another aggregate. ‑But you can always use foreign key values as a reference to entities inside another aggregate. It&rsquo;s perfectly okay to use this, and it will avoid the need for when you go to save that aggregate for it to cascade its persistence into other aggregates. If you find you&rsquo;re needing to use a lot of foreign key references to aggregate children often, you may need to reconsider the design of your aggregate in your domain model. ‑Another pointer was don&rsquo;t be afraid to have an aggregate of one, in other words, an aggregate that only has one object in it. ‑And finally, don&rsquo;t forget the rule of cascading deletes. Remember, one test for whether or not a particular object makes sense as an aggregate root is to consider whether deleting that object should also delete all of the other child objects in that object&rsquo;s hierarchy. If it doesn&rsquo;t, then you have probably chosen the wrong structure for your aggregate.</p>
<p>Review and Resources
Once again, we have covered quite a bit in this module. Let&rsquo;s review some of the terms that you learned in this video. The first thing we talked about was an aggregate. An aggregate is a group of related objects that work together in a transaction. The root becomes the entry point through which you do any work with the aggregate, and the root also is what&rsquo;s in charge of making sure that all of the rules that apply to that graph of objects are met. ‑Each of the rules that describes the state that the system must be in in order to be valid is called an invariant. Within our aggregates, we have objects that are related to one another. In DDD, we refer to these relationships as associations. If you use an ORM, you may hear the term navigation properties, which refers to those properties that reference the related objects in the model. And we talked about the importance of defaulting to one‑way relationships, which we also refer to as unidirectional relationships. ‑In addition to these important terms, Steve and I shared a lot of guidance around creating aggregates and roots in your domain models. Nobody wants to work with a big ball of mud. We use aggregates to organize our model. An aggregate is a set of related objects that live in a single transaction while encapsulating the rules and enforcing invariance of that transaction, making sure that the system is in a consistent state. When designing how related objects work together, your job will be easier with one‑way relationships. Use those as a default, and only introduce bidirectional navigation if you really need to. ‑And most importantly, don&rsquo;t resist updating your model as you and your team of domain experts learn more about the domain. Hopefully, most of this will happen early on, and then just once in a while you might have a big breakthrough, like we did when we realized that the schedule made more sense as an aggregate root than trying to have each appointment be its own aggregate. Up next, you&rsquo;ll learn about repositories which are a critical pattern in domain‑driven design. This is Steve Smith, ‑and I&rsquo;m Julie Lerman. Thanks for watching Domain‑Driven Design Fundamentals.</p>
<p>Working with Repositories
Introduction and Overview
‑Hello. I&rsquo;m Julie Lerman. ‑And this is Steve Smith. ‑In this module of Domain‑Driven Design Fundamentals, you&rsquo;ll learn about repositories, another critical pattern for Domain‑Driven Design. ‑We&rsquo;ll start by defining what repositories are, and then we&rsquo;ll provide some tips for working with them, as well as talking about some of their benefits. There are different ways to define repositories and plenty of debate around their use. We&rsquo;ll address some of these points. ‑Next, we&rsquo;ll introduce you to the specification pattern and how it can be really helpful when you&rsquo;re implementing repositories. Then we&rsquo;ll open up Visual Studio again and show you how we&rsquo;ve implemented some repositories in the scheduling app.</p>
<p>Introducing Repositories
‑Now, Julie, if this were an in‑person class, I&rsquo;d definitely ask for a show of hands who has heard of the repository design pattern. I would expect most hands to go up. ‑I hope so too. I think the repository pattern is by far the most popular element of DDD to be practiced outside of Domain‑Driven Design. They can be valuable in so many applications as a way to simplify data access and enforce separation of concerns. When I began learning about repositories and implementing them in my own software design, it had a huge impact on my application architecture. Along with automated testing practices, it really forced me to consider separation of concerns with each method and behavior added to my software. ‑Personally, I love the pattern, and I find it makes it much easier for me to write good, testable code. We&rsquo;re going to talk about using repositories within a DDD application, but if you want to learn more about the pattern itself, you can look in the design patterns library, and I know Julie also discusses using them with Entity Framework in her Entity Framework in the Enterprise course. ‑You can see the repositories are part of the DDD mind map, as they&rsquo;re used to access entities and aggregates. Any system that needs to persist between restarts has some kind of persistent storage for the state of the system, like a database. Many applications focus a great deal of effort on the mechanics of querying, fetching, and translating data to and from objects to the point where it distracts from the model that these objects are meant to represent. And having ad hoc access to the data source also promotes having developers query for any bit of data they want anytime they want, rather than using aggregates. This makes it pretty difficult to manage the consistency of aggregates by enforcing their invariants. At best, the logic for enforcing the integrity of the model becomes scattered among many queries, and at worst, it&rsquo;s not done at all. ‑Applying Model‑First design and separation of concerns means pushing persistence behavior into its own set of abstractions, which we refer to as repositories. Only certain objects, like specifically aggregate roots, should be available via global requests. Repositories provide this access, and through omission, prevent access to non‑aggregate objects, except through their aggregate roots. They give you the ability to constrain the data access, so you avoid lots of random data access code throughout your application. ‑When you think about the life cycle of an object in your application, you should consider two cases. In the first case, you have objects that are not persisted. These objects are created, perform some work, and then they&rsquo;re destroyed. In the second case, you have objects that are persisted. These objects have a slightly more involved lifecycle since after the object is created, it must be reconstituted with whatever state it had when it was last saved. Then it can perform whatever work the application needs it to do, after which it may need to save its state to some persistent storage before finally being destroyed. You can use repositories to manage the lifecycle of your persistent objects without the objects having to know anything about their persistence. We call these objects persistence ignorant because they&rsquo;re ignorant of how they&rsquo;re stored into and retrieve from a data store. ‑In his book, Domain‑Driven Design, Eric Evans speaks quite a bit about repositories. They can be summed up by saying that a repository represents all objects of a certain type as a conceptual set, like a collection with more elaborate querying capability.</p>
<p>Repository Benefits
‑Repositories can add a number of benefits to our application. First of all, they provide a common abstraction for all of our persistence concerns, which provides a means for clients to very simply obtain model objects and to manage their lifecycle. They also promote separation of concerns. The domain logic and the user interface can both vary independently from the data in the back‑end data source that is used by the application. ‑The public interface of a repository very clearly communicates our design decisions. Only certain objects should be accessed directly, so repositories provide and control this access. Another important benefit is that repositories make it easier to test our code. They reduce tight coupling to external resources like database, which would normally make unit testing difficult. Having a repository separate from client code and domain logic means that we can easily make improvements to optimize data access for this application, tuning for performance, adding caching behavior, etc. is all much easier and safer when the code for data access is all encapsulated in one or more well‑known classes. All of this makes your code easier to maintain.</p>
<p>Repository Tips
‑Here&rsquo;s some basic guidance you should keep in mind when designing repositories. First, a repository should have the illusion of a collection of a specific type of object. You&rsquo;ll be adding the objects to the collection, removing them, and retrieving objects from the collection, but that it is an illusion of a collection is important to keep in mind. When you interact with the repository, these are the types of methods you&rsquo;ll be calling, add, remove, and retrieve. Your calling code doesn&rsquo;t care how the repository performs those actions. So in the repository, you might have code that responds to a retrieve method, goes out to a database and gets data, but it could be getting data that&rsquo;s already in memory, or it might be grabbing data from a text file on your computer. ‑Another important recommendation for repositories is to set up access through a well‑known global interface. That way, developers that need to interact with the repository will be familiar with a common pattern for using it. ‑Here&rsquo;s a simple repository interface example. Depending on the size and complexity of your software, you may have a few layers of interfaces. ‑For example, if you anticipate having a number of repositories for a schedule aggregate used in different bounded contexts, you might want an IScheduleRepository interface that not only implements the lower‑level interface, but defines some other methods or properties that every schedule repository is required to have regardless of the bounded context it might reside in. Because a repository acts like a collection, you&rsquo;ll want methods to add and remove objects to encapsulate the underlying data insertion and deletion operations. We&rsquo;ve got these defined in our IRepository. It is up to each concrete implementation to define how add and remove will actually work. ‑It&rsquo;s not unusual to need to add specific query methods to individual repositories. Whether you need a custom subset of entities or a specific way to load entities&rsquo; relationships, custom methods are a simple way to achieve this. For example, if we wanted to fetch a schedule instance with all the appointments for a given day, we could add a method to the ScheduleRepository that might have an EF Core implementation like this one. ‑Likewise, if we just wanted to be able to fetch a client with their patients, we could add a method like this one, which will eager load the patients when it loads the client. Be careful with this approach though, as it can grow out of hand, and your repositories may end up with many different query methods. A simple way to address this is to use specifications instead, which we&rsquo;ll cover later in this module. In addition to these specific tips for implementing repositories, you should also keep in mind these more overarching tips. First, be sure to provide repositories only for aggregate roots that require direct access. And next, keep the clients focused on the model, while delegating all of the object storage and access concerns to the repositories.</p>
<p>Avoiding Repository Blunders
We&rsquo;re not always going to land on the happy path, so we do want to share with you some common problems that you might run into, how to recognize them, and most importantly, how to avoid them. ‑Remember your client code can be ignorant of the implementation of your repositories, ‑but developers cannot. ‑It&rsquo;s important that developers understand how your specific repository is implemented, otherwise, they can run into a number of different problems. ‑So we&rsquo;re talking about not just the developers who are implementing the repository, but also the developers who are using the repository. ‑One of the common repository problems the developers working with repositories often encounter is called an N+1 query error. This is where in order to display a list of rows from the database, you end up calling one query to get the list and then a number of queries equal to the count of that list to fetch each item individually. ‑Another one that I see a lot is when people are fetching related data. With Entity Framework, they&rsquo;re either using eager loading or lazy loading, and especially with lazy loading, there are a lot of developers who don&rsquo;t really know what to expect from it and just because it&rsquo;s easy and it just works, they use it and then run into all kinds of problems because of it. ‑And depending on how your data is structured, sometimes if you&rsquo;re trying to fetch just one or two properties that are represented in a particular column in a data table, you might end up fetching more data than required if you pull back the entire row which might include dozens of columns and a lot of actual data there. These are things that knowing how your underlying data is persisted and how your repository is implemented, how those things work, can make a huge difference in your application. ‑Most of these blunders impact how data is accessed in a data store and that means that one of the best tools you have for surfacing these problems is profiling your data store. Many of the IDEs we use for managing databases have profilers built in, some examples are SQL Server Profiler, Jetbrains DataGrip, and Azure Data Studio. Many of the APIs we use also have logging capabilities that can relate database activity. As a .NET developer, I often use the .NET Core logging API or some of the features built into Entity Framework Core, but most any language you use can do this and all of the cloud providers have ways to trace activity in their various data stores. There are even third‑party tools dedicated to database profiling. The suite of profilers from Hibernating Rhinos is a great example. They have profilers for RavenDB, Azure CosmosDB, and the EF Core, and Hibernate ORMs.</p>
<p>Addressing the Debates Around Using Repositories
Many developers have strong opinions about the use, and some might say overuse, of the repository design pattern. Let&rsquo;s consider some of the common arguments made about repositories. It&rsquo;s worth remembering that like Bjarne Stroustrup&rsquo;s famous quote about programming languages, there are two kinds of design patterns, too. It&rsquo;s no surprise, really, that as the repository pattern grew in popularity, that there would be many complaints about when and how to implement it. ‑Here&rsquo;s one that really gets me. EF Core, the .NET ORM which we&rsquo;re using this course, has a built‑in repository for its data access. It&rsquo;s called the DbContext. I&rsquo;ve heard and read comments from so many people who say never use a repository on top of EF Core because it already has a repository built in. And then I hear others who say you should always use a repository to interact with EF Core. I am not a fan of the words always and never. Maybe it&rsquo;s because I&rsquo;m a libra, who knows. So, these strongly held opinions really frustrate me. What Steve and I want to do here is give you the information you need so that you can make educated decisions about when to use repository and when to opt for something else. ‑Let&rsquo;s remember for a moment what repositories are and where they live in a domain‑driven application. Repositories are abstractions. They&rsquo;re part of your domain model. They define the persistence operations the model will use. That&rsquo;s it. There&rsquo;s nothing in the domain model patterns produced through model‑driven design espousing the use of Entity Framework, or NHibernate, or any other specific vendor tool for doing persistence. It doesn&rsquo;t even know if you&rsquo;re doing Java or .NET. It&rsquo;s meant to be totally abstract and just types. ‑The domain model should be persistence ignorant, and it shouldn&rsquo;t depend on implementation details. ‑Right. One of the things I really appreciate about DDD and the way it isolates domain expressions within a layered architecture is that it aligns perfectly with SOLID design principles, like the dependency inversion principle. ‑You are a big fan of SOLID, Steve. ‑Guilty! In this case, in terms of SOLID, using an abstraction for persistence enables us to follow dependency inversion because we can define an abstraction in our domain model and then implement it in another project that depends on the domain model. We can also write our application and its user interface so that it depends on our persistence abstraction, too, rather than on the implementation details. That&rsquo;s the heart of dependency inversion. ‑And that makes it easier to follow the interface segregation principle, which I also learned about from your SOLID course. This principle prefers smaller interfaces, so if your app is using a DbContext directly, that is not a small interface. Along with DbContext repository features, it exposes a lot of other functionality. Using an abstraction that limits what your app needs to do with regard to persistence makes for a much simpler design in our model, reducing complexity. ‑Right. In that way, it&rsquo;s similar to the facade pattern because it lets us work with a much simpler view of what could otherwise be a potentially very complex and powerful persistence library. ‑So, when we&rsquo;re following DDD, our domain model shouldn&rsquo;t know anything about EF Core, or whatever APIs you&rsquo;re using for your data persistence. If our model requires persistence, like most do, we should define abstractions in the model that describe what our needs are without specifying how they&rsquo;re done. ‑Exactly. The abstraction defines what needs done, the specific implementation is all about how to do it. ‑And one really popular and powerful way to do persistence in .NET is with Entity Framework Core. And because it implements methods that map pretty closely to most common persistence abstractions, it&rsquo;s usually pretty easy to implement a particular abstraction with a class that calls into EF Core. ‑Definitely. ‑EF Core works great for this in most of the apps I work on, but we should never couple it tightly to our domain model. ‑Exactly. The whole point of DDD is that we shouldn&rsquo;t be coupling our domain problems with our persistence problems.</p>
<p>Returning IQueryables: Pros and Cons
Another question I get all the time, and which I&rsquo;ve discussed in some of my other Entity Framework courses, is whether repositories should return IQueryable, and yes, I do have my opinions on that. ‑Yes, this is another source of some debate. On the face of it, it sounds like it would be a great idea. Your most basic repository abstraction might not provide much in the way of complex filtering options and you can avoid having to think about that sort of thing if you just return an IQueryable. ‑Right, because then any code that consumes an IQueryable can extend the expression adding additional filters or projections to the query before it&rsquo;s actually executed. On the surface, it sounds pretty good, right? ‑Well, it turns out that a lot of query logic is actually business logic, and if you return an IQueryable, it has two not‑so‑good effects. It can leak a lot of the implementation details so your application code&rsquo;s behavior changes significantly based on the implementation of the repository and it tends to put the business rules for querying all over the application. ‑Let&rsquo;s say we have an MVC application with a controller so that&rsquo;s the server‑side logic of the UI layer and it returns a view to the UI. The controller calls into a service to get its list of customers and the service contains a customer repository interface. That repository calls into an infrastructure project and the infrastructure project is where we&rsquo;re using EF Core and it&rsquo;s DBContext, but to limit what&rsquo;s exposed outside of the infrastructure project, there is a repository there as well. The repository and the service makes its calls to the repository in the infrastructure layer. It sounds like a lot of layers, but that&rsquo;s not a problem because we have reduced coupling and made a maintainable solution. The real problem here is where can we put our query logic in this example? ‑Well obviously the repository, and it wouldn&rsquo;t be unusual for the method in the service to further modify the query, but since it&rsquo;s also returning an IQueryable, the controller action could further modify that same expression tree, and assuming the controller just passes that same IQueryable to the view, which we&rsquo;ve both seen teams do, even the view could further refine the query. So is this a good thing or a bad thing? ‑Well on the plus side, we get a lot of flexibility without having to write a lot of code for our repository. We&rsquo;re also able to tailor the data we need to the specific place it&rsquo;s used and even modify the query from multiple steps in the app. At the same time, we get to reuse a simple repository interface everywhere in our app. ‑Right, but on the other hand, that query logic is now spread out everywhere. Every class that&rsquo;s adding query logic, in addition to whatever else it&rsquo;s doing, is now violating the single responsibility principle. Then there is separation of concerns. Query logic should be separate from other concerns in most of these classes. ‑And another problem I see a lot with this approach is confusion about when the actual query is executed and what runs on the database server versus in‑memory in the application. ‑Many developers will assume the query runs inside the repository and the result they get back is from the data store. And of course that&rsquo;s true for most calls, but not necessarily for those that return IQueryable. ‑Right, the query will execute the first time any code tries to enumerate the result. That could happen inside the repository, but it could also happen in the service, or in the controller, or even in the view. ‑Yeah, I see that a lot. a related issue is that developers at any step of this process can add additional logic that may compile just fine, but then at runtime when EF tries to interpret it, it blows up. ‑Anything you add to the query expression that Entity Framework doesn&rsquo;t know how to translate into SQL is likely to cause an exception, at least with recent versions of EF Core. ‑And it may be redundant at this point, but it&rsquo;s probably worth adding here that there is no encapsulation when you use this approach. ‑There is a way we can fix at least some of these issues though. For example, instead of returning IQueryable, we can still create flexible repository methods by passing in predicates. Then in the implementation, this predicate can be passed along to the DBContext as its Where expression providing the necessary filter. If you&rsquo;re not familiar with the term predicate, but you&rsquo;ve used the link where method, that&rsquo;s what the method takes as its parameter, which is why we&rsquo;re able to pass it right to the WHERE clause. ‑That does help part of the problem. Where before the query could have been executed at any of these points, at least now we know that whatever comes back from the repository will be the in‑memory result. The actual query is always executed in the repository itself. Of course, if the service takes in a predicate, it still means that any code anywhere in the system could be responsible for creating the query logic with the possible exception of the view if it&rsquo;s just being passed an IEnumerable at this point. ‑Okay, so with predicates, they&rsquo;re still very flexible, but they&rsquo;re not as easy to build up from multiple locations in your application, especially compared to IQueryable. The rest of the good points still hold though. ‑The only thing we&rsquo;ve really changed on the bad side is confusion about when the query actually executes. Being a fan of solid and encapsulation and knowing some other patterns we&rsquo;ll share later in this module, I&rsquo;m usually going to vote against this approach too. ‑Well another way we tend to solve this conundrum is going the custom query route. We even suggested this as a tip earlier, but you can definitely take it too far. Every little change to a query means another method, customer with orders, customers by shoe size, by shoe size, customers by favorite Netflix show. Hey, you never know what problems your domain experts are going to share with you. ‑The problem with this approach if it goes beyond one or two methods, is that you really start to feel the pain of the open/closed principle violation. Every time another custom query requirement comes in, you have to change the repository abstraction and all of its implementations, and the bigger the type gets, the more it violates the interface segregation principle, too. The more complex your problem is, the more query methods you&rsquo;ll be adding to your solution. This can surely be an untenable situation, and we will show you some better alternatives a little later in this module.</p>
<p>Considering Generic Repositories and Interfaces
Using generic interfaces for persistence is great from a code‑reuse point of view. With just one simple interface, any entity can be persisted using a standard set of operations. If you&rsquo;re using aggregates, you can use generic constraints in this simple marker interface to ensure that only aggregate roots can be persisted using your interface. It can work really well. ‑But there are trade‑offs. What if you have certain aggregates that should never be deleted, but your generic repository includes a delete method? Does it make sense to have operations defined in your domain model that should never be used? This is where you need to make a judgment call. Is the convenience of having a single consistent way of dealing with persistence throughout your model more valuable than having only the necessary and appropriate persistence operations exposed? There&rsquo;s no one right answer. Pick what makes sense for your app, your model, and your team. ‑In our demo, partially for the sake of simplicity, we are using a single generic repository for all of our operations, even though, yes, this means there are operations on some aggregates that are never called and some that never should be called, for example, deleting the entire schedule. ‑If we didn&rsquo;t go that route, our model would need to include separate repository interfaces for each of the aggregates in our model, including schedule, doctor, room, client, and appointment type. Each would define only the operations that were actually needed by the application. For a larger model, this could result in quite a few interfaces, and possibly implementations, but would provide a more pure representation of the domain model. ‑If you do choose to create a generic repository interface, that doesn&rsquo;t necessarily mean you&rsquo;ll implement it generically. You might only choose to create implementations for each aggregate root, which would comply with DDD recommendations. However, it can be convenient to create a generic Repository of T implementation class that you can then use with any entity. ‑This is what we&rsquo;re using in our sample, both for the front desk app and for the clinic management app. In both cases, if you review the sample, you&rsquo;ll see there&rsquo;s very little persistence‑specific code in either solution. ‑If you really like the code reuse you get from having a generic repository implementation, one way to keep it from allowing too much access to the internals of your aggregates would be to use a marker interface, perhaps one that simply extends the entity interface to identify your aggregate roots. Then you can update your generic repository to require this interface, rather than working with any entity. ‑At that point, code that uses the repository won&rsquo;t be able to instantiate the generic repository with non‑root entities, so we&rsquo;re able to use our repository to restrict access to non‑root entities from client‑server model. Using marker interfaces to identify aggregate roots is one way you can enforce your design decisions in your model using the compiler rather than relying on code reviews or other less effective practices. ‑Repository abstractions, especially generic ones, can sometimes get to be pretty large. Large interfaces violate the interface segregation principle, one of the solid principles that I cover in my Solid Principles for C# Developers course. One way to keep these interfaces smaller and more focused is to split them into read and write operations. This is related to the concept of Command Query Responsibility Segregation, or CQRS. Read operations are queries, write operations are commands. There are many benefits to leveraging CQRS that we don&rsquo;t have time to cover in this course, but one area where you may immediately benefit is with modifying behavior related to these kinds of operations. Queries often benefit from data caching, and it&rsquo;s very easy to add data caching to just the read operations. ‑Commands often benefit from being performed asynchronously using a queue, and having a separate interface for commands makes it easy to implement this behavior. These are just two ways you can quickly leverage splitting up your repository definitions between reads and writes. Of course, if you have a lot of different read methods, this can make it more and more difficult to implement custom caching logic, since every new method will also need to be added to the caching layer. Fortunately, this is easily solved by using the specification pattern.</p>
<p>Exploring Repositories in our Application
Steve is going to give you a guided tour of how data access and persistence are handled in the FrontDesk application using repository abstractions. Because he&rsquo;s been fine tuning versions of this demo application for many years, it&rsquo;s quite impressive, and he truly is the best guide for walking you through this implementation. ‑We&rsquo;ll start from the front end of the application, which is our Blazor client. Let&rsquo;s take a look at editing an appointment. Here&rsquo;s an appointment for Julie&rsquo;s dog, Samson. You can see that on the edit screen, in addition to showing the details for the appointment, it also provides us with a list of the doctors and appointment types. When we hit the drop‑down list, we can see all of the different doctors who are available that we could schedule to work with this particular appointment. That&rsquo;s actually accomplished through a back end API that&rsquo;s coming from a different project. Let&rsquo;s take a look at that. We&rsquo;ll start by examining the API using our Swagger endpoint. Looking at Swagger for DoctorEndpoints, you can see that there are two endpoints, one to get a specific doctor by ID and another one that returns a list of doctors. We just saw the list of doctors in action. Let&rsquo;s go ahead and run it again from Swagger. Here you can see the resulting set of three doctors, just like we saw in the drop‑down list. You&rsquo;ll find the code for this particular endpoint inside the FrontDesk.Api project. Within there, there&rsquo;s an Endpoints folder with subfolders for each of the different types of entities that we expose API endpoints for. Inside of Doctor, you can see there&rsquo;s a GetById and a List, and we&rsquo;re looking at the List endpoint here. When we define an endpoint, we simply inherit from BaseAsyncEndpoint, and specify the request type, if any, and the response type, if any. We can also do dependency injection through the constructor, just as you would with a controller. Each endpoint has a single Handle or HandleAsync method, and this is where the actual work of the endpoint is done. You can see in this example that we are simply awaiting on the repository&rsquo;s ListAsync method in order to get our list of doctors. Once we have the list, we map it to our DTO that we&rsquo;re going to actually return, and pass that back as part of that response type. The response, as we just saw in Swagger, includes the Doctors as JSON, as well as a Count property that includes the total number of those doctors. Now let&rsquo;s look a little bit more closely at that repository. You can see in the dependency injection that&rsquo;s occurring in the constructor that we&rsquo;re depending on an IReadRepository<Doctor>, but where is that defined? For that, we need to look at our SharedKernel project. Inside the separate SharedKernel project, which FrontDesk references as a NuGet package, you can see that we have defined an IReadRepository<T> interface. This inherits from IReadRepositoryBase<T>, which is actually itself defined in another NuGet package, the Ardalis.Specification type. The reason why we&rsquo;re creating our own interface here is so that we have complete control over it and we can add additional behavior. For example, in this case we&rsquo;re adding a generic constraint. We&rsquo;ve said that this particular interface will only work with types that have the IAggregateRoot interface attached to them or applied to them. Looking at that particular interface, you can see that there&rsquo;s nothing to it. It&rsquo;s simply a marker. It&rsquo;s a way that we tell the compiler that our intent for a particular class or entity is that it should be treated as an aggregate root. We use that marker to enforce our design and our encapsulation to make it so that we don&rsquo;t accidentally just load up a child entity out of an aggregate, when instead we&rsquo;ve made a design choice that we want to work with that entire aggregate as a unit. You can see that we&rsquo;ve also implemented IRepository<T> similarly. It also inherits from a type that comes from Ardalis.Specification, and also has the same IAggregateRoot restriction. Now let&rsquo;s return to our FrontDesk application and see how we implement this. First, we should look at the DefaultInfrastructureModule. This is an artifact module that defines how we&rsquo;re going to wire up our abstractions with their implementations. And here you can see all the important bits of how we wire up EfRepository to IRepository, as well as IReadRepository. But notice for the IReadRepository we&rsquo;re actually wiring up a different type, a CachedRepository. This acts as a decorator around the underlying EfRepository, and will provide additional caching logic. Inside of the CachedRepository, when we asked for a list of doctors, it actually checked the cache first, and then if it wasn&rsquo;t in the cache, it would go and fetch the result from the EfRepository, which in turn would make the request to the database. We can see in this example here that the logging is showing us that we&rsquo;re actually hitting CachedRepository, and some of the times we&rsquo;re fetching the source data and other times were fetching the data from the cache. The actual EfRepository that is also defined inside of FrontDesk.Infrastructure is shown here, and once more, you can see that there&rsquo;s not much to it. Most of the behavior we&rsquo;re simply inheriting from the EfRepository that exists in the Ardalis.Specification package. It&rsquo;s called RepositoryBase<T>. However, when we inherited it, we were able to add additional constraints, and so you&rsquo;ll see here as well that we specify that this only works with IAggregateRoot. You can see the definition of the RepositoryBase<T> in the Ardalis.Specification NuGet package, which is available on GitHub. The details of it are shown here. The ListAsync method simply delegates to dbContext.Set of the appropriate T type, and then calls its ToListAsync, passing along a cancellationToken if one was provided. Now the last piece of the puzzle is our own AppDbContext. Inside our AppDbContext, we define the DB sets that we&rsquo;re working with and we also pass in some additional configuration. One thing to notice and take away from this example is how many places in our solution we have to reference AppDbContext or EntityFramework. It&rsquo;s almost nowhere in the entire code base. The only place that we talk about it at all is inside of AppDbContext, EfRepository, and some related folders such as Configuration and Migrations. Everywhere else, and especially in our domain model, we&rsquo;re completely persistence ignorant, relying only on abstractions that we&rsquo;ve defined.</p>
<p>Introducing the Specification Pattern
Eric Evans introduces the specification pattern in the original book on domain‑driven design. Although it&rsquo;s covered in Evans&rsquo;s DDD blue book, the specification pattern isn&rsquo;t listed in the book&rsquo;s mind map, and honestly, it doesn&rsquo;t get the attention it deserves. Factories are in the book&rsquo;s mind map, but specifications aren&rsquo;t? Even though in my experience they play a much larger role in producing a clean domain model design. ‑In the book, Evans says that specifications mesh smoothly with repositories, which are the building‑block mechanisms for providing query access to domain objects and encapsulating the interface to the database. It&rsquo;s this powerful combination of specification and repository patterns that truly result in a clean, extensible, and testable design. Let&rsquo;s dig a little more into the specification pattern and how it integrates with repositories before we show you how we&rsquo;ve implemented it in the front desk application. ‑Specifications are used to specify the state of an object, and as such, are primarily used in three ways, validation, selection and querying, and creation for a specific purpose. In our app, we are primarily leveraging specifications in our queries. Create explicit predicate‑like value objects for specialized purposes. A specification is a predicate that determines if an object satisfies some criteria, according to Eric Evans. The most basic specification simply provides a method typically named IsSatisfiedBy, which accepts some object and returns a Boolean. These methods perform their logic in memory, and unfortunately, in remote data querying scenarios, this approach would require every row to be transferred to the application before the specification logic could be run against it. ‑However, more sophisticated specifications can be used in conjunction with ORMs like Entity Framework Core to encapsulate the details of a query while still allowing EF Core to translate the query into SQL that executes on the database server. Our sample application uses such a specification in the form of a NuGet package, ardalis.specification, which is maintained by, guess who, Steve Smith. ‑Recall that one of the benefits of using the repository pattern and abstraction was that it prevented query logic from being spread throughout the application. This was also the reason for not returning IQueryable from repository methods. The same logic can be applied to repositories that accept arbitrary predicates since, again, that means the complexity of these predicates would need to live in the code calling the repository, which might be in the user interface for example. Using repository interfaces that accept specifications instead of custom predicates addresses this problem very elegantly. ‑What about the issue we learned about earlier in this module where generic repositories weren&rsquo;t suited to aggregates with custom query needs? So, individually typed repository interfaces were required, and each additional custom query needed to be added to this new specific interface. Well, specifications solves that problem too. Generic methods accepting generic specifications allows for custom queries where needed for any given aggregate. ‑A few more benefits of specifications. They&rsquo;re named classes that live in your domain model. You can easily unit test them in isolation, or if necessary, integration test them with a test database. They&rsquo;re highly reusable. They keep persistence logic out of your domain and your user interface. They keep business logic out of your database and persistence layer. They help your entities and aggregates follow the single responsibility principle by keeping complex filtering or validation logic out of them. You can easily create your own specification interface and implementation. Feel free to look at the source for ardalis.specification on GitHub and take just the bits you find useful. Or, you can reference that package and leverage all of its features and just start adding the specifications that your domain needs. It&rsquo;s up to you. Either way, you will need to write the specifications themselves. These belong in your domain model. When you don&rsquo;t have many of them, you might just put them in a root specifications folder. However, as your model grows, if you&rsquo;re using aggregates, it may make sense to have each aggregate include in its own folder the specifications that go with it. This makes them easy to locate as they grow in number. ‑Each specification class is a value object, so it should be immutable. Generally, they do all of their work in their constructor. Any variable part of the specification should be supplied as a constructor argument. And once constructed, the specification needs to be supplied to your query implementation. You can use specifications directly with EF Core or you can use a repository abstraction that supports them. In either case, pass the specification to the query object and it will be used to build the query, which is then executed and results are returned. The resulting code for most queries turns into one line to create the specification and another line to execute the query by passing the specification to a repository or a DbContext method. Note that our sample is built on top of a repository abstraction that&rsquo;s provided with the ArdalisSpecification package, and so it&rsquo;s fully compatible with its specification types. We&rsquo;ll look at the code more in the next section. ‑Here&rsquo;s an updated mind map that I have created which shows how specifications work with repositories to define the queries for aggregates and entities. If you&rsquo;ve been using repositories without specifications and have experienced any of the pain points we&rsquo;ve described in this module, try refactoring to use specifications and I&rsquo;ll bet you&rsquo;ll be surprised what a positive difference it makes.</p>
<p>Using Specifications with Repositories in Our App
Now it&rsquo;s time to see just how specifications are implemented in the sample app. While the application code does lean on Steve&rsquo;s specification API, there is still plenty to see. Most of what you&rsquo;ll see here is the application&rsquo;s code, but occasionally you&rsquo;ll also see some of the code that&rsquo;s in the Ardalis.Specification API. Once again, Steve is going to walk you through this demo, and he&rsquo;ll do so from the perspective of how the app retrieves data, starting with the front‑end. ‑When we first load the schedule page in the FrontDesk app, it loads our Blazor WebAssembly application, which then makes some API calls to fetch the appointments and related data. One of those calls is shown here. It&rsquo;s used to get the list of appointments for the schedule. Looking at Swagger, we can see there are a bunch of appointment endpoints. Our API is designed to serve the needs of the client app. Its endpoints won&rsquo;t necessarily match up with how our domain model is constructed, so it&rsquo;s perfectly fine to have an endpoint for appointments, even though appointment is not an aggregate root. It just means we need to pass in the aggregate root ID as part of the request so that we can get the schedule that owns the appointments. If we test the list AppointmentsEndpoint, we can pass in the same schedule ID that Blazor was using, and we get back a list of appointments as expected, and these are, in fact, the same appointments that are being used in the front end. Looking at the source code for this endpoint, you can see that, again, it&rsquo;s in the API project in the Endpoints folder in an Appointment folder, and within that, we&rsquo;re looking at the List endpoint. Now, when we pass in the request, we&rsquo;re specifying a ScheduleId, and if that ScheduleId is missing or empty, then we&rsquo;re going to return NotFound from this API. Otherwise, it uses the ScheduleByIdWithAppointmentSpec to encapsulate the query that it&rsquo;s going to use. On the page in question, we only want the appointments for one day. It&rsquo;s worth noting that this specification does not perform any filtering by date; it returns all appointments for this schedule. We&rsquo;ve left a to do task here for you to implement this behavior by creating a new specification. Now, the specification that we&rsquo;re using here is passed to the repository method, GetBySpecAsync. We&rsquo;ll look at that in a moment. For now, let&rsquo;s take a look at this specification. All of the schedule specifications are in the ScheduleAggregate folder in the Core project. The ScheduleByIdWithAppointmentSpec is pretty simple and has just three details worth pointing out. First, it has a WHERE clause, making sure it only matches schedules that have a matching ID. Second, it eager loads it&rsquo;s associated appointments by using it .Include statement. And third, it implements another marker interface, ISingleResultSpecification. This interface is used to mark specifications that are expected to only return a single result. It is required when passing a specification to a repository method that only returns a single instance of a type rather than a collection or enumerable. Considering that this is being called from a List endpoint on the API, this may seem strange, but remember, we are only loading a single schedule aggregate, and it is then just the container for the set of appointments that the endpoint is going to return. The method the endpoint is calling, GetBySpecAsync, is defined in Ardalis.Specification, as shown here. Note that it has a generic constraint requiring any specification passed to it to have that ISingleResultSpecification marker interface. The sample code is calling this first method, which just works with one entity type and then returns it. If you need to use projection, though, you can use the second method, which operates on your entity type, but returns a different type using a .select. You can use this to optimize queries to return only needed properties. Remember that specifications are useful to define the expected shape of returned data in a query. This doesn&rsquo;t just mean filtering the number of rows using a WHERE clause, but also determining which associations should be brought back with the query, and even which columns should be included. Let&rsquo;s see an example of that. Returning to the specifications for the schedule, there&rsquo;s another one called ScheduleForClinicAndDateWithAppointmentsSpec. One of the newer features in EF Core is &ldquo;filtered includes,&rdquo; and so by adding an include filter, we can make sure that this schedule, which is being used with a particular ClinicId, will only load in its appointments where they are for a given date that gets passed into the specification. You can use this specification, by the way, as an example when you complete that to do task that we just saw in the list endpoint. Compare this code to how we solve this problem in the previous version of this course using custom SQL queries and a custom ScheduleRepository. The specification has replaced all of that with a single specification class containing all the query logic, and the calling code simply needs to create the specification and then pass it to the repository. Unlike custom LINQ expressions that might be anywhere in our application, specifications are easily tested in isolation. In the IntegrationTests project, you&rsquo;ll see several different tests that demonstrate the various schedule specifications and ensures they work as expected. These tests use a real database, since .include logic can&rsquo;t be tested with an in‑memory collection. For the last specification that we looked at, which only includes the appointments for a given date, you&rsquo;ll see that there&rsquo;s an integration test that adds a number of appointments on different dates and then uses a repository to fetch back a schedule using the ScheduleForClinicAndDateWithAppointmentsSpec and a specific date, and it verifies that we only get back the appointments for that date and not the appointments that are on different dates, which verify the behavior of many of the abstractions and implementations in our domain model.</p>
<p>Review and Resources
Once again, let&rsquo;s begin a review with some of the important terms you learned in this module. First, and most importantly, the focus of the module, repositories, which encapsulate the data persistence logic, add, update, delete, and retrieve. In the case of domain‑driven design, we use repositories to focus on aggregate roots. Key to building flexible repositories is the specification pattern, which guides you to encapsulate business rules in a way that they can be passed around and acted upon in other methods, classes or APIs. You learned about persistence ignorance, which describes objects being ignorant about how they are persisted into data storage. It&rsquo;s another critical aspect of domain‑driven design. Steve and I also talked about ACID, an acronym to describe transactions as being atomic, consistent, isolated, and durable. Another acronym we talked about is SOLID, which is a collection of software design patterns. ‑After introducing you to repositories and how they fit into the DDD mind map, you learned about their benefits and some tips for designing them. ‑We also addressed some of the debates around repositories, not only if you should even use them, but how to use them, for example, whether or not to return IQueryables. Many of these debates exist because of the complexity of balancing clean repositories with repositories that help you achieve the variations of queries required by your domain. ‑We introduced you to an often overlooked pattern, the specification, that plays a critical role in solving this problem with DDD. Remember that you are not on your own building specifications. You can lean on the NuGet packages that I created or just dig into my GitHub repo to pick and choose what you want to adopt. Links are coming up. ‑Steve gave you a great tour of how repositories are implemented in the FrontDesk application and then more deeply to see how these repositories are using specifications to provide the rich querying needed in the application. ‑Here are a number of links to not only my GitHub repo and NuGet packages, but a number of other resources we referenced, as well as some additional ones that we think you&rsquo;ll find useful. ‑In the next module, you&rsquo;ll learn about two more critical pieces of the DDD mind map, domain events and anti‑corruption layers, both which help provide some data pathways between the various parts of your software. Thanks again for watching Domain‑Driven Design Fundamentals. I&rsquo;m Julie Lerman, ‑and I&rsquo;m Steve Smith. Thanks for watching.</p>
<p>Adding in Domain Events and Anti-corruption Layers
Introduction and Overview
Hi, this is Steve Smith. ‑And this is Julie Lerman. ‑In this module of Domain‑Driven Design Fundamentals, you will learn about domain events and anti‑corruption layers, two patterns for decoupling how the domain model communicates internally and with other systems. ‑We&rsquo;ll start with domain events, which can be used to separate concerns, allowing different areas of the application to evolve independently, and sometimes helping with scalability as well. You&rsquo;ll learn how to identify domain events in your system, and how to design domain event classes. Then we&rsquo;ll show you domain events being used in a simple application, so you can get a feel for the structure and the workflow. ‑Then, you&rsquo;ll get to see the domain events we built in our sample application, which are a bit more realistic. After this, we&rsquo;ll turn our attention to another important element of domain modeling, anti‑corruption layers, which can be used as translators between bounded contexts and Legacy APIs.</p>
<p>Introducing Domain Events
Domain events are a critical part of a bounded context. They provide a way to describe important activities or state changes that occur in the system. Then, other parts of the domain can respond to these events in a loosely coupled manner. ‑In this way, the objects that are raising the events don&rsquo;t need to worry about the behavior that needs to occur when the event happens. And likewise, the event handling objects don&rsquo;t need to know where the event came from. This is similar to how repositories allow us to encapsulate all of our data access codes, so the rest of the domain doesn&rsquo;t need to know about it. ‑We can also use events to communicate outside of our domain, which we&rsquo;ll look at in just a moment. Another thing that&rsquo;s worth remembering is that domain events are encapsulated as objects. This may be different from how you&rsquo;re used to coding events. It certainly was different for me when I first started learning about them. For example, in a user interface, events are more commonly written as some form of a delegate in another class, but here they&rsquo;re first class members of the domain model. ‑Right. Although you can implement domain events using techniques, like the event keyword in C#, the domain events themselves should be full‑fledged classes. In fact, all of these parts of domain‑driven design are defined as objects in our domain model. ‑Vaughn Vernon describes domain events simply, saying we should use a domain event to capture an occurrence of something that happened in the domain. The domain events should be part of our ubiquitous language. The customer or domain expert should understand what you&rsquo;re talking about when you say when an appointment is confirmed, an appointment confirmed event is raised. ‑You may already be familiar with the idea of events from working with user interfaces. ‑Many user interface clients, like .NET Windows Forms, Electron, or web pages, like the one shown here, make heavy use of events and event handlers. In this example, there&rsquo;s a single page with a single button, and in the markup, you can see there&rsquo;s an onclick attribute in the button that leads to a little JavaScript method defining what the app should do in response to a user clicking the button. ‑Events are helpful because they let us avoid a lot of conditional logic. Instead, we can write code that signals a certain thing has happened, and we can have other code in our system listen for these signals and take action accordingly. So in this kind of code, you don&rsquo;t have a separate class for an onclick event, and it may take some getting used to that now in our model, we&rsquo;re going to create a whole class to represent an event. Domain events offer the same advantages to our model as the events in the user interface. Rather than having to include all of the behavior that might need to occur whenever the state of one of our objects changes, instead, we can raise an event. Then, we could write separate code to deal with the event, keeping the design of our model simple, and helping to ensure that each of our classes has only one responsibility. Essentially, a domain event is a message, a record about something that occurred in the past, which may be of interest to other parts of our application, or even other applications entirely.</p>
<p>Identifying Domain Events in Our System
‑Be especially attentive to these kinds of phrases when discussing the application with your domain experts. When this happens, then something else should happen. If that happens, notify the user when, or inform the user if, these types of phrases frequently refer to situations that are important to the domain expert, the system, or the user. It might therefore be worth modeling these types of things as domain events. You may also discover behavior in the application that will benefit from being treated as domain events that may be the domain expert isn&rsquo;t initially aware of. ‑Remember that domain events represents something that happened. Since we can&rsquo;t generally alter history, this means they should be immutable. It&rsquo;s a good idea to name the event using terms from the bounded context&rsquo;s ubiquitous language describing clearly what occurred. If they&rsquo;re fired as part of a command on a domain object, be sure to use the command name. Here&rsquo;s some examples. ‑Depending on the application, it might be important to have events to represent when a user has authenticated, when an appointment has been confirmed, or when a payment has been received. Be sure to only create events as you need them in your model. You should follow the YAGNI principle, that&rsquo;s you ain&rsquo;t gonna need it. In other words, don&rsquo;t create domain events unless you have some behavior that needs to occur when the event takes place, and you want to decouple the behavior from its trigger. You really only need to do this when the behavior doesn&rsquo;t belong in the class that&rsquo;s triggering it.</p>
<p>Designing Domain Events
Here&rsquo;s some more things to keep in mind when you&rsquo;re creating domain events. We&rsquo;ve already mentioned that domain events are objects, but to be more specific, each domain event should be its own class. It&rsquo;s also usually a good idea to note when the event took place since frequently the code that&rsquo;s handling the event might run some time after the event occurred. It can be helpful to create an interface or a base class that defines the common requirements of your domain events. For example, capturing the date and time the event occurred. ‑Also, when you&rsquo;re designing your event, you need to think about the event‑specific details you want to capture. If it&rsquo;s related to an entity, you might want to include the current state of the entity in the events definition. Think about what information you would need to trigger the event again. This can provide you with the set of information that is important to this event. Similarly, you may need to know the identities of any aggregates involved in the event, even if you don&rsquo;t include the entire aggregate itself. This will allow event handlers to pull the information back from the system that they might require when they&rsquo;re handling the event. Ideally, domain event objects should be lightweight, so you want to be sure you capture sufficient information to handle the event, but not so much that the event object itself becomes bloated. Since the main events are immutable, they&rsquo;re typically fully instantiated via their constructors. And since they&rsquo;re simply noting that something has happened in the system, they don&rsquo;t usually have any behavior or side effects of their own.</p>
<p>Applying Domain Events to a Simple App
We&rsquo;ve put together a simple console application that we&rsquo;re going to use to demonstrate the value that domain events can have in your application. The idea behind this is to strip things down to as small a level as possible. Then, we&rsquo;ll also show how domain events are playing a real role in a more real‑world way when we get to our veterinary scheduling application. This is a .NET console application with dependency injection. The main program just loads the needed services and runs the app. The app has a simple run method, which goes through the following steps. We can step through it with the debugger, so you can see the output in real time. The app loads services and starts running. It shows what happens when an appointment is created using a service. The service calls a factory method that creates the appointment. After instantiating the appointment, the factory method sends an email, which you can imagine includes code like what is in the comments here. Then, it similarly sends a notification to the user interface, again, with code like what&rsquo;s in the comments before finally returning to the service. The service, then saves the new appointment in the database. Then, the app creates a different appointment and saves it directly using a repository instead of a service. And once more, the notifications and the save occur in the same order. Finally, the appointment is confirmed, which triggers some UI notification, and then that change, too, is saved. The main thing to take away from this example so far is that the Appointment class has a lot of concerns. The act of creating an appointment, especially, involves a lot of code that could fail. It&rsquo;s also worth noting that notifications and emails are going out before the state of the entity is saved. So if something goes wrong, users will have been told the operation was successful, and people may have been notified via email when, in fact, the update itself might never go through. ‑The reason we&rsquo;re showing the behavior both from a service and with the appointment directly is because our domains should be designed to work either way. Earlier in this course when you learned about domain services, we explained that forcing all operations on your domain to go through a set of services tends to lead to an anemic domain. Ideally, your aggregates and entities should behave correctly, whether they&rsquo;re being used directly or through a set of services. One way we can improve this design would be to move the responsibilities of actually sending emails or updating the UI to help our methods or other services. Then, we could call them from appointment.create instead of having all the code in here. This would make for less code inside of Appointment. ‑That would definitely be better, but it would still mean that appointment would need to be updated every time a new requirement came along. There&rsquo;s a principle we can use to avoid that, though, called the Hollywood principle. ‑I love the name of this principle. Its name comes from an old saying from Hollywood agents, don&rsquo;t call us, we&rsquo;ll call you. ‑Exactly. Applied to software, the principle is closely related to dependency inversion from solid. Instead of forcing appointment.create to have to know about and call every possible thing that might be involved in the appointment creation workflow, instead, it can just let the app know something happened and let the app respond by calling handlers. ‑Instead of putting all the logic into this method, potentially making it huge and complicated and really hard to read, we move that logic into handlers, and the app calls the handlers. We don&rsquo;t call the handlers, the app calls us. And beyond just reducing the amount of code and responsibility inside Appointment, this approach also lets us make sure that notifications to the user don&rsquo;t occur until persistence is successful. And it still keeps the model&rsquo;s behavior consistent without requiring a service to perform any of the work. Let&rsquo;s see how it works. ‑Domain events is a pretty simple pattern, but you do need to have some plumbing code to support it. You also need to think about whether you want your events to fire before or after persistence. In many cases, what you really want is postpersistence events for the reasons we mentioned above. You want to make sure your persistance succeeds before you send any notifications outside of your app. Also, although occasionally I&rsquo;ve used them for validation in the past, ideally, your domain events and handlers should never fail. That is, don&rsquo;t build your behavior around exceptions that might be thrown from event handlers. Use a different pattern if you need that type of behavior. ‑In this simple demo, which mirrors how our sample app works, we just need a collection of events on each entity. We&rsquo;re creating simplistic types to represent domain events and the respective handlers. You can implement the logic to find and call handlers whenever an event is dispatched in a number of ways. For this sample, we&rsquo;re using the MediatR NuGet package created by Jimmy Bogard. Steve mentioned that you&rsquo;ll need some plumbing to start, and that plumbing is the interfaces or base classes, if you prefer, for handler and domain event classes. In our example, we&rsquo;re using interfaces. Here&rsquo;s the IDomainEvent interface and the IHandle interface. ‑Once you&rsquo;ve set up your event and handler interfaces or base types, it&rsquo;s time to create some events and their associated handlers. ‑For this scenario, there are two things happening, an appointment is scheduled or created and an appointment is confirmed. An event is something that already happened. So we name our events in the past tense, and we have AppointmentCreated and AppointmentConfirmed. The event classes are pretty simple and just include the instance that triggered them, so handlers have access to any properties they might need from it. Once the events have been defined, you just take each individual responsibility out of the original method and create a separate handler for it. It&rsquo;s fine to have multiple handlers for the same event. Ideally, your design shouldn&rsquo;t depend on the order in which the handlers execute. But if it does, you can think about adding a sequence to your handler interface and ensuring they&rsquo;re called in sequence order. ‑The last thing you need to do is register or record the events on the entity. In this sample, that just means adding them to the list of events that are on that entity. The actual implementation for dispatching the events is done in the repository after the save is successful. And in our veterinary sample, this work is done in the DbContext SaveChanges method. ‑Let&rsquo;s step through the code again now that it&rsquo;s using domain events. ‑The app starts up as before. We enter the appointment.create method. ‑And look how much smaller that method is now. ‑Definitely. It&rsquo;s way easier to see what&rsquo;s going on here. Now the domain event is added to the collection, but notice that when we step over this, nothing actually happens yet. ‑Right, it&rsquo;s just holding it until after the entity is persisted. ‑Which is now. Notice that we&rsquo;re in the repository Save method. And for every event that we have stored on this entity, we&rsquo;re using MediatR to publish it at this point in time. ‑This is still in process on the same thread. There&rsquo;s no out‑of‑process queue or anything involved here. ‑Right, there&rsquo;s nothing to install using this pattern except for MediatR, and that just runs in‑memory. And, of course, you could wire this up with your own code that simply loops over your set of events and then dispatches out to your handlers. There&rsquo;s nothing that says you have to use MediatR. Notice in the output that the DATABASE Saved occurred, and then the UI and email notifications. ‑As expected, we only triggered side effects outside our domain after persisting. Now let&rsquo;s see the version that uses the repository directly and doesn&rsquo;t bother going through the service. ‑We basically see the same behavior, DATABASE Saved, UI, EMAIL. ‑All that&rsquo;s left now is the confirm and save, which should look similar, entity saved, and then the UI is updated. ‑That&rsquo;s basically it. I created a small GitHub repo, which has just this sample in it. It&rsquo;s at github.com/ardalis/DomainEventsConsole. There&rsquo;s a branch there showing how things work without events. Of course, you can also download it from the course details. ‑If you want to start your solution with all of this plumbing already in place, you can use Steve&rsquo;s CleanArchitecture solution template, which is also on GitHub. He is one productive guy. Everything shown here is already in place in the template, which is designed for you to use as a starting point for your app.</p>
<p>Exploring Domain Events in Our Application
Now let&rsquo;s look at how we&rsquo;re leveraging domain events in the veterinary FrontDesk scheduling app that we&rsquo;ve been working with. Again, we&rsquo;ll start by showing you the code, and then we&rsquo;ll debug through it so you can see it in action. ‑In our Appointment class, we&rsquo;re going to record a domain event when certain changes are made to the appointment. So, if we scroll down and take a look at the UpdateRoom method, you&rsquo;ll see that it creates and saves an appointmentUpdatedEvent. The same is true for the other update methods like UpdateDoctor, UpdateStartTime, etc. They each will create an appointmentUpdatedEvent and pass it the current instance of the appointment, and then this is saved into the entity&rsquo;s Events collection. ‑In the case of the Confirm method, it&rsquo;s similar, but it creates a different event, an appointmentConfirmedEvent. Essentially, the appointment entity can trigger two kinds of events directly, change and confirmed. And you&rsquo;ll notice it only does so if an actual change takes place. Calling an update that doesn&rsquo;t change the current value will not trigger a new event. ‑Let&rsquo;s take a look at the appointmentUpdatedEvent, and this is similar to the one we saw in the simpler console app in the previous demo. It inherits from BaseDomainEvent, which is defined in our shared kernel, and it adds a UTC timestamp property called DateOccurred that is set when the event is created. This can be useful for debugging purposes. The only other property the class takes is the appointment itself. The AppointmentConfirmedEvent, shown here, is similar. ‑Notice that these domain events are all defined in the core project with our domain model. For this sample, they&rsquo;re in an Events folder in the root. However, in a large application with many events, it might make more sense to put them with the aggregate that they correspond to. In this case, the ScheduleAggregate. There&rsquo;s one more domain event in our sample, which is the AppointmentScheduled event. It&rsquo;s similar in structure to the others, but it&rsquo;s actually created elsewhere. ‑Once you start working in event‑driven applications, it can be a bit more difficult to follow the flow of execution in the app where events are concerned. It really just takes some getting used to, and then you&rsquo;ll find it to be second nature. The best way to see where events are raised and where they are handled is by looking at an individual event and examining its references. Looking at AppointmentScheduled, you can see that it is handled in the API project and in the core project. It is only created inside of the ScheduleAggregate itself. Let&rsquo;s have a look at where that happens. ‑In Schedule, the AddNewAppointment method creates and saves the AppointmentScheduled event after adding the appointment to its collection and marking whether or not it&rsquo;s conflicting. Once the schedule is saved, any appointments that have had domain events added to their respective collections will have them dispatched after the save to persistence is complete. ‑Before we step through the code, let&rsquo;s have a look at one of the AppointmentScheduledEvent handlers. The thing to notice is that these handlers don&rsquo;t get created or called anywhere in our code. That&rsquo;s that Hollywood agent again from the Hollywood principle saying, don&rsquo;t call us, we&rsquo;ll call you. The event dispatching logic, in this case, using MediatR, is what calls these handlers at runtime. But at compile time, nothing references them directly. ‑Now let&rsquo;s see the flow of domain events in our application when we change an appointment. We&rsquo;ll modify this appointment for my little baby, Sampson, and change the appointment from a wellness exam to a diagnostic exam. But a diagnostic exam takes more time, and this will automatically change the duration of the visit, which should trigger a conflict with one of Sampson&rsquo;s other appointments. Yes, he likes to go to the vet quite a lot. ‑The change initially hits the AppointmentUpdate endpoint. It loads the schedule and the appropriate appointment and calls its Update methods. In this case, the only one that has a change is the change to the appointment type. This intern adds an appointmentUpdatedEvent. Once the change is saved, the event is dispatched. The API project also has a handler, AppointmentUpdateHandler, that responds to this event by sending a message to the Blazor client using a SignalR hub. This will trigger a real‑time notification in the app. ‑What about communication between bounded context or apps using events? Applications and microservices frequently use events to communicate, too, but these aren&rsquo;t domain events since they extend beyond a single domain. They&rsquo;re frequently called integration events, and they may be defined as part of your domain or in a separate project or package. For simplicity, ours are here in this IntegrationEvents folder. ‑The FrontDesk has just two integration events, the AppointmentConfirmLinkClickedIntegrationEvent is published by another app and consumed by this one, and AppointmentScheduledIntegrationEvent is an event this app publishes and another app consumes. It&rsquo;s important that the structure of the published and consumed types match, which is why frequently a shared package is used to define these kinds of events. ‑We don&rsquo;t have time to dive deeply into distributed application architecture, but one thing you need to remember when designing integration events is that they typically will be enriched and denormalized when compared to a similar domain event. For instance, the AppointmentScheduled domain event just has a reference to appointment, and that only has IDs for the client, patient, and doctor. However, the integration event includes many more details like client name and email, patient name, and doctor name. The reason for this is to ensure that consumers of the event have enough information from the event to perform whatever actions they need to without having to immediately call back to the publishing app to ask it for more details. You can imagine that the performance of a system would suffer if every time an appointment event was published, one or possibly many apps that were consuming that event, turned around and immediately had to make calls to this app&rsquo;s API asking for client details, patient details, and doctor details. Hence, we have a handler that is responsible for taking in a domain event and enriching it with the additional details shown here on the integration event. We&rsquo;ll put these integration events to use in the next module.</p>
<p>Introducing Anti-Corruption Layers
The last topic we want to discuss in this module is anti‑corruption layers. An anti‑corruption layer, as the name implies, helps to prevent corruption in your domain model. ‑Right, just like superheroes help to fight corruption, these layers provide a sense of security to your model when it needs to interact with other systems or bounded contexts. ‑Returning to our mind map, you can see that the anti‑corruption layer is used to translate and insulate as part of a context map, mapping between a bounded context and foreign systems. ‑When your system needs to communicate with other systems, especially legacy applications that weren&rsquo;t written or modeled as well as your current system, you need to be careful not to let assumptions and design decisions from that system bleed into your model. For instance, if the other system&rsquo;s model includes a customer, even if that customer refers to the same actual business customer, it&rsquo;s likely that it will be modeled differently than a customer in your system. It&rsquo;s best to have a layer that can translate to and from other systems&rsquo; models. In DDD, this is the job of an anti‑corruption layer. ‑Right, like we mentioned in the beginning of the course, even other bounded contexts in your own system may be different enough to merit having an anti‑corruption layer in place to protect the two distinct models from one another. And, of course, legacy applications frequently use very different models from newer systems. An anti‑corruption layer isn&rsquo;t a design pattern, however, it&rsquo;s usually comprised of several design patterns. The job of the layer is simply to translate between the foreign system&rsquo;s model and your own. ‑In addition to translating the objects themselves, the anti‑corruption layer can also clean up the way in which you must communicate with the other system. It may provide a façade to simplify the API or an adapter to make the foreign system behave in a way that is known to your system. You can learn more about these design patterns in the Design Patterns Library on Pluralsight. ‑We&rsquo;re usually most concerned with having an anti‑corruption layer in place when communicating with legacy systems. Eric Evans notes why that&rsquo;s important. ‑Even when the other system is well designed, it is not based on the same model as the client, and often the other system is not well designed. ‑Since this is a fundamentals course, we&rsquo;re not going to dig deeply into anti‑corruption layers, because they can be fairly complex, as well as very customized to each scenario, but here&rsquo;s an example structure of one which comes from Eric Evans&rsquo; book, showing how an anti‑corruption layer can connect your beautiful system on the left with a not so beautiful system on the right. ‑I really like this diagram. I think Eric had some fun putting it together. ‑Gee, what gives you that impression, Steve? ‑Of course, in the middle you can see how the anti‑corruption layer is using a façade and some adapters, but on the right it&rsquo;s protecting us from a big complicated interface, some messy classes, and some things we just don&rsquo;t even want to know about. ‑Right, and of course, your own system is comprised of an elegant class, a very expressive class, and of course even more good stuff, and maybe even some stuff we should be refactoring as well. ‑There&rsquo;s no one way to create an anti‑corruption layer. Whatever you need in order to insulate your system from the systems it works with is what you should put inside of this layer, which should allow you to simplify how you interact with other systems, ensure that their domain decisions do not bleed into your design, and ensure any necessary translation is done along the way.</p>
<p>Review and Resources
We&rsquo;ve covered some new topics in this module, and there&rsquo;s a few new terms that we want to make sure we review. Domain events are a type of object that actually represents something that occurred within the domain that other parts of the system may find interesting and want to tie their behavior to. And this is a great way to keep your system decoupled and to keep your individual objects simpler because they don&rsquo;t have to know about all of the behavior that might occur when some event takes place. We also referred to the Hollywood principle, which can be summed up as don&rsquo;t call us, we&rsquo;ll call you. This principle is related to the dependency inversion principle from SOLID and is frequently used to decouple systems from one another. Instead of us putting all the logic we need in our code, we architect the system so that it calls back to us at the appropriate time. And we put our code into handlers that the app calls, rather than directly coupling our model to these actions. ‑And finally, we looked at anti‑corruption layers, which can be used to ensure that our model that we worked so hard to produce doesn&rsquo;t become polluted by the models of other systems we work with based on objects they wanted to return to us or the type of API that they want us to code to. So we put anti‑corruption layers in place to shield our model from those other systems or bounded contexts that we might work with from our bounded context. ‑In this module, we introduced domain events, and hopefully, you have a good idea of what they are at this point. ‑We&rsquo;ve talked about how you can identify opportunities to use domain events based on the kinds of requirements your customers give you, as well as when you see code in your model that&rsquo;s doing too much and could be more loosely coupled. ‑We gave you some tips for designing and naming domain events, and then we showed them in action, both in a relatively simple console app, as well as in our much larger veterinary clinic sample application. ‑Finally, we introduced the concept of anti‑corruption layers, which use a variety of design patterns to insulate our model from the design choices of other applications or bounded contexts. Here are a number of resources where you can learn more about domain events and anti‑corruption layers. Some of these, including a few Pluralsight courses, we mentioned in this module, but there are others that we find to be relevant, even if we didn&rsquo;t explicitly mention them. ‑Up next, we&rsquo;re going to wrap up this course by adding a new feature to the application. Because of our clean architecture and well‑designed domain model, it&rsquo;s going to be pretty easy to integrate into our existing app. I&rsquo;m Steve Smith, ‑and I&rsquo;m Julie Lerman, and thanks for watching this module of our Domain‑Driven Design Fundamentals course.</p>
<p>Evolving the Application Easily Thanks to DDD
Introduction and Overview
Hello, this is Julie Lerman, ‑and this is Steve Smith. In this module, we&rsquo;re going to wrap up our course on Domain‑Driven Design Fundamentals by showing how we can reap the benefits of our design when it&rsquo;s time to add additional functionality to the system. ‑In this module, we&rsquo;ll first review our current system design and see how it incorporates DDD patterns and practices. Then, we&rsquo;ll circle back to our customer, Michelle, to see how the new vet clinic appointment management system is working out. ‑During that quick conversation, we&rsquo;ll learn about a new feature, and we&rsquo;ll show how we can implement that feature. ‑We&rsquo;ll leverage message queues to implement this feature, so we&rsquo;ll definitely be sure to share with you some of the basics about message queues before we show you that code. ‑The main benefit of our design choices is the ease with which the system can be extended and maintained in the future. And we hope you&rsquo;ll agree that adding to the current design is quite straightforward.</p>
<p>Reviewing Our Current System Design
So far, our system is pretty simple, though it&rsquo;s fairly complex, as most course demo apps go. ‑The system is currently two different web applications, although the user interface makes it look like a single app. Our main focus has been the application used by clinic employees to schedule appointments. There&rsquo;s a lot of complexity with scheduling, so this benefited from domain‑driven design. There&rsquo;s also a clinic management application that&rsquo;s used to do simpler data‑in/data‑out tasks like record keeping and maintaining information about doctors, clients, patients, and more. Let&rsquo;s review the scheduling app a little more closely. ‑We have a single aggregate for a schedule, which contains a number of appointments. We limit access to the schedule through the schedule repository class, which is responsible for retrieving and storing the schedule in our database. We&rsquo;ve identified a couple of value objects that allow us to better model concepts in the domain, and we&rsquo;re making use of domain events to allow our domain in other parts of our system to respond to changes in the state of our model. ‑It&rsquo;s taken us a while to get to this point, but now that we&rsquo;re here, the design of the system is very clean, and it reflects the customers domain, as well as we&rsquo;ve been able to model it so far, of course, given some time constraints. ‑Yes, we do have to ship the app, I mean, this course, at some point. ‑Right, of course, as we build on this application, our model would continue to evolve. But we&rsquo;ve shown you techniques you can use to ensure that you can grow the application without being overwhelmed by the complexity you&rsquo;re trying to model. ‑Actually, as it turns out, the customer does have one more request for us. She said something about customers forgetting their appointments. Let&rsquo;s have another quick conversation.</p>
<p>Addressing a New Feature with the Domain Expert
As it turns out, the customer does have one more request for us. She said something about customers forgetting their appointments. Let&rsquo;s have another quick conversation. ‑Hey, Michelle, great to see you. How are things going with the new scheduling application? ‑It&rsquo;s been fantastic. We&rsquo;re really able to see very easily who scheduled each day, and book new appointments, and move things around is needed, and the front desk folks really appreciate that it highlights the appointments that are conflicting or unconfirmed. That makes it much easier for them. But one thing that&rsquo;s still a problem is the fact that sometimes our clients forget their appointments. It probably happens at least a couple of times every day, and our staff really don&rsquo;t have the time to call every client to make sure they remember ahead of time. ‑So, you&rsquo;d like the system to call them then? ‑Well, we understand there&rsquo;s services that&rsquo;ll do that sort of thing and we might move to that eventually, but for now, if we could just send an email that would probably help remind clients to put it in their calendar. ‑Oh, okay, so, do you want an email to go out when they schedule the appointment or on the day before they&rsquo;re scheduled to come in, or maybe even both? ‑Oh wow, if we could do both, that would be great, one to let them know when they&rsquo;ve booked so that they know that we&rsquo;ve got it in our schedule and another one to remind them that they have an appointment the next day, just in case they forgot. ‑That shouldn&rsquo;t be too hard. Our model already handles certain events that occur, like when appointments are scheduled, and appointments already support being marked as confirmed too. ‑Sure, and I think all we&rsquo;ll really need to build that&rsquo;ll be new is some kind of service for sending the emails and some way for clients to click a link in the email so they can confirm the appointment. Since it&rsquo;s email, it shouldn&rsquo;t be a problem to send these out the day before, even if that day isn&rsquo;t a week day or a work day, right? ‑No, I think that should be fine. It shouldn&rsquo;t hurt anything to send an email on a Sunday or a holiday, and of course, we&rsquo;ll ask our clients to opt into these reminders so we&rsquo;re not sending anything unsolicited. ‑Sounds good. We&rsquo;ll get started, and should have something for you to review real soon.</p>
<p>Planning Our Implementation Steps
Before we get into the gory details of the implementation, we just want to make sure that you understand the very high level of what we&rsquo;re doing here. The first thing is triggered when the appointment is scheduled. And in response to that, our system will send a confirmation email to a client. ‑Once the client gets that confirmation email, they can click a link to confirm that they&rsquo;re going to make it to the appointment, and the system will then mark that appointment as confirmed so that on the schedule, the staff will see that it&rsquo;s got a green box around it, and they should expect the client will actually show up. ‑What&rsquo;s nice about this implementation is that it benefits so much from a lot of the infrastructure we already have in place. And thanks to our DDD‑based architecture, it&rsquo;s just as easy to add in a few extra features that we need to make this work. ‑So as we go through this, you&rsquo;ll see us using some existing and some new domain events, some application events, a number of event handlers and services. One new tool you&rsquo;ll see is something we haven&rsquo;t talked about yet, messaging queues to communicate between separate applications. The application we&rsquo;ve been working with will need to communicate with a public website that the customers will interact with when they confirm their appointment.</p>
<p>Introducing Message Queues
Before we go any further, we did just mention something new, which is message queues. And we just want to talk about that a little bit. It&rsquo;s a pretty advanced topic for this fundamentals course, so we&rsquo;re going to talk about it at pretty much a high level. ‑Message queues are nice to use between applications for a number of reasons. They can help decouple them and make it so that one of the applications can just drop off something into a message queue and continue on with its work and not have to worry about what happens to the message after that. ‑Right, or if whichever application or applications it&rsquo;s trying to communicate with, it doesn&rsquo;t need to worry if that application is available and listening at that very moment. The message can sit in the queue and when the other application is ready to grab it, it does. With a message queue, we&rsquo;re really just dealing with a single message. One application drops it, and the other one takes it, and then the message is gone. ‑Yeah, and there&rsquo;s lots of different implementations of message queues that you can find online. Some of them are free. Most of the cloud services that are out there now have these types of things built in as well. ‑And what we&rsquo;re doing here is dealing with a single message at a time in something of a silo app since we control both applications that are communicating with each other. But sometimes you need to have a lot more flexibility than that, you might actually have a number of applications that are interested in that message and you may not even know in advance or control those applications. So this is when something called a service bus comes into play. ‑Right, so you&rsquo;ll frequently hear about something called an enterprise service bus. And there&rsquo;s, again, a number of examples of these that you can find available. It usually sits on top of message queues and other features. And one of the responsibilities it has is making sure that messages get delivered to the different applications that care about that message. ‑It might even be an application that didn&rsquo;t even exist or you didn&rsquo;t know about when you were first setting up the message queue. So even at that point, because service bus allows you to decouple the routing of the message, it&rsquo;s possible to go ahead and hook up other applications to listen to the queue. ‑Right, so you&rsquo;ll see in our scenario that we have our scheduling application raising an event that an appointment was created. And it might be that maybe in the future we would want to add some other application that wants to react to that event. ‑We could publish it to social media, hey, I&rsquo;m going to go see the vet. ‑Exactly. If we had a service bus, we could simply wire up in our service bus for this new social media notifier service, pick up that event. But with just message queues, as you&rsquo;ll see in our implementation, we would have to change our scheduler application to know about this new app and write to its queue because we don&rsquo;t have any advanced routing, everything&rsquo;s hardcoded in our simple scenario. The message queue we are using is RabbitMQ. It&rsquo;s a mature, open‑source message broker that you can get set up and running with zero install by using a prebuilt Docker container. It has a lot of capabilities, but we&rsquo;re keeping it simple and just using it to define a few specific queues, which are separate bounded contexts we&rsquo;ll use to publish and consume events.</p>
<p>Sending a Message to the Queue
Now let&rsquo;s take a look at how we&rsquo;re adding message queues into our solution. The first part of the process happens when the appointment is scheduled. And you&rsquo;ve already seen our AddNewAppointment method inside the schedule aggregate root. And you saw how the domain uses domain events and domain services to notify the user interface if there&rsquo;s a conflict in the schedule. In the previous module, we showed you MediatR, which we&rsquo;re using to publish these domain events. And we also talked about integration events, which are structured to be shared between different applications. So what we&rsquo;re going to do in our system is add RabbitMQ into the mix at the same point where MediatR is publishing the domain events. But we&rsquo;ll ask RabbitMQ to publish our integration events. These events will be formatted as JSON data before they&rsquo;re inserted into the queue. So let&rsquo;s see what this looks like in the application. We&rsquo;ll be looking at the code that makes all of this work a little further on in this module. We&rsquo;ll go ahead and create a new appointment. Let&rsquo;s bring Sampson in to see Dr. Jones again. So there&rsquo;s the appointment. Nothing has changed from the perspective of the user. RabbitMQ includes a user interface to inspect the queues, and in the Front Desk app the menu has a link so that you can open up this admin page and see what&rsquo;s going on with the queues that are associated with this application. We&rsquo;ll head to the Queues page and then drill into the vetclinicpublic queue, which is a queue that we set up to handle communication between the Front Desk app and the VetClinicPublic app. And you can see that the one and only message that RabbitMQ is tracking is in that queue. So we&rsquo;ll drill into that queue and then scroll down to see the details of the message itself. And the most interesting part, the payload, which is the JSON expression of the event data. You can see the GUID value of the AppointmentId, the ClientName is Julie Lerman, an email address, which is not really my email address, the PatientName is Sampson, and other relevant details that came from the integration event. So the Front Desk app knew to publish the message to this queue, and our VetClinicPublic app knows to read from this very specific queue in order to perform the task of emailing the client.</p>
<p>Reading From the Message Queue and Acting on the Message
Now that the message is waiting in the message queue, it&rsquo;s time to read the message and act on it. And acting on it is the next step in a workflow, sending an email to the client to let them know about the appointment they&rsquo;ve just scheduled. We can&rsquo;t do this easily from our scheduler application because we need for the user to be able to click on a link that specifies that they want to confirm their appointment, so it needs to be publicly accessible. So we&rsquo;ve decided to put this on the veterinary clinic&rsquo;s public website, and so that will be responsible both for sending the emails and for hosting the link that the customer will click. The public site uses a hosted service to periodically check for new things in its queue. Once it finds a message on the queue, it will retrieve the information from that message to create a confirmation email using code like what you see here. One of the most important pieces of this email is a link back to the public website, not really localhost, which includes the GUID that represents the appointment ID. The website then sends the email. That&rsquo;s what the user will end up clicking on in their email and trigger a confirmation using the website. Alright, so now we&rsquo;re looking at the vet clinic public website, which is a super simple demo solution that we put together. And one of the things it does when it starts is start checking for messages, which you can see here. But we don&rsquo;t have it running quite yet because it would&rsquo;ve already pulled the message out of the queue. First, we&rsquo;ll show you the code that&rsquo;s making this all work, and in a bit, we&rsquo;ll step through while debugging. The public website has a hosted service called FrontDeskRabbitMqService, which periodically checks the message queue to see if anything new has arrived. As soon as it finds one of those messages off of the message queue, it&rsquo;s going to send an email, and we&rsquo;re going to use a tool called Papercut, which will emulate a local email server for the purpose of testing. Rather than installing this on our dev machines, we&rsquo;re running a Docker container to host Papercut. You can view emails Papercut has received by clicking the Sent Emails link from the FrontDesk app&rsquo;s menu. Currently, there aren&rsquo;t any emails in Papercut, but as soon as we start the web application, it&rsquo;s going to check our message queue and then send an email that we should see appear in Papercut. There&rsquo;s a message, the same message that we sent out for Sampson&rsquo;s appointment. There&rsquo;s a hyperlink that leads us back to being able to confirm. Let&rsquo;s see first, high level, what happens when we click on that CONFIRM button, and then we&rsquo;ll come back and click it and watch it in action. So now the user has the email, and their beautiful CONFIRM link in the email. When they click that, it opens up the website, browsing directly to the GUID that was their appointment. And in response, the website calls its own method called confirm, which takes the relevant appointment ID and pushes it into another one of the queues. You&rsquo;ve seen the message queue that was used for relaying the message from FrontDesk to the public website, and that was named fdvcp‑vetclinicpublic‑in. Try to say that five times fast. But you can have as many queues defined in your system as you need. And one of the other queues that we&rsquo;ve defined is for relaying messages from the public website, in other words, when the client has clicked on the button to confirm their appointment back to the FrontDesk app.</p>
<p>Using Multiple Queues to Handle Various Communications
Now that the email&rsquo;s been sent, let&rsquo;s see what happens when the client clicks on the CONFIRM link in that email. ‑When we click on that, we&rsquo;ve now confirmed the appointment. Once the user clicks on the CONFIRM link, it drops the message with the confirmation back into the scheduler queue, and you can see that message right here. ‑Yeah, this middle queue shows that there&rsquo;s one message. Let&rsquo;s look at it. We&rsquo;ll scroll down to the Get Message(s) button, and the message is retrieved and displayed. We&rsquo;ve seen this before where the payload is the JSON data we&rsquo;re looking for, and this one contains the appointment ID that&rsquo;s just been confirmed. Now you can see that the two different applications are communicating back and forth with each other using their two separate message queues. We&rsquo;ve named the queues so that it&rsquo;s clear which applications are using them to communicate and in which direction. The initial acronym specifies which two applications are involved. Fdvcp means frontdesk and vet clinic public. The latter part of the queue&rsquo;s name says which app is listening to it. The last step now is for this confirmation information that&rsquo;s sitting in the queue to get back to the scheduling app. ‑Now in our scheduler application, we have implemented a hosted service just like you saw in the public website This one is called the VetClinicPublicRabbitMQService, and it listens to the appropriate queue to see if there are incoming messages that it needs to deal with. When it finds one, it responds to the AppointmentConfirmLinkClickedIntegrationEvent, yes, it&rsquo;s a long name, with the email confirmation handler. The handler looks up the appointment from the AppointmentId that was contained inside of the message, and from there, it calls Appointment.Confirm. Appointment, as you recall, is our entity, and its confirm method also then triggers some domain events, which for instance, our user interface listens to. And when it sees that that event has been fired, it triggers a change in the UI, enhancing the appointment with a green bar across the top to show that the appointment has been confirmed. Okay, so all that&rsquo;s going to happen at this point is that when the message comes through, it&rsquo;s going to make the Sampson appointment right here have a green border and pop up a dialog to let us know that a change has occurred. ‑It&rsquo;s very slick. This is actually really easy to implement because we already had the website listening for events. Remember how it was able to display new appointments and display conflicts? We&rsquo;ve implemented another design role based on a particular property of the appointment, which is confirm. All we did was set up another event handler. ‑We wrote the original sample for the first version of this course in 2013. At the time, things like SignalR and WebSocket, as well as emails with confirmation links were relatively rare, although we certainly didn&rsquo;t invent these kinds of app interactions. ‑Right, but now, every time I make an appointment for my dentist or hair and even for Sampson in real life to go to the vet, I&rsquo;m getting texts or emails with exactly these kinds of confirmation links. ‑I know, I guess maybe a lot of businesses watched our course.</p>
<p>Debugging to See the Detailed Implementation in Code
Now we&rsquo;re going to take a deep dive into the code that makes all this work, and we&rsquo;ll go through it step by step so that you can see how all this is wired together. And we&rsquo;ll do that by literally just debugging through the whole process, so you can see how all the code links up. Remember, all of the code for this sample is available on GitHub, and we encourage you to run it yourself to really understand how it works. The README file has instructions for running the solution using Docker, which is the recommended approach if you just want to see it running. There are also instructions for using Visual Studio or VS Code, which you will need if you want to debug the apps as we&rsquo;re about to do. For instance, I need to run RabbitMQ and PaperCut using the Docker commands shown here, before I can debug the app, as we&rsquo;re about to see. We&rsquo;re back in the vet manager, and the user is on the phone with Steve who wants to make an appointment with Darwin. Everything works just the same way it&rsquo;s worked before. We&rsquo;ll go ahead and add a new appointment and save the appointment, which triggers the ScheduleAggregate root&rsquo;s AddNewAppointment method. We&rsquo;ll leave the Locals window open while we&rsquo;re debugging so that if you want to pause the video and take a look at any of those values, you can do that. We haven&rsquo;t changed anything in the method. The only thing that&rsquo;s different is that now we&rsquo;ve got an additional subscriber that&rsquo;s listening for this domain event, this particular domain event, the AppointmentScheduled event, to be raised. So we&rsquo;ll go ahead and raise the event and watch what happens. At this point, we&rsquo;re looking at a new class that we created, which is this RelayAppointmentScheduled service, and what it&rsquo;s responsible for is creating the event that is going to get pushed onto the message queue that the public website is listening to. This is the new piece of logic that&rsquo;s listening for the event that we just raised. You can see it&rsquo;s listening for AppointmentScheduledEvent, a domain event, and in the method, the first thing we do is to create the AppointmentScheduledIntegrationEvent that represents our cross‑domain message that will be sent using RabbitMQ. The functionality we need from this event right now is to be able to send an email to the client, so we make sure to include all of the data that such an email would require. Now we&rsquo;re in the Publish method that lives inside of RabbitMessagePublisher, and that&rsquo;s inside of an infrastructure project. We&rsquo;ve moved out of the core domain, but this is still part of the main front desk scheduling application. Yes, and what it&rsquo;s responsible for doing is actually getting that message into a structure, a format that RabbitMQ can use. That means putting things into JSON format in this case, and then actually sending the message. Once this fires, we should be able to inspect the message queue in RabbitMQ, and verify that our message has actually been queued up for the VetClinicPublic input queue as expected. That&rsquo;s what we did before, but this time we&rsquo;re actually seeing the code that&rsquo;s making all of this happen. Alright, so that completes the actual thread of the UI. The response is complete for this part of the application. Now we&rsquo;ll pause this and switch over to the VetClinicPublic application. We&rsquo;ve just started it up again, and we&rsquo;ve shown this to you before. Now we&rsquo;re going to watch the flow of the code after the hosted service starts up. Jumping to the next breakpoint, you can see now we&rsquo;re inside of the actual HandleMessage method, which gets the message as a string. It&rsquo;s responsible for parsing the string using JSON, and deserializing it into an appropriate type. This is just demo code, so it&rsquo;s not the most reusable or elegant, but it works for this app. Remember that any change to the integration event in the front desk app will require changes here as well, which is one reason why a shared package can be useful for keeping applications in sync. Once we&rsquo;ve deserialized the message into a command, we use mediator to send the command, and a separate handler to actually send the email. This keeps extra code out of the hosted service, and lets the handler use dependency injection to get any services it needs. In this case, it&rsquo;s an implementation of, I send confirmation emails, called ConfirmationEmailSender. It&rsquo;s the service that builds the email with its details, including the URL behind the CONFIRM link in the email that the client receives. Remember, the whole reason why we need a separate app to implement this feature is that the end user needs to be able to click a link that goes to a public location on the internet. The front desk app is an internal app that runs inside the vet clinic&rsquo;s network so it&rsquo;s not accessible. The public website is a good place to send users, and while they&rsquo;re there, they can get more details about the clinic, or buy something from its theoretical online store, etc. After the email has been sent, we can see it in PaperCut, and opening it, we can see the CONFIRM hyperlink. Clicking the link brings us back into the VetClinicPublic application&rsquo;s, AppointmentController class. This endpoint simply creates a new event. This is the one with a really long name, AppointmentConfirmLinkClickedIntegrationEvent. Unlike the name of the event, the message itself is really simple, and just includes the appointment ID that was confirmed, and when it happened. The controller action then sends the event using a RabbitMQ messagePublisher that&rsquo;s identical to the one we just saw the front desk app use. However, this publisher&rsquo;s destination is actually a different queue, the front desk input queue. Technically, the front desk has two input queues, one for messages from the ClinicManagement app, and another for messages from the VetClinicPublic app. In this case, we&rsquo;re talking about the VetClinicPublic one. Back in the front desk scheduling app&rsquo;s hosted service, it discovers the message on the queue, and calls into the HandleMessage method in the service we&rsquo;ve seen a number of times, the VetClinicPublicRabbitMqService. Here, it parses the message and extracts the appointment ID, which it then uses to create and publish that really long‑named event again, AppointmentConfirmLinkClickedIntegrationEvent internally. This integration event triggers a call to the EmailConfirmationHandler, which loads the schedule aggregate, then locates the appropriate appointment, and calls its Confirm method. Finally, it saves the schedule. The appointment.confirm method makes an appointmentConfirmed domain event, which is fired once the aggregate is saved, and this event in turn triggers a handler in the UI. The appointmentConfirmed handler in the FrontDesk UI sends a message via SignalR, indicating the message was confirmed. This results in the browser showing a notification, and changing the format of the appointment to have a green border. You already saw similar logic used for the AppointmentUpdate and AppointmentScheduled handlers. That&rsquo;s the full round trip for how creating an appointment, getting an email, clicking a link, and confirming that appointment works for this application.</p>
<p>Considering Microservices
Since we published our original version of this course, which if you haven&rsquo;t watched, you&rsquo;ll find a link from either of our author pages, microservices have become incredibly popular. There are some benefits to microservices, even if they&rsquo;re probably a bit overhyped at the moment, and there are some obvious parallels between microservice design and DDD. ‑Microservices should be self‑contained and should not depend on other microservices. They should be independently deployable. Changing the internal behavior of a microservice should not break services that work with it, as long as it maintains compatibility with its external APIs and message interfaces. ‑So, basically what you&rsquo;re saying is each microservice should have a boundary around it, and within that boundary it should focus on a specific set of behaviors that its free to model however it sees fit. ‑That&rsquo;s right. ‑It&rsquo;s almost like each microservice can be considered its own context, and it has its own terminology and even language for how it&rsquo;s designed. ‑It is a lot like that, it&rsquo;s true, and it&rsquo;s not unusual for teams to treat individual microservices like bounded context with their own ubiquitous language and everything else that goes along with being a bounded context. But, beware of assuming that microservices and bounded context always have a perfect alignment. There can be plenty of scenarios where this could be a problem. My brilliant friend, Vladik Khononov, not to be confused with the also brilliant Pluralsight author, Vladimir Khorikov, has shared his experiences along these lines in his blog and also in recorded conference presentations. We&rsquo;ll include links to his content in the resources at the end of this module. ‑Now, this isn&rsquo;t a microservices course, but obviously if you&rsquo;re working on microservices, it would be helpful for you to have a good understanding of DDD concepts, because many of the problems that microservices solve are also solved by domain‑driven design. ‑In our sample application, there is an obvious candidate for a microservice. In fact, it&rsquo;s almost there already, the confirmation email sending logic that currently runs inside the public website. ‑We put the hosted service in that existing web application because it was convenient and because the two are loosely related since the emails include a clickable link that goes to a page on that public website. ‑But we could easily move that hosted service into its own process and treat it like a separate microservice, and that would simplify the public web app, so it would no longer need to have a two‑way relationship with a front desk app by way of message queues. Also, the front desk app is likely to be updated more frequently than the confirmation email logic, so it&rsquo;s possible that changes to the front desk application could break the email logic. ‑Yes, one of my favorite benefits of carving out a microservice is that if it&rsquo;s something stable and working, you get the benefit of just leaving it the heck alone. Updates to other parts of the app or system are much less likely to break a microservice that is in production and working, and not being deployed frequently. ‑Right, and the email sending logic is about as micro as a microservice can get, but in the future we might want to add other kinds of customer emails to send, and it would be a logical place to hold that logic. ‑Exactly, and since it has no user‑facing logic, it&rsquo;s a pretty simple change to make. Maybe some of our students could do that as another exercise.</p>
<p>Sharing Some Tips for Extending and Running the Sample Application
As we wrap up the course, we want to remind you, once more, that there are a number of to‑do items in the sample that you can use as ideas for ways to extend this demo app. Doing so would help you gain real experience working with the architecture and patterns you&rsquo;ve learned in this course. You&rsquo;re sure to learn and retain more from actually working with the code than from just listening to us or watching us show you the code. ‑We do have detailed instructions in the README for how to run the app. You can run the individual solutions in Visual Studio, but if you do so, keep in mind, you&rsquo;ll also need to make sure you have a local SQL Server running, and you&rsquo;ll need to update the connection strings and app settings for the applications to access it. You&rsquo;ll also need your own RabbitMQ and Papercut or similar test email server running, either as Docker containers or locally‑installed services. There&rsquo;s definitely a bit of effort involved in getting all of this set up and running the first time. ‑Alternatively, if you just want to run the app and see everything working, you should be able to do so with just two commands, assuming you have Docker installed. Just run docker‑compose build ‑‑parallel and then docker‑compose up. Each of these commands might take a few minutes. It usually takes about 2 minutes for the build step on my machine, and it&rsquo;s normal to see some errors when the docker‑compose up command runs until all of the services are up and running. Once the process stops outputting messages to the log window, you should be able to hit the application. To do that, take a look at the ports that are shown in the README file. And in the Docker column, you&rsquo;ll see the ports for all of the different applications and utilities that are used.</p>
<p>Considering the UI in the Domain Design
The control we used solved a number of the problems we thought we were going to have when embarking on this application. But the fact that the UI kind of impacted how we designed our domain begs the question about, well, if you&rsquo;re totally focused on the domain, why would you even be thinking about the UI? But thinking about the UI while we&rsquo;re working on the domain is not the anti‑pattern you may think it is. ‑Yes, we&rsquo;ve been focusing on the domain, but frequently the user interface needs to be considered, especially in the early stages of planning. You don&rsquo;t want to try to flesh out the whole domain design before you start thinking about the UI. ‑In a TechEd session I attended in 2013, Jimmy Nilsson, who&rsquo;s the author of the book Applying Domain‑Driven Design and Patterns, talked about the importance of thinking about the UI in the early stages of planning and revisiting it while modeling the domain, rather than ignoring it until the end. In his session, he describes how even the UI sketching he does in the early stages of his application planning can affect the whole design of the system. As we were building this scheduler sample for this course, we actually discovered a huge benefit to considering the UI early in the process. We initially had expected to encounter a lot of complexity in the appointment scheduling problem, but we found a UI control that helped visualize the schedule for the user, such that the system no longer needed to be as complex. In our scenario, scheduling is a big part of the application, but it isn&rsquo;t our domain, our domain is the veterinary clinic. We consider scheduling to be more of a cross‑cutting concern, and one that could be partially solved through a rich user interface. ‑By considering and using a rich user interface, we were able to do things like allowing conflicting appointments while making it obvious to the user that this had occurred. This gives the user more information, and they can make decisions about whether or not they need to correct the problem. When we initially considered the problem of appointment conflicts, we had thought the domain model would throw exceptions anytime something like that occurred. But this would have resulted in a much worse user experience. Frequently, in domain‑driven design, you need to consider the user experience, which at times may need to allow for models that are, at least temporarily, in an invalid or incomplete state. Keep this in mind as you design your domain model, and be careful not to make it too rigid to support scenarios your users may benefit from. ‑Thinking about the UI up front and discovering this kind of solution kept us from wasting a lot of time trying to solve certain scheduling problems in our domain. Of course, you don&rsquo;t want your UI to totally drive how you model your domain, but as Jimmy Nilsson notes, you shouldn&rsquo;t ignore it, either.</p>
<p>Modeling with Event Storming and Other Techniques
When you&rsquo;re developing apps using DDD, it can be helpful to visualize how processes communicate both within a bounded context and between context as part of a business process. As we mentioned earlier in this course, Alberto Brandolini has done a lot of work on a related practice called event storming. Event storming can be used by all parts of a business, not just developers, to describe how a part of the business works and to make the whole thing visible. Once this is done, later iterations of the diagrams and artifacts produced can be useful for modeling the software that will be used by the business. ‑You might recall the image we showed earlier of Julie facilitating an event storming workshop with a client. The result of that first iteration, called chaotic discovery, is not so easily captured, but it provides guidance for the later modeling you might do. ‑There are many ways to model your system. Another method, Event Modeling, championed by Adam Dymitruk, is another process, and this focuses on the inputs and outputs of events and how each of those events changes the system and changes state. And you can describe an entire system with this flow. ‑We&rsquo;ve used the wonderful online tool called a Miro board at miro.com to show one perspective of the scheduling system as information flows through the front desk application and into the VetClinicPublic website bounded context. The colors used here correspond to different things in our model, like aggregates, events, and other processes. ‑And there are other modeling processes that have been invented, adopted, and adapted within the DDD community. And many of us rely on a combination of processes and tools to help us and help our clients better understand their systems before embarking on design. But as always, balance is important. You&rsquo;ll want to beware of analysis paralysis. ‑Definitely. That reminds me of something Eric Evans talked to us about.</p>
<p>Eric Evans on the Fallacy of Perfectionism
Steve and I believe that it would be fitting to leave you with one last thought from the father of domain‑driven design, Eric Evans. Eric was kind enough to talk to us about DDD when we originally created this course so that we could share with you some of his wisdom. Eric talked about the fallacy of perfectionism, which aligns with our own sentiments about considering what you&rsquo;ve learned here to be guidance to help you solve complex software problems, not a roadblock to productivity. ‑Eric shared with us that what he&rsquo;s noticed is that there seems to be something about DDD that brings out the perfectionist in people, and they say, this model is not really good enough and churn and churn, trying to improve it. He says, no model is ever going to be perfect. ‑Eric goes on to say that we need to know what we&rsquo;re doing with this thing, the scenarios we&rsquo;re trying to address. We want a model that helps us do that, that makes it easier to make software that solves those problems. That&rsquo;s it. ‑This reminds me of the saying, all models are wrong, but some are useful. Our domain models don&rsquo;t need to be perfect. They just need to help us build the software that helps people solve problems and get work done. Don&rsquo;t strive for a perfect model, but rather just aim to develop a useful one.</p>
<p>Lessons Learned Since Our 2014 Course
Julie and I wanted to finish this course by spending a couple of minutes talking about some of the things we&rsquo;ve learned since we published the first edition of the course in 2014. ‑We&rsquo;ve received a ton of positive feedback from so many of you over the last few years, and we really appreciate it. So we did our best not to change the overall flow of this course too much since we know the last one was so well‑received. ‑Definitely. If you watched the original version, hopefully you found this one to be fresh, but familiar, and I suspect a lot of students will end up watching both as a way to cement some of these concepts or just to spend more time with us, right, Julie? ‑Maybe. Now let&rsquo;s highlight some of the things that have changed in the last few years. From a strict DDD perspective, there are a lot of new resources and techniques that have emerged as more and more companies are adopting DDD. Things like event storming an event modeling, which we&rsquo;ve touched on in this course, are starting to become mainstream parts of DDD for many organizations. ‑Yes, and the industry&rsquo;s use of some patterns have shifted too. There&rsquo;s a lot of pushback against the repository pattern these days. I think, in part, because it became very popular, but was often used without the context of DDD or other complementary patterns like the specification, and these can really help it shine. Our first course didn&rsquo;t really talk much about specification as a core DDD pattern, but it&rsquo;s something I use on most of my projects now. ‑From a technology perspective, our previous course was built for .NET developers, and at the same time, that meant .NET 4. The original veterinary application used ASP .NET, MVC, and Web API, and an early version of SignalR. And for data access, we used Entity Framework 6. ‑Since then, .NET Core, which is now .NET 5, has shipped and become the new standard for .NET developers, and the latest versions of EF Core have added a number of features that we&rsquo;re leveraging to help improve the design of our model like owned objects and filtered includes. We also shifted our use of domain events from being prepersistence to postpersistence. There are valid use cases for both kinds of domain events, but the latter is safer for any events that communicate outside of the domain, so we&rsquo;re defaulting to that this time around. ‑Right, especially since one of our key demos involve sending emails to the client. The original sample also used SQL Server for its message broker, which we chose because we didn&rsquo;t want to force our students to have to install a custom tool. But Docker is another technology that wasn&rsquo;t mainstream in 2014, but it is today, and it makes it a breeze to use custom bits of infrastructure. In this update to the course, we&rsquo;re definitely leveraging Docker to provide RabbitMQ messaging with 0 install, as well as to capture emails during development using Papercut in another Docker container. ‑Yeah, Docker should really make it trivial for students to run the application locally, even though it has a bunch of moving parts. If you don&rsquo;t have Docker, you can still run it in your IDE or from the command line, but with Docker, it&rsquo;s just a lot simpler to get going. ‑And along with Docker and containers, microservices have become a huge buzzword in the industry. Of course, Docker makes it much easier to deploy microservices, and DDD principles really shine when designing them. So all of these things, I think, are really complimentary. ‑Definitely, although I do think some companies are too quick to jump to microservices without fully understanding their domain and where to separate out different contexts. And on the topic of separation, our previous sample put everything in one giant solution, too, mostly to make it easier to find things. ‑This time, we went with something that should resemble a real‑world application even more with separate solutions for each bounded context. We even published the shared kernel as a NuGet package, in our case, hosted on nuget.org, although typically, your organization would probably have a private NuGet feed. ‑If you&rsquo;re still working with .NET Framework apps and you haven&rsquo;t watched the previous course, we encourage you to give it a look. Its samples are geared more toward that framework, and you should find a link to it on Julie or my author page here, on Pluralsight, or at this bit.ly link here. ‑And don&rsquo;t feel bad if it feels like there&rsquo;s still a lot you have to learn about DDD. It&rsquo;s a big topic. And as we&rsquo;ve just shared, Steve and I are constantly learning new ways to apply it, too. Be sure to check out other DDD courses here, on Pluralsight, and if you need direct help for you or your team, you can reach out to Steve or me, directly.</p>
<p>Review and Resources
If you remember nothing else from this particular module, the one thing to keep in mind is how simple it was for us to add in what was potentially a really complicated feature. Because of our DDD implementation and some of the infrastructure we had already built, it wasn&rsquo;t really very challenging to plug these new puzzle pieces into the application. ‑Right, we introduced a couple of new concepts. We talked about message queues, and those fit really nicely into our existing architecture because we were already using events to correspond to interesting things happening within our application. ‑And the message queue allowed us to stick a message in an external place by one application, and another application can come along and retrieve that message. So the message queue allows our applications to communicate with each other, but they can do it in a disconnected way. ‑And then we mentioned, but we didn&rsquo;t show, this concept of a service bus, often called an enterprise service bus, which you may want to introduce if you start having more than just a couple applications needing to talk to one another. ‑At the risk of being redundant, let&rsquo;s just pay homage one more time to how the decisions we made earlier on, when implementing the vet clinic solution, allowed us to add in a potentially complicated new feature, email notifications and responses into the application. ‑While we had used mediator to transfer domain events within the FrontDesk application, this time we took advantage of message queues to help us move events back and forth between applications. ‑Using RabbitMQ&rsquo;s API, we created three different queues that were specific to the cross‑application communications we needed. For example, a queue that the vet clinic public app could publish messages into for the FrontDesk application to retrieve so it could update the UI. ‑It&rsquo;s also important to note that we leveraged existing tools like RabbitMQ and Papercut to perform certain tasks. In DDD, we would refer to these as generic domains. You&rsquo;ve got to look under the covers to see how the code was making all the communication between the apps and the message keys possible, but without our domain model having to know about any of the details. ‑And then we shared some additional knowledge as we wrapped up the course. We talked about modeling practices like event storming and tools like MURAL. We talked about all of the new ideas that have evolved since we first published this course in 2014 and how they impacted this new version of the course and the sample application. ‑And we ended with some more wisdom from Eric Evans, to whom we are eternally grateful not only for bringing DDD to the software community, but also for spending time with us when we created the original course so that we could share his perspective and insights with you. ‑Like the end of a fireworks display when they shoot up many, many fireworks at once, we&rsquo;re sharing here a lot of resources and links because of the great many topics we brought into this last module. There are two pages of links here to articles and videos and other Pluralsight courses, so you might want to pause the video to be sure that you see them all. ‑So, from me, Steve Smith, ‑and from me, Julie Lerman, thanks so much for taking this journey with us through Domain‑Driven Design Fundamentals.Course Overview
Welcome to Pluralsight. My name is Julie Lerman, and this is Steve Smith. Together, we&rsquo;d like to welcome you to our course, Domain‑Driven Design Fundamentals. Steve is a trainer and architect with NimblePros and spends a lot of time helping teams write better code, faster. And Julie is well known in the DDD community for helping reluctant teams embrace domain‑driven design. In this course, we give you a strong foundation for learning how to build applications and microservices using domain‑driven design. DDD has proven to be a very effective approach for managing complex requirements. The original version of this course has helped many thousands of learners leverage domain‑driven design, and they have shared amazing feedback. Now, we&rsquo;ve updated the course and its sample application to reflect ideas and tools that have emerged since that first version. Some of the major topics that we&rsquo;ll cover include what are the essential ideas of domain‑driven design? What are the main patterns used in domain models? We&rsquo;ll also talk about how to break up concepts into smaller parts and how these smaller aggregates and contexts communicate with one another. By the end of this course, you&rsquo;ll know how to break down customer requirements into a maintainable domain model and structure a solution using domain‑driven design. Before beginning the course, you should at least be familiar with software development, ideally using C#. From here, you should feel comfortable diving into DDD and design patterns with courses on the DDD learning path and the design patterns learning path. We hope you&rsquo;ll join us on this journey to learn domain‑driven design with the Domain‑Driven Design Fundamentals course, at Pluralsight.</p>
<p>Introducing Domain-Driven Design
Introduction and Overview
Hi, this is Steve Smith ‑and this is Julie Lerman. Welcome to our course, Domain‑Driven Design Fundamentals. ‑We&rsquo;re looking forward to sharing our experience with DDD and how it&rsquo;s helped us and our clients. You&rsquo;re welcome to reach out to us online. ‑You can find me online at thedatafarm.com or on Twitter @julielerman. ‑And I&rsquo;m online at ardalis.com or on Twitter as @ardalis. ‑Eric Evans coined the term Domain‑Driven Design in his groundbreaking book with the same title published in 2004. Since then, other titles have followed, including great books expanding on the subject by Jimmy Nilsson and Vaughn Vernon and so many who are now also great experts at DDD. And there are also now a number of fantastic DDD conferences and even a well‑established virtual meetup. ‑There&rsquo;s definitely continued and renewed interest in Domain‑Driven Design as both the demand for and complexity of software continues to grow. Domain‑Driven Design is commonly referred to as DDD and even has its own Twitter hashtag, dddesign. Although DDD has been around for so long, it continues to be a great approach to building software that we both enjoy employing and sharing with others. And as more minds have gotten involved in DDD, it continues to evolve.</p>
<p>What to Expect from This Course and This Module
Domain‑Driven Design is a huge topic. Our focus will be on the developer perspective and the technical and coding aspects of DDD more so than architectural concerns. We&rsquo;ll start by talking about why we think you should even be watching this course. Next, we&rsquo;ll jump right into an existing solution so you can get a concept of what the code and the architecture of an application written using DDD practices looks like. Then we&rsquo;ll start digging into the big DDD concepts like modeling problems of the domain, what the various technical components of DDD are, and how you can use DDD to manage complex projects. Throughout the course, we&rsquo;ll use the existing solution so you can see how some of this process works. ‑With this in hand, we&rsquo;ll walk through extending the sample based on a new request from the client. Since this is a fundamentals course, we certainly don&rsquo;t expect to turn you into an expert by the end of it; however, you should be well on your way to understanding the value behind Domain‑Driven Design and how some of the practices can be employed to improve your success with complex software projects. Right now, if you&rsquo;re new to DDD, you don&rsquo;t even know what you don&rsquo;t know yet. However, once you&rsquo;re done with this course, you&rsquo;ll know more about DDD, but of course, you&rsquo;ll also realize how much more there is to learn. That&rsquo;s one of the great things about our industry. The more you know, the more you realize how much more there is you don&rsquo;t know. ‑In this module, we&rsquo;ll focus on the value of Domain‑Driven Design. You&rsquo;ll learn what the term represents and what problems DDD can help you with in your software building process. ‑Not only will we share the benefits of DDD, but we will be sure to highlight some of the potential drawbacks. Finally, you&rsquo;ll get a look at a small application that we&rsquo;ll be using throughout the course as you learn DDD.</p>
<p>Understanding the Value of Domain-Driven Design
Domain‑Driven Design focuses on the problems of the business domain that you&rsquo;re attempting to solve. Its a critical shift from decades of focusing on how to store your data and then letting that drive how the software is designed. But that workflow added a lot of unnecessary complexity to the task of building software. So why should you watch this course? Why should you care about learning Domain‑Driven Design. Steve and I have both been designing and developing software for a very long time. Without giving away our ages, we&rsquo;ve got over 40 years of experience between the two of us, and we&rsquo;ve both been very inspired by Domain‑Driven Design. In many ways, it aligns very naturally with ideas that we&rsquo;ve each come to from our own experience. It also takes these ideas and lays them out in a way that&rsquo;s not only illuminating, but it&rsquo;s repeatable. When Eric Evans wrote his book, his goal was to understand what was behind the successes he had achieved with large‑scale, complex software projects and what were the patterns. That&rsquo;s what he laid out in the book. ‑This is why we care about DDD, and we hope that you can gain from our experience, which is why we put together this course. DDD provides principles and patterns to help us tackle difficult software problems and even business problems. These are patterns that are being used successfully to solve very complex problems. The more we&rsquo;ve learned about DDD, the more we found these ideas aligned with the approaches we&rsquo;ve learned from our many combined years of experience. DDD provides us with a clean representation of the problem in code that we can readily understand and verify through tests. We developers live to code. When starting on a new project, we&rsquo;re eager to jump in and start coding so that we can build some software. But you can&rsquo;t build software unless you truly understand the client&rsquo;s needs. DDD places as much emphasis on not only comprehending what your client wants, but working with them as full partners through a project. The ultimate goal isn&rsquo;t to write code, not even to build software, but to solve problems. ‑You need to realize that nobody really wants your program. They want what it can give them. There&rsquo;s a famous saying in sales. Buy a quarter‑inch drill, they want to buy quarter‑inch holes. Your client&rsquo;s not interested in building software, but in being successful at their mission. Software provides a more efficient means to this end.</p>
<p>Gaining a High-Level Understanding of DDD
Domain‑driven design is for solving complex problems. Evans put a lot of thought into the subtitle of his DDD book and came up with Tackling Complexity in the Heart of Software. But DDD itself is a complex topic. To start with, we think it&rsquo;s helpful to look at it from a very high level. We call it the 10,000 foot view here in the US, but that&rsquo;s probably 3,048 meters to the rest of you. ‑One of the critical pieces of DDD is to encourage better interaction with domain experts. These are the people who live and breed the business or process or whatever you are targeting with the software you&rsquo;re planning to write. You may be thinking, but we already talked to them. Perhaps, but probably you&rsquo;re using your terms, not theirs, and maybe talking in the language of tables in a database rather than domain concepts. Or you may presume that after some standard requirements gathering, you can infer enough about the problem at hand to design the solution on your own. After our own history in the business of developing software, we know that that rarely ends well. DDD guides us to engage with the domain experts at much greater length and through much more of the process than many software teams are used to doing. ‑When talking with Eric Evans about this, he told us that you really need to cultivate your ability to communicate with business people in order to free up their creative modeling. Another core theme in DDD is to focus on a single subdomain at a time. Say you&rsquo;re asked to build software for a spaceship manufacturer. They describe their business tasks such as purchasing materials, engineering, managing employees, advertising their spaceships and share with you their dreams about mass producing spaceships when the market&rsquo;s ready. Each one of these tasks are in themselves a complex subdomain filled with their own specific tasks, terminology, and challenges, and those subdomains may have only minimal interaction between them. Many applications just try to do too many things at once, then adding additional behavior gets more and more difficult and expensive. With DDD, you&rsquo;ll divide and conquer. By separating the problem into separate subdomains, each problem can be tackled independently, making the problem much easier to solve. This lets us focus on the problem of employee management separately from the problem of sourcing materials for producing the spaceships. The term modeling is important in DDD and refers to how you decipher and design each subdomain. You&rsquo;ll learn much more about this as you progress through the course. ‑The final theme in our high‑level perspective of DDD is writing the code to implement each subdomain. The principle of separation of concerns not only plays a critical role in identifying the subdomains, but within each subdomain, we use it as well. Many applications spread the domain logic between the persistence layer and the user interface, making it much more difficult to test and to keep all of the business logic consistent. DDD applies separation of concerns to help steer you clear of this problem by focusing on the domain and not on details like how to persist data into a database or how to connect to a service in the cloud. Those become implementation details that you can worry about separately. While implementing these subdomains, the focus is on the subdomain, the problems of the subdomain you are trying to solve with your software. You don&rsquo;t get bogged down worrying about infrastructure concerns.</p>
<p>Exploring the Benefits and Potential Drawbacks of DDD
Domain‑Driven Design is a big commitment. While Steve and I have both chosen to leverage pieces of DDD as we learn more about the wider scope, one thing we&rsquo;re both confident about is that it&rsquo;s providing a lot of benefits to our work. Because DDD guides us to focus on small, individual, nearly autonomous pieces of our domain, our process and the resulting software is more flexible. We can easily move or modify the small parts with little or no side effects. It even lets us be more flexible with our project resources as we&rsquo;re building the software. ‑The resulting software also tends to be more closely mapped to the customer&rsquo;s understanding of the problem. DDD gives you a clear and manageable path through a very complex problem. When you look at the code, you can see that it&rsquo;s generally well organized and easily tested, and the business logic all lives in one place. Even if you don&rsquo;t use full DDD for a project, there are many patterns and practices that you can use by themselves to benefit your application. So keep watching, even if you don&rsquo;t think you&rsquo;ll need all of it. ‑We often describe DDD as a way to take big, messy problems and transform them into small, contained, solvable problems. But DDD is not a path for every project. It&rsquo;s real benefit is for complex domains. Even Eric Evans explicitly states that DDD isn&rsquo;t suitable for problems when there&rsquo;s substantial technical complexity, but little business domain complexity. Using DDD is most beneficial when the complexity of the domain makes it challenging for the domain experts to communicate their needs to the software developers. By investing your time and effort into modeling the domain and coming up with a set of terminology that&rsquo;s understood for each subdomain, the process of understanding and solving the problem becomes much simpler and smoother. ‑But all this comes at a cost. You&rsquo;ll spend a lot of time talking about the domain and the problems that need to be solved, and you&rsquo;ll spend plenty of time sorting out what is truly domain logic and what is just infrastructure. The easy example there is data persistence, or for the sake of our spaceship manufacturer, maybe it&rsquo;s how to communicate with an external service that helps to verify that potential buyers are properly vetted for space travel. ‑You&rsquo;ll have a big learning curve as you learn new principles, patterns, and processes. There&rsquo;s no question about that. DDD is a big topic and gaining expertise from end to end is a big commitment. This course doesn&rsquo;t aim to make you an end‑to‑end expert in DDD, but to give you a big step forward that will allow you to not only comprehend the concepts, but you&rsquo;ll gain a lot of new tools that you can use right away, whether or not you choose to dig further. And it&rsquo;s worth restating that DDD is not always the correct path for your applications. And it&rsquo;s helpful to keep in mind some of the scenarios where DDD is just going to be overkill. For example, if you have an application or a subdomain that&rsquo;s just a data‑driven app and doesn&rsquo;t need much more than a lot of CRUD logic, there&rsquo;s really no need to use DDD. It would be a waste of time and effort. ‑And be clear about the difference between complexity in your business domain and technical complexity. DDD is designed to help with complex domains. If your domain is simple, even if you have a lot of technical challenges to overcome, DDD still may not be the right path. For example, if you are writing a tic‑tac‑toe game for a touch screen with a new complex API, the complexity lies in the touch interactions of the two players on the screen. The domain itself is well known and just comes down to Xs and Os. Getting others to follow the DDD approach can also be a drawback. There may be some politics involved in this decision. It really depends on your team and your organization. We hope that another takeaway from this course will be to help you understand the concrete benefits of DDD, which you can show to your coworkers to help convince them.</p>
<p>Inspecting a Mind Map of Domain-Driven Design
In his DDD book, Evans included a really useful diagram of how many of the concepts and patterns of DDD are interrelated. Let&rsquo;s take a look at that mind map. ‑Evans refers to this as a navigation map, and it lays out all of the pieces of Domain‑Driven Design and how they relate to one another. We want you to see it so that you have a concept of the big picture, even though in this course we&rsquo;ll spend most of our time on a subset. We will be defining many of these terms later on in the course, so don&rsquo;t panic. We&rsquo;ve mentioned modeling the domain and subdomains a few times. Modeling is an intense examination of the problem space. Key to this is working together with the subject matter experts to identify the core domain and other subdomains that you&rsquo;ll be tackling. Another important aspect of modeling is identifying what&rsquo;s called bounded contexts. And within each of these bounded contexts, you focus on modeling a particular subdomain. As a result of modeling a bounded context, you&rsquo;ll identify entities, value objects, aggregates, domain events, repositories, and more and how they interact with each other. ‑In the image, there&rsquo;s more than just these subdomains, however. For example, there is a concept of an anti‑corruption layer, which allows subdomains to communicate with one another from behind their boundaries. The model also has notes for each element, such as free teams to go separate ways. This is something that can be accomplished once you&rsquo;ve identified the boundaries of each subdomain. Or avoid overinvesting in generic subdomains. That could be something like a credit card verification service that you could choose to use rather than building yourself. As you begin focusing on specific subdomains, another very important DDD concept surfaces, driven by the need for clear, concise communication. It&rsquo;s called the ubiquitous language. A simple definition of a ubiquitous language is to come up with terms that&rsquo;ll be commonly used when discussing a particular subdomain. And they will most likely be terms that come from the problem space, not the software world, but they have to be agreed upon so that as discussions move forward, there is no confusion or misunderstanding created by the terminology used by various members of the team. ‑We invite you to pause this video to look over this map and read the notes associated with the various elements and contemplate what they might mean. We&rsquo;ll revisit this throughout the course, and we hope that the map will make more and more sense as you work through the course.</p>
<p>Introducing Our Sample Application
Now we want to switch over and show you a relatively small DDD‑based solution that we&rsquo;ll be working on for the rest of the course. This app represents an appointment scheduling system for a veterinary clinic. It&rsquo;s &ldquo;small&rdquo;, but since DDD requires a certain amount of complexity to warrant its use, it&rsquo;s bigger than most demos you&rsquo;ll see in other courses or presentations. For this course, we decided that we would use a veterinary clinic management system because it has a decent amount of complexity, and that means that we can apply some of the DDD principles, but it also gives us an excuse to show off pictures of our pets. ‑And our friends pets too. We&rsquo;ve got a whole bunch of pet pictures from other Pluralsight authors in here, and they&rsquo;re all so cute. ‑We&rsquo;ve got Ben Franklin here from Michael Jenkins. We&rsquo;ve got Patrick Neborg&rsquo;s dog here, Sugar. Aren&rsquo;t these guys cute? And, of course, Julie&rsquo;s got Sampson. ‑Oh, my handsome boy. ‑And I&rsquo;ve got Darwin, the silly poodle. He was just a puppy when we recorded the first version of this course, and he&rsquo;s got a new friend, Rosie. Rosie is just a puppy. I guess every time I get a puppy we have to update this course. ‑So the idea behind this application is that if you&rsquo;re working at the front desk of a vet clinic and someone walks in, maybe they want to schedule an appointment, or the phone rings with someone who wants to schedule an appointment for their pet, the first thing you&rsquo;re going to do is look that client up, the person, in the system. ‑So the user starts by looking up the client, and from there, they can choose which of the clients, animals or patients, they&rsquo;re going to schedule. So here&rsquo;s Julie with Sampson. Here&rsquo;s Kim with Roxy. Next, the user is just going to click on an open slot in the schedule, which opens up the create appointment window. ‑Oh, Roxy, you&rsquo;re such a cutie. We can set up Roxy for a wellness exam with Dr. Smith. ‑Now notice before we save this appointment, it isn&rsquo;t yet confirmed. We&rsquo;ll get to that in a minute. So we save, and the appointment shows up. Now the complexity in this system comes into play when we have to do some checks for certain things. We want to make sure, for instance, that Roxy isn&rsquo;t already scheduled in one of the other rooms at this exact time. We also want to send an email notification to Kim to let her know that Roxy has this appointment scheduled. We&rsquo;ll add a link in the email the client can click to confirm. And in a real system, perhaps it would add it to their calendar of choice. The idea is to cut down on no‑show appointments for the clinic. ‑Of course, there are other features of this application. We&rsquo;re focused on the schedule right now, but we do need to be able to manage client data and manage their pet data, the clinic&rsquo;s patients, and things like that. Admins need to be able to manage doctors and rooms and appointment type since these all might change over time or from one clinic to another that uses the same software. But those are mostly CRUD tasks, which means we&rsquo;re just talking about adding and removing records and maybe making some edits without a whole lot of complexity. We&rsquo;ll talk about those tasks in a different compartment of the application than the schedule, which, of course, has a lot more complexity.</p>
<p>Exploring the Sample App&rsquo;s High-level Structure
So why don&rsquo;t we take a look at the structure of our app? This is a distributed application built with ASP.NET Core on .NET 5. It&rsquo;s running Blazor WebAssembly in the front end, which is talking to APIs running on ASP.NET Core. There are three different web apps that the system uses. Two are used internally by client staff, and then there&rsquo;s the public‑facing website for the clinic, which is needed for the confirmation links that users will click. The two clinic apps, Front Desk and Clinic Management, each have their own database, and all three apps communicate with one another using messages transported by RabbitMQ. Like I said, it&rsquo;s maybe a little more complicated than most demos. We want the sample app to be something you spend some time with and extend as part of your experience with this course, so please be sure to check it out and run it locally. It should just work if you have Docker installed. ‑Now let&rsquo;s take a quick look at how the code is organized. The full solution is hosted on Steve&rsquo;s GitHub account. Here&rsquo;s the URL, but we&rsquo;ll definitely also have that URL in the resources slides at the end of this module. PLURALSIGHT DDD FUNDAMENTALS is the name of the root of our GitHub repository. In here, you can see the three web apps, ClinicManagement, FrontDesk, and the public‑facing website, VetClinicPublic. ‑There&rsquo;s also a folder for SharedKernel, which we&rsquo;ll talk about a little bit later. The first app we&rsquo;re going to focus on though is the FrontDesk app. ‑Our main focus for this course is going to be the front desk application and its scheduling functionality. Looking at the solution, you can see it&rsquo;s broken up into seven projects, which seems like a lot, but three of them are just there to support Blazor The server‑side code, where our domain model resides, is just three projects. ‑The most important project is FrontDesk.Core. That&rsquo;s where the domain model is defined. All of the app&rsquo;s infrastructure needs, like how it talks to its database or RabbitMQ, are kept in the FrontDesk.Infrastructure project. In the front end, in this case, ASP.NET Core and its API endpoints, is in the FrontDesk.Api project. This is the front end from the server&rsquo;s perspective. The system is using a clean architecture design which you may also hear referred to as onion architecture or ports and adapters. I cover this in my N‑Tier Applications in C# course, and I have a popular GitHub solution template you can use to set up a new project using this approach. ‑With clean architecture, the project dependencies all point towards the domain model in the core project, so both the API and infrastructure projects have a dependency on Core. Core should never depend on infrastructure concerns, but it can leverage NuGet packages that don&rsquo;t couple it to infrastructure concerns. ‑In this case, it&rsquo;s using a couple of utility packages, as well as the SharedKernel package that&rsquo;s shared by other apps. We&rsquo;ll talk more about SharedKernel later. The ClinicManagement app uses the same kind of structure and also has a Blazor front end because why not? It&rsquo;s pretty much just CRUD, so we don&rsquo;t focus too much on its domain model, but it is a distinct app with its own database, and we do need to build into our design a way to propagate changes from it to the FrontDesk app. ‑Finally, there&rsquo;s the public web app. It&rsquo;s just one project, and it&rsquo;s pretty simple. This is responsible for sending emails, which this demonstration fakes using a tool called PaperCut, and it hosts the link that clients click to confirm appointments. The public web app also needs to communicate with the front desk, but it doesn&rsquo;t have a database of its own, nor does it access any of the other app&rsquo;s databases. ‑That&rsquo;s it in a nutshell. We&rsquo;ll demonstrate the confirmation emails and more complex use cases later in the course. But for now, that should give you an idea of how the ideas we&rsquo;re sharing are put into practice.</p>
<p>Review and Resources
So, as we&rsquo;ve talked about, creating applications is not about writing code, even though often that&rsquo;s a really, really fun part for us developers, but it&rsquo;s about solving problems. And the more complex the problems are, the more difficult the whole project becomes. So Domain‑Driven Design gives us some great patterns and practices for attacking these more complex problems, and they get us to really focus on interacting with the domain experts, breaking apart our domain, and working on things in smaller units and in a very organized fashion. And in the end, it gives us a much more efficient and effective path to success in creating our solutions. ‑Yeah, we talked about some of the benefits that Domain‑Driven Design provides, as well as some of the drawbacks. Specifically, your team just needs to know Domain‑Driven Design, and your domain experts need to be available to work with you on these systems. Domain‑Driven Design is a big topic. We looked at some of the different concepts that are involved in DDD, and we&rsquo;re going to look at a lot more of them in depth through this course. But remember that this is just an introduction to Domain‑Driven Design, so some of these aspects that are a little more advanced, we&rsquo;re not going to be able to cover with a great deal of depth. ‑In the next module, we&rsquo;ll start exploring the process of discovering and modeling domains. Here are some links to resources that we mentioned this module and others that we find relevant. ‑This is Steve Smith ‑and this is Julie Lerman, and thanks for watching Domain‑Driven Design Fundamentals.</p>
<p>Modeling Problems in Software
Introduction and Overview
Hi. This is Steve Smith. ‑And this is Julie Lerman. Welcome back to our Domain‑Driven Design Fundamentals course. This module will focus on modeling problems in software, and you&rsquo;re welcome to reach out to us online. You can find me online at thedatafarm.com or on Twitter @julielerman. ‑And I&rsquo;m at ardalis.dot com or on Twitter as @ardalis. In this module, we&rsquo;re going to take a look at how we decompose the model for the veterinary office domain. We&rsquo;ll talk about the importance of domain experts in DDD. ‑We&rsquo;ll drive this point home with a play in which we&rsquo;ll consider a few different scenarios for how the project might have gone, which should provide you with examples of ways to involve the domain expert in the design of the system. ‑Next, we&rsquo;ll talk about the domain model and some of the elements that typically are found in this part of the application. It&rsquo;s important to separate the core domain model from related subdomains, and we&rsquo;ll talk about how bounded contexts can help us accomplish this separation. ‑And then we&rsquo;ll wrap things up by talking about ubiquitous language and how this seemingly small thing with a big name can have a large impact on your model, your design, and, of course, your application. So let&rsquo;s get started.</p>
<p>Introducing Our Domain
Steve and I both have a love for animals. In fact, Steve&rsquo;s wife, Michelle, is a veterinarian. In thinking about a sample application we could use for this course, we wanted to use something complex enough to justify the use of DDD. The veterinary clinic management domain made a lot of sense, allowing us to leverage our own experience as pet owners, as well as having a domain expert available in the form of Michelle, or Dr. Smith as we&rsquo;ll be referring to her in the course. ‑There are many different pieces involved in managing a typical veterinary clinic. The staff needs to be able to schedule appointments. They likely need to schedule their own working shifts as well. They need to be able to invoice for their services and collect payments and, in many cases, send out bills. They&rsquo;ll also need to be able to store and retrieve medical records, as well as work with external labs and specialty clinics. Most veterinary practices also have products for sale and may need to track inventory, as well as sales. And there are often follow‑ups and reminders that may need to be sent by mail, phone, or perhaps email. There is certainly sufficient complexity in this domain to merit the use of domain‑driven design.</p>
<p>Planning Ahead to Learn About the Domain
Of course, it&rsquo;s a good idea to speak with a domain expert about the systems requirements before diving in and beginning to code a solution. Whether you&rsquo;re tasked with building a full system or just adding a new feature, an overall understanding of the client&rsquo;s business is a critical start. Of course, it&rsquo;s just the beginning. It&rsquo;s also important that you have a continuous conversation with the domain expert throughout the development of the system. The simple system we showed in the last module needs some updates. So we&rsquo;re going to share some conversations we had with the domain expert to help validate our initial assumptions. ‑An important part of this conversation is going to be identifying the things that aren&rsquo;t included in the scope of the project or feature. To that end, we&rsquo;ll try to identify subdomains within the overall problem domain and then determine whether or not we need to concern ourselves with these subdomains at the moment. If not, we can consciously remove them from the scope with the customer&rsquo;s approval and avoid confusion and possible missed expectations later. To get started though, we do want to know a little bit about the big picture.</p>
<p>Conversation with a Domain Expert: Exploring the Domain and Its Subdomains
As Julie already mentioned, my wife, Michelle, is a veterinarian. In addition, she has a deep understanding of software development processes, having successfully managed software teams at NimblePros and Teller. She has graciously agreed to play the role of domain expert for our course. In real life, she knows quite a bit about software and technology, but for the purposes of this course, she&rsquo;s playing the more traditional role of a veterinarian with little background in software development. Hi Dr. Smith. Thanks for your time today. Julie and I would like to learn more about what goes on in your veterinary clinic. Can you share some of the big picture processes involved in the day‑to‑day operation of a clinic? ‑So the biggest thing is probably scheduling patients and keeping track of them once they arrive. Clients will usually call ahead unless it&rsquo;s an emergency, and then we need to get them entered into our system. Of course, surgical procedures need to be scheduled in advance. And when they&rsquo;re here, we need to record information about the patient, our observations, notes, and diagnoses. ‑Wow, that&rsquo;s quite a list. Probably not what you were dreaming about when you started vet school. So many of these are all secondary to the core reason for being a vet, keeping pets healthy. And, I think it sets you apart from other businesses that have to manage clients and schedule appointments. But, you can&rsquo;t run a business without it. Is that all? ‑So when the appointment is over, they also have to pay. So most of the time that&rsquo;s done immediately, but we do have some billing that&rsquo;s done after the fact, and when they&rsquo;re checking out, they may need to buy some things for their pets, toys or prescriptions, or maybe some prescription food as well, and we need to track all of that as well. For some of the lab work, we need to send that out and get the results back, and some prescriptions go out to outside pharmacies as well. So we need to manage all of those through the system. ‑Okay, so payments, billing, point of sale, labs, prescriptions, anything else? ‑I think that&rsquo;s about it. Oh, we also use the system to note which staff members are working when, and right now our website isn&rsquo;t integrated into the system at all, but we were thinking it would be great if clients could view information about their pets, maybe schedule appointments, look up prescriptions, and we can make updates to the site without having to go through our computer contractor. ‑Okay, great. So, we&rsquo;ll add staff scheduling and content management to the list. I don&rsquo;t want to assume you know what a content management system is. We also call it a CMS, you might have heard of that. It&rsquo;s a type of software system that lets the owner, that&rsquo;s you, be in charge of the information that&rsquo;s displayed. A blog is a really good example of a CMS that can be managed by its owner. ‑I have a blog, so I understand exactly what you mean. Something like that would be really great for us to have so we can make updates right in‑house. But it&rsquo;s kind of like a blog, especially something that&rsquo;s more professional than my personal blog. ‑Cool. So I think that&rsquo;s probably enough of a big picture view for us to consider at the moment. Now let&rsquo;s try and think about which of these are connected to the others so we can determine which ones we need to worry about for our application&rsquo;s needs. ‑We started with this fairly complicated view of the overall problem domain, but now we&rsquo;ve segregated these into different areas and we know which ones we need to focus on right now and which ones we can treat as external collaborators. ‑Determining where we can safely draw the line between what problem our immediate application needs to solve and what is outside of its area is certainly helpful. It&rsquo;s also important that this be well understood and communicated among everyone involved in the project.</p>
<p>Conversation with a Domain Expert: Exploring the Scheduling Subdomain
Now that we have a better understanding of the domain and the other subdomains around the scheduling system, it&rsquo;s time to focus more on understanding the scheduling subdomain. We had another meeting with Dr. Smith, and you can listen in. ‑Hi guys, welcome back to the clinic. How are things going with the computer system? ‑We&rsquo;re making good progress, and now we&rsquo;re ready to look at another more complex feature. ‑We know there&rsquo;s a lot that goes on here, but today we want to focus on appointment scheduling because we realize we&rsquo;re still a little confused about it. ‑Since we&rsquo;ve both owned pets for a long time, we figure we probably have a rough idea of what&rsquo;s needed, but it&rsquo;ll be good to talk through it with you. Do your patients usually schedule their appointments over the phone? ‑Okay, so yeah our patients aren&rsquo;t usually involved in the scheduling. Usually, it&rsquo;s the clients that call in for appointments for their pets. And yeah, usually it&rsquo;s on the phone or in person when they&rsquo;re checking out after an office visit. Julie and I talked about that earlier. ‑Yeah, so Steve, the patients are the animals, and the clients are the people or the pet owners. ‑Right, right, of course, that&rsquo;ll be important to get right. ‑Remember, we talked about that. So the client needs to make an appointment for their pet. They&rsquo;ll talk to a staff member who will schedule the appointment. What kind of information do they need in order to do that? ‑So that really depends on the type of appointment. It could be an office visit, or it could be a surgery. Why don&rsquo;t we talk about the office visits first. If it&rsquo;s just for a wellness exam, that&rsquo;s pretty standard. They just need to choose an available time slot with one of the doctors. Some of the visits can be scheduled with just a technician though, so if they need just their toenails trimmed, for example. ‑Or painted, like Samson. He gets his toenails painted. ‑Does he really? ‑No, I&rsquo;m joking. I just want to, pink. ‑I&rsquo;m sure he&rsquo;d love that. Okay, so office visits might be an exam requiring the doctor or another kind of appointment that only requires a technician. ‑Right. We also have to worry about our rooms too. We only have five exam rooms available, and we try not to overbook. We don&rsquo;t like for our clients to have to wait too long in the reception area, especially if we have a lot of cats and big dogs out there at the same time. It makes them all really nervous. ‑What about other staff? ‑So our technicians will float between the exam rooms and other areas of the clinic as needed, except, of course, for those scheduled technician visits. We do have a schedule for the staff, but it&rsquo;s separate from how we schedule our appointments. ‑Okay, so what about the surgeries? ‑Well, if it&rsquo;s a surgery, those are only scheduled on certain days, and they require that the operating room be available, as well as some recovery space in the kennel area. It also depends on what kind of surgery or procedure we&rsquo;re going to be doing. Something simple like a dental cleaning takes less time and fewer people than a caesarean section for a bulldog. ‑Okay, so an appointment is either an office visit or a surgery. Office visits happen in the exam room; surgeries require the operating room and recovery space. Is that right? ‑Right. And depending on the reason for the visit or the surgery, different staff might need to be involved. ‑So we&rsquo;ll probably want to have separate classes for appointments and surgeries. ‑Classes? No, we refer our clients to obedience and puppy preschool classes at other facilities. We don&rsquo;t actually schedule any of those in the clinic themselves. ‑I&rsquo;m sorry. That&rsquo;s a software term. In software, we have different classifications of concepts in the program, which are called classes. I&rsquo;m just getting ahead of myself here. Sorry. ‑Don&rsquo;t worry. We&rsquo;re not going to make you learn our software terms. Steve and I will try to have a little bit more self control with that. We do want to make sure we&rsquo;re all speaking the same language when it comes to concepts in the application though. ‑Okay, so I have another quick question. Do we have to worry about multiple staff members scheduling appointments at the same time? ‑No, there should only ever be one person doing the scheduling at a time, although I could see if we grew in the future that could change. But I don&rsquo;t think that&rsquo;ll happen in the next couple of years. Okay, then we don&rsquo;t have to worry about the rare occurrence of two people creating a conflict if they&rsquo;re trying to schedule an appointment for different patients in the same room or with the same doctor. That&rsquo;ll keep things a lot simpler. And we need to know before an appointment if certain resources are available, like rooms and doctors. And then if they are and we want to schedule the appointment, then we need to be able to book the doctor, the room, and any other resources. Hey, is it okay if we refer to doctors as resources? ‑Sure, that makes sense. You know, I think it makes sense to use the term resources to refer to the doctors, the rooms, and the technicians since those are all things that can affect whether or not an appointment can be scheduled. But remember, sometimes it&rsquo;ll be just a vet tech in a room, and other times it might be the doctor in the room, but sometimes you might need the doctor, the technician, and a room. ‑Wow, this is a lot more complicated than we&rsquo;d realized, but it&rsquo;s interesting. This is going to be cool to model in the application.</p>
<p>Reviewing Key Takeaways from Meeting with Domain Expert(s)
Some of the things we learned in that initial high‑level discussion with the domain expert included the fact that patients and clients are not the same thing to a veterinarian. ‑Yeah, that&rsquo;s pretty obvious in hindsight. But in most other medical professions, it is the patients who make appointments and pay the bills. It&rsquo;s good we were able to get on the same page with the customer on that early on in the process. ‑I think it helped Dr. Smith put some of the processes she uses into explicit terms that we could program against also. A lot of times just describing the process to someone who is unfamiliar with it can really help improve the understanding of it. It&rsquo;s like that idea that when you have to teach something to someone else, it makes you learn it a lot better. Listen to what Dr. Smith had to say at the end of our conversation about this. ‑Yeah, I never really thought about the details of how we do some of these things since it&rsquo;s just something we do, and we don&rsquo;t really think about it. Being more explicit about what the rules are that determine how we do are scheduling could help us avoid some of the occasional scheduling problems we&rsquo;ve had. This is going to be great. ‑We also need to remember not to use too much programmer jargon, especially when there are programming terms that might have a different meaning in the customer&rsquo;s domain. ‑I agree. It&rsquo;s a little early for us to be worrying about how things might end up looking in the code anyway. At this stage, the main focus is on understanding the domain. We&rsquo;ll get to building the software soon enough. But first, we want to make sure we know what problem it&rsquo;s going to be solving. One of the most important things we can do as we explore the problem with the domain expert is to try and make their implicit knowledge about the process they use now explicit. Once we&rsquo;re able to capture the process and its rules and exceptions with some detail, we can start to work on modeling a solution using this information. Building software is hard. One of my favorite sayings is as software developers, we fail in two ways. We build the thing wrong, or we build the wrong thing. By making sure we understand what the customer needs and, of course, working closely with the customer throughout the development process, we can dramatically reduce the likelihood of the second kind of failure, which is much harder to fix typically. ‑Hey, Steve. I like the way you quote yourself here, but it really is a great quote.</p>
<p>Taking a First Pass at Modeling our Subdomain
After talking to Dr. Smith about how appointments work, we&rsquo;ve identified a few high‑level elements of our model. The central concept in this application seems to be the appointment itself. Typically, an appointment is scheduled by a client for a patient. Booking an appointment often requires an exam room and a doctor, but may involve other resources. Appointments might be for office visits or vaccinations, or they might be surgeries, which are a separate kind of thing entirely with their own rules which involved different kinds of procedures. Surgeries require different resources too, like operating rooms and recovery rooms. ‑That&rsquo;s a pretty good high‑level view of the model we have so far for the appointment management part of our application. I think it&rsquo;s worth noting that some of the concerns of this application are going to also play a part in other subdomains. For instance, I&rsquo;m pretty sure we&rsquo;re also going to be working with clients and patients in a lot of the different parts of this application. ‑Yeah, I think it&rsquo;s time we introduce the idea of bounded contexts.</p>
<p>Using Bounded Contexts to Untangle Concepts that Appear to Be Shared
As you develop your model, remember to identify its bounded context. That is, where is this model valid? If you don&rsquo;t put boundaries around your model, eventually, pieces of it will be used where they don&rsquo;t fit. Concepts that make sense in one part of the application may not make sense in another, even if they have the same name and sometimes even if they literally refer to the same thing. ‑For example, as we built out the appointment scheduling portion of this system, we needed to know some very basic information about clients. But in the context of appointment scheduling, these are very simple concepts with little behavior beyond their names. However, in the billing context, we&rsquo;ll want to include contact and payment information for clients, but that&rsquo;s information we don&rsquo;t care about back in the appointment scheduling context. If we try to reuse the same exact client model in multiple places, it&rsquo;s likely to cause inconsistent behavior in our system. ‑That&rsquo;s right. For instance, we might decide to include some form of validation on clients to ensure we have enough information to bill them. If we&rsquo;re not careful, that validation might inadvertently prevent us from being able to use clients to schedule appointments, which certainly isn&rsquo;t the desired behavior. Maybe the billing system requires that clients have a valid credit card in order to save changes for them, but it wouldn&rsquo;t make sense for a lack of a credit card to prevent us from saving an appointment for a client in the appointment scheduling system. In this example, we have two contexts, but the boundaries between them are blurred and overlapping. Eric Evans notes that models are only valid within specific contexts. Therefore, it&rsquo;s best to explicitly define the context within which a model applies. We should be able to avoid compromising the model within this context, keeping it strictly consistent within these bounds and avoiding distractions or confusion from outside issues. ‑Once we explicitly define our bounded contexts, we can easily see whether or not we have elements of our model that are trying to span multiple contexts. In this example, we&rsquo;d want to keep a simple view of a client in the appointment scheduling up and a richer version of the client with contact and billing information in the billing context. We would define these two views of a client in two separate classes, and they will most likely live in separate applications. In fact, Evans recommends that bounded contexts maintain their separation by giving each context its own team, codebase, and database schema. ‑While this is ideal, in many real‑world apps, we need to work on systems where this level of separation is not present, usually due to resource constraints or for political reasons within the organization. Remember though, if you have multiple contexts, you&rsquo;ll want to keep them bounded. And one way to maintain this separation is to keep their data, code, and team members distinct from one another, although in real world, I&rsquo;ve never seen something with that level of separation. ‑Yeah, but I think even if it&rsquo;s not possible to literally do that with your company and your team, just having that concept in mind really helps in your brain have that idea of separation. ‑I agree. I know that just thinking about the fact that these things ought to be separated and trying to figure out a way to do it means that even if you can&rsquo;t get to the ultimate level where everything is is completely separate, you can still introduce separations through things like namespaces, separate folders, separate projects, anything you can do to make it clear that these are different contexts that shouldn&rsquo;t be sharing too much information. ‑You know, I think that&rsquo;s also really important point about this course in general and DDD in general. For me, it&rsquo;s really hard to think of all of these things we&rsquo;re learning as hard and fast rules, like you have to do it this way or you&rsquo;re not doing it right. I like to see all of this as really good guidance. So, you know, it helps me keep my eye on the prize, and when there&rsquo;s places where I can&rsquo;t truly achieve exactly what DDD kind of directs me to do, you know, I&rsquo;m using my own experience, my own intelligence to make decisions about how to do things, and I&rsquo;m letting DDD guide me in a lot of scenarios. ‑Sure. And some of these ideals, I think of like 100% test coverage. It&rsquo;s almost impossible in most real‑world applications to achieve 100% test coverage. But just because that ideal is not something you can ever achieve doesn&rsquo;t mean that you shouldn&rsquo;t strive for more test coverage. ‑Yeah, yeah, totally, totally agree with that.</p>
<p>Conversation with Eric Evans on Subdomains and Bounded Contexts
When learning about DDD, most of us have a hard time understanding how subdomains and bounded contexts are different. We asked Eric Evans about this and got some great insight. He explained that a subdomain is a view on the problem space, how you&rsquo;ve chosen to break down the business or domain activity, whereas a bounded context represents the solution space, how the software and the development of that software has been organized. Quite often, these will match up perfectly, but not always. ‑Eric helped us understand this further with the example of a room that you want to cover with carpeting. The room is the problem space, so it&rsquo;s like a subdomain. You could install a wall‑to‑wall carpet that matches the shape of the room perfectly. This would be like when the subdomain and the bounded context encompass the same thing. But other times you might just use some area rugs to cover the floor, and the area rugs solve the problem. They cover the part of the floor where you walk, and you don&rsquo;t have to worry about cold feet in the winter. And that&rsquo;s a scenario where the area rugs are like bounded contexts that don&rsquo;t match the subdomain, but they solve the problem even though they&rsquo;re not an exact match to the shape of the room.</p>
<p>Introducing Context Maps
If your organization has multiple bounded contexts, and ideally these are separated, there can be confusion when the different teams are talking to one another. Again, DDD focuses at least as much on effective communication as it does on anything specifically related to the code we produce. Evans recommends using context maps to visualize and demonstrate to all teams where the boundaries between their context lie. ‑Think about a complex topographical map. It will frequently include a legend, like the one shown here, in order to explain what each of the lines and symbols on the map mean. However, this legend is only valid within the context of the map with which it appears. Trying to use this legend on another map would be confusing at best. ‑A good first step for an existing application is to create a map that shows how things are. Remember that the names of your contexts are also important as you&rsquo;ll refer to them frequently when discussing different parts of the application. It may be that things are not as separate as they should be, and that&rsquo;s worth noting. If you have separate teams responsible for different contexts that share resources, it&rsquo;s important that each team understands which aspects of the application they can change on their own and which are shared dependencies they&rsquo;ll need to coordinate with other teams to avoid breaking things. If we look at these two sets of concepts, we can see some obvious overlap. For one thing, Client appears in both contexts, but we know that for appointment scheduling we really only care about the client&rsquo;s name, whereas in the billing system they&rsquo;ll want additional information like address and payment details. However, although the details involved vary, we know that Mr. Jones, the client on the left, is the same actual person as Mr. Jones, the client on the right. However, we also have a concept of notifications on both sides, and in this case, they&rsquo;re referring to different things. On the left, we&rsquo;re talking about sending a notification when an appointment is booked as a reminder, and on the right, we&rsquo;re talking about notifying the client that their payment was received or perhaps that it&rsquo;s past due. ‑Especially in smaller organizations, it&rsquo;s common to have one team responsible for several contexts of the same overall application. In such cases, it&rsquo;s also common for the team to use a single codebase for the bounded context that they&rsquo;re working with and store it in a single repository, such as GitHub. Usually, there will also be a shared database. As we&rsquo;ve already noted, this is not ideal since it makes it much more difficult to maintain the boundaries between the separate contexts. ‑Part of creating a context map involves explicitly identifying its boundaries. If we try to draw the boundaries around these two bounded contexts, we can see there are now several resources that belong to each bounded context. This isn&rsquo;t ideal if the two contexts really are meant to be kept separate. ‑In the ideal case for a large complex system, we would have bounded contexts like these, with their own teams, codebases, and database. For instance, on the left, we have an appointment scheduler application. It&rsquo;s being worked on by Team Awesome, and they&rsquo;re storing all of their code in their own repository called vet‑app‑sched. And, of course, this application has its own database. This team is free to change anything they want with their model or any other part of their system without worrying about breaking anything outside the boundaries for the team on the right, which is working on a billing system, and their team has decided to call themselves Team Ultimate, store their code in a repository called vet‑billing, and, of course, using their own database. By having this separation, this can greatly increase team velocity and reduce integration bugs. ‑Of course, you&rsquo;re probably wondering how the two systems will interoperate. There are a number of patterns that can be applied to enable this kind of integration. We won&rsquo;t be covering all of them in this course, but one question that frequently comes up is how to share cross‑cutting concerns like blogging and shared abstractions such as people names that are used by multiple bounded contexts. For this scenario, a common approach is to designate these shared concepts or resources as what we call a shared kernel. Team Awesome and Team Ultimate agreed to share the subset of the domain model. Since they&rsquo;re sharing it, they also agree not to change it without coordinating with the other team first. Frequently, the shared kernel will either be a part of the customer&rsquo;s core domain, or some set of generic subdomains, or even both, though it could be any part of the model that both teams require. Using a shared kernel is a tradeoff between code reuse and consistency and the overhead involved in integrating changes to the shared kernel across multiple teams and bounded contexts. It works best when the shared model is relatively stable.</p>
<p>Addressing the Question of Separate Databases per Bounded Context
The concept of having separate databases for each bounded context often throws people for a loop. But with the advent of microservices, which also, by definition, each have their own database, teams are beginning to get more accustomed to the idea. Here&rsquo;s what Eric Evans said to us when we talked with him about the problems created by trying to share a database across teams. &ldquo;If you&rsquo;re in a company where you share your database and it gets updated by hundreds of different processes, it&rsquo;s very hard to create the kind of models that we&rsquo;re talking about and then write software that does anything interesting with those models.&rdquo; Given that sharing a database across bounded contexts is really not a great idea, then we have another important question. ‑Another question that comes up often is how to sync data between the individual databases that are tied to each of the bounded contexts. Some different patterns you can use are publisher/subscriber, commonly referred to as pub/sub, and two‑way synchronization. Pub/sub is definitely simpler and preferable when you can manage it. You can use different implementations like message queues, database processes, batch jobs, or synchronous API calls. It&rsquo;s really up to you how you want to design your synchronization between bounded contexts. The point is just that you don&rsquo;t get the integration for free from using a shared database.</p>
<p>Specifying Bounded Contexts in our Application
We talked with Eric again to get his perspective on defining context boundaries. Some of the key points he shared were that first, it&rsquo;s important to understand that it&rsquo;s never a simple task whether you&rsquo;re new to it or not. And he&rsquo;s seen stumbling blocks of all sorts. The most common is not having a clear enough context boundary, so the effort of applying DDD isn&rsquo;t clearly separated from other tasks related to building software. ‑He also reminded us that the bounded context is such an essential ingredient that is probably the biggest stumbling block. And it&rsquo;s not often one that an individual on a project can usually addressed by themselves. It kind of has to be dealt with at the team level or even the organizational level. In our application, we&rsquo;ve organized the solution to make it clear where the boundaries are between our contexts. The main area that we are currently focused on is the appointment scheduling bounded context. ‑We&rsquo;ve identified two other bounded contexts that are involved in the overall application or will be eventually. For instance, it&rsquo;ll be important for users to be able to manage clients and their patients. The staff of the clinic also needs a way to manage their schedules so they know who&rsquo;s working on different days. We&rsquo;re referring to these two bounded contexts as client patient management and resource scheduling. ‑We also have a few parts of the application that are common to several bounded contexts. These are cross‑cutting concerns that we have consciously chosen to share. In DDD, we isolate such code into its own package referred to as a shared kernel, and it&rsquo;s worth noting that a bounded context does not always mean a separate application, even though we&rsquo;ve identified several different bounded contexts. ‑It&rsquo;s also a great opportunity to consider packaging logic up into microservices. Do keep in mind, however, that there&rsquo;s not always a 1:1 alignment between bounded contexts and microservices or applications. Also, let&rsquo;s not forget that our application will definitely need a front end.</p>
<p>Understanding the Ubiquitous Language of a Bounded Context
We&rsquo;ve mentioned already that an important part of DDD is an emphasis on effective communication among the stakeholders in the project. And remember, if you&rsquo;re a programmer, count yourself as one of the stakeholders in whatever you&rsquo;re working on since you certainly have a stake in its success. The language we use to describe the problem and how we choose to model it is key to the shared understanding we want to have with our domain experts in order to be successful. Having a single, shared, ubiquitous language helps avoid unnecessary confusion and translation within the team building the software and is one of the fundamental practices of Domain‑Driven Design. And when I talk about the team building the software, I don&rsquo;t just mean the programmers. I mean the whole team, including the business people that are deriving what the software should do. The discovery of the Rosetta Stone allowed us to unlock several different languages by showing the same message in three different texts. We don&rsquo;t want to have to have a Rosetta Stone or any other sort of tool to help us translate between what the business is talking about and what the programmers are talking about. We want to make sure that everyone is speaking the same language the whole time so that translation is unnecessary. ‑Think about if you&rsquo;ve ever used an online translation tool to round trip a sentence. You can run into similar communication issues in your application if you&rsquo;re constantly having to translate to and from the domain expert terms or the programmer&rsquo;s terms. Here&rsquo;s an example of a user story for a sample system about creating appointments. ‑We have a lot of developer friends in Nigeria, so I thought it would be fun to try out Igbo for our translation. We used a website to translate between English and Igbo a few times, and in the end, the user story has changed just enough to create confusion. Translation software is pretty good these days, and we were hoping for a more humorous result, but according to animal experts, it&rsquo;s close, but not the same as a veterinary technician. ‑But the point here, of course, isn&rsquo;t just relating to different international languages, but to the different languages spoken by business experts and programmers. ‑Incidentally, a great practice when you&rsquo;re discussing your system requirements with customers is to always try and explain back to them what you think it is they want the system to do so they have an opportunity to correct your understanding of what they think they just told you. ‑Definitely. Remember, one of the key benefits of using a ubiquitous language is that all parties can understand it without having to perform any translation. This means when you show a test or some code to a domain expert, you don&rsquo;t have to explain that in the system you call something an animal when the domain expert calls it a patient. ‑Evans cautions that a project faces serious problems when it&rsquo;s language is fractured. When domain experts stick to using their jargon while the technical team members have their own language tuned to discussing the domain terms in the design, translation errors will manifest as software bugs. Neither the customers nor the developer&rsquo;s language is sufficient for all parties to discuss the application effectively. What is needed is a shared common language that incorporates and uses terms defined in the domain model. The use of this language must be ubiquitous, and the more the language is used, the more will force deficiencies in the model into the open. ‑And by ubiquitous, we mean it must be used everywhere within the bounded context. The vocabulary of the language includes the names of model classes and prominent operations. The team should use these common terms in code, in diagrams, on the whiteboard, in design documents, and especially when discussing the system. ‑Yeah, pretty much ubiquitous means everywhere, all the time. Even in that one email you&rsquo;re sending off to another developer, stick to using the terms that you&rsquo;ve agreed makes sense for this bounded context.</p>
<p>Conversation with a Domain Expert: Working on our Ubiquitous Language
You&rsquo;ve heard some of our conversations that helped lead to a ubiquitous language for the scheduling app. There was another important one that happened early on between Michelle and me that we want to share with you now. ‑Pay attention to not only the clarification of the terms, but also to the fact that Julie and Michelle are equal partners in this conversation. Although Julie is trying to lead the conversation towards the goal of identifying the correct terms, she&rsquo;s careful not to make assumptions about Michelle&rsquo;s domain. ‑So Michelle, last time you and Steve and I got together to talk, Steve and I have been working on just kind of fleshing things out and planning things, and I realized that we had some confusion over some of the common terms, like things that, as real pet owners, we would kind of assume the terms are, but then when we&rsquo;re thinking about business and software, we&rsquo;re thinking of the terms a little differently. So I was wondering if we could just sort that out with you so that we&rsquo;re all on the same page and using the same terms and using terms that none of us have to stop and think about what we&rsquo;re talking about. We&rsquo;ll always know what they mean. ‑Sure. ‑The first thing is we have these clients, those are the people who own the pet. So when thinking about the software and business, we think of them as clients, but kind of in the real world, and me, I have a pet, I go to the vet all the time. I think of myself as a pet owner. So what do you refer to those people who bring the pets, pay their bills, call and make the appointments, etc? ‑Most of the time, I mean those would be listed as as clients. ‑Okay, so you do call them clients. You don&rsquo;t worry about calling them owners, and of course, it sounds kind of weird to say I own a dog, right? ‑He kind of owns you. ‑Yeah, that&rsquo;s more like it. You&rsquo;re the pro you know. So then what about that dog, like are they patients, are they pets, are they clients? What do you refer to the pets as? ‑So for the purpose of the medical record, we refer to them as the patient. ‑Okay. So it would be client and patient. ‑Exactly. And actually in veterinary medicine they talk a lot about this triad, the veterinary client/patient relationship, where all three are really important in that. ‑Okay. So those are actually terms that are commonly used in your industry. Industry, that sounds so weird, but with that. Cool. Alright, so the next one we were also going back and forth on was an appointment or an office visit. When somebody is scheduling a visit, scheduling to come in, how do you refer to that? ‑So there would be two big subsets of what they might be scheduling to come in for. They might schedule a surgery, which is an easy one to define. They&rsquo;re going to come in, we&rsquo;re going to do some sort of a procedure. Usually, there is going to be some anesthetic involved. That would be a surgery and that would be outside of our normal office hours. ‑Oh, okay. So what about when they just come in for regular stuff? ‑So when they come in for regular appointments, you could call those office visits or appointments, and there are a few different subsets of those. You may have an appointment that&rsquo;s a wellness exam, and in that exam, we would be doing, of course, a physical examination and generally wellness treatments like vaccination, some blood work, generally your healthy pet who is coming in for a routine checkup. ‑So that&rsquo;s an office visit and there is a couple other things that come under the umbrella of office visit, but if I, I&rsquo;m also thinking about scheduling because that&rsquo;s the thing we&rsquo;re really going to be focused on is the scheduling portion of the app. So we&rsquo;re always scheduling an appointment, an appointment for a surgery, an appointment for an office visit, whatever type of office visit that is, so is using the term appointment, does that make sense? Would you, if if I said appointment would you think that could be a surgery, that could be a checkup, that could be whatever. This thing to be scheduled is what I want to define. ‑Yeah, I mean I think you could call them all appointments, but I would differentiate between the surgery and something that&rsquo;s done in the office, but then I would further differentiate in the office between a wellness exam, an exam for somebody that&rsquo;s coming in with a problem, or an exam that doesn&rsquo;t need to see a doctor, but could just be done by a technician like a toenail trim. ‑Oh good. Yeah, we always need those, clickety‑clack on the floors. Alright, so I think then we&rsquo;ll use just the overall umbrella of we&rsquo;ll schedule an appointment and then we&rsquo;ll be more explicit about what type of an appointment that&rsquo;s going to be. Would that feel okay to you? ‑Yeah, that makes sense to me. ‑Great. Excellent. Alright, so I&rsquo;ll get back to Steve and then we&rsquo;ve got another meeting set up I think in a few days to just hash out some more details after Steve and I&rsquo;ve gotten some more of our ducks in a row. ‑Sounds great! ‑Excellent. Thanks Michelle. Bye bye. ‑Thank you. Bye. ‑Now we have a stake in the ground for our ubiquitous language. As we continue working with Michelle, not only will we learn more items for the bounded context, but there is also a chance that the ubiquitous language will evolve. Eric Evans guides us to pay attention to those changes because a change in the ubiquitous language is also likely to mean a change in the domain model. We have to update our design to accommodate what we&rsquo;ve learned.</p>
<p>Reviewing Important Concepts from This Module
We&rsquo;ve covered quite a few concepts in this module. One of the most important ones is just understanding the problem domain and the overall thing that your software is working within. ‑‑And breaking things apart. I know that when I started out, I had a really hard time really understanding differences between the core domain, the subdomains, and the bounded context, especially the subdomains and the bounded context because at first glance, they looked like the same thing to me. ‑‑Sure, it&rsquo;s really easy to have an application where you have some kind of a concept, like a customer that you know is used by every system that your organization uses. And it ends up becoming this like God object in your database and in your different applications where any given application might only care about a tiny subset of that concept. ‑‑Yeah. So, for me, I think the most important thing is really focusing on the bounded context. Getting down to that and understanding about the boundaries. One thing that helps me a lot is just stating within the context of this and then suddenly like, oh right, that&rsquo;s what a context is. It&rsquo;s not like some mysterious new term that Eric Evans invented. He just is leveraging what makes sense. Within the context of appointment scheduling, this is what a client looks like. Within the context of billing, this is what a client looks like. ‑‑Sure, I think that makes a lot of sense. And it&rsquo;s valuable, even when you have an application, like a legacy application that wasn&rsquo;t built with domain‑driven design. Let&rsquo;s go ahead and look at some more terms here. For instance, we&rsquo;ve got what you were just talking about, I think of as context mapping. And even in a legacy application, it can be valuable to kind of map out what are all the concepts in this application and where are the overlaps with different subdomains that maybe we haven&rsquo;t even defined in this legacy application. ‑‑Yeah. Even if you&rsquo;re not planning on making huge changes to it, it&rsquo;s still really, really helpful to just kind of update your perspective on things. Sometimes it just leads to new understandings. ‑‑I think the shared kernel is a really important part of this, too, because in almost every real‑world organization I&rsquo;ve worked with, there are different types of cross‑cutting concerns, and we talked about one of them being the authentication piece, and that&rsquo;s definitely a really common one. But there are usually others too that you want to share. ‑‑Yeah, and, again, it&rsquo;s another one of those things that sounds like it might be a big, scary, mysterious thing because you haven&rsquo;t referred to it that way, but if you really just start out thinking of it as the common stuff, but then‑‑‑I think one of the important things, though, is even within the context of domain‑driven design, we have a ubiquitous language because if I say common, you might have a different idea of what I mean by common, but if I say shared kernel, we&rsquo;ve got an agreed‑upon understanding of what we&rsquo;re talking about there. So at first, I really kind of pushed back against using these terms because I felt like a lot of the DDD experts were just throwing them around all the time. And then I started really getting a better understanding of why it&rsquo;s important to use those terms. It&rsquo;s about‑‑‑it&rsquo;s the ubiquitous language of domain‑driven design so everybody&rsquo;s on the same page. ‑‑Yeah, I do agree that that&rsquo;s an important part of learning about DDD and other areas of software development, like, for instance, design patterns. These things give us these terms that we can use that are very, very dense. If we talk about shared kernel, it would take me three or four sentences to describe what I meant by that. But in these two words, you know exactly what I mean, just like if I talk about using a strategy design pattern, that is much easier to convey than if I were to try and describe it with words and have to draw a UML diagrams to say what I mean. ‑‑And it&rsquo;s the same, again, with the ubiquitous language because now I really have a better understanding of the fact that what it means is the language is ubiquitous throughout a particular bounded context. When we&rsquo;re talking about a scheduling app, we&rsquo;re going to use these terms all the way through, like you were saying before, we use it not just when we&rsquo;re talking to the domain expert but in our class names, in our methods, it&rsquo;s just ubiquitous throughout all of the pieces of the things that are involved in that bounded context from one end all the way to the other of it. ‑‑And I think as we&rsquo;ll see when we look at the code again, some of the constructs in .NET, like namespaces, are really appropriate to ubiquitous language because when you prefix that same term in your code with a particular namespace, that tells all the other programmers that if I say SchedulingApp.notification, we know that that has a different meaning that if I&rsquo;m talking about EmailReminder.notification. ‑‑Or SchedulingApp.client versus Billing.client. ‑‑Exactly.</p>
<p>Review and Resources
In this module, we learned about our domain, in this case, a veterinary practice. We talked about it at length with a real live domain expert and identified the core elements of our domain model. We identified a variety of subdomains and focused in on the key area that we would be addressing first with our application. ‑We spent some time designing the system based on our conversations with Michelle, identifying boundaries between different contexts, and noting how sometimes the same object with the same name might mean something different within a different context. ‑Finally, we talked about the importance of communication in general and in particular having a ubiquitous language. We know that Domain‑Driven Design can help us avoid many design errors and wasted time miscommunicating as we work on a complex project. ‑Steve and I are so grateful to Eric Evans for spending time with us while we were creating this course in order to share his luminous advice and insights. In the next module, we&rsquo;ll drill into the domain model so you can have a good understanding of its critical elements. ‑This is Steve smith, ‑and this is Julie Lerman. Thanks again for watching Domain‑Driven Design Fundamentals.</p>
<p>Elements of a Domain Model
Introduction and Overview
Hello, this is Julie Lerman, ‑and this is Steve Smith. ‑In this module, we&rsquo;re going to focus on the elements of a domain model which are in our bounded context. ‑You&rsquo;ve seen these in the mind map. It&rsquo;s patterns like entities and aggregates and more. ‑You can find me online at ardalis.com or on Twitter as @ardalis. ‑And you can find me online at thedatafarm.com or on Twitter at @julielerman. ‑In this module, we&rsquo;ll focus on the technical aspects involved when modeling a bounded context. We use these terms while modeling, and these same terms refer to patterns we&rsquo;ll use when we code. The concepts flow through the entire process, which is great. You don&rsquo;t have to keep switching hats or mindsets. ‑We&rsquo;ll start by grounding ourselves in the domain and understand why it&rsquo;s important to stay focused there. DDD models are driven by behaviors, not classes and properties. This is another very cool shift in thinking for those of us who have always focused on objects. Then you&rsquo;ll learn about some terms used to describe domain models, rich and anemic. You learn what the terms mean at a conceptual level and what the code that they&rsquo;re describing looks like. ‑Entities are the key types in your system, but not every type in your system is an entity. ‑You&rsquo;ll learn how entities fit into DDD, how to differentiate entities that have complex needs from simpler entities that might only need some basic CRUD logic, and you&rsquo;ll be able to see how we&rsquo;re implementing all of these concepts in our code.</p>
<p>The Importance of Understanding DDD Terms
Domain‑Driven Design is filled with lots of specific terms. Much like the ubiquitous language that we use to make it easier to communicate while working within a bounded context, understanding and using the terms of DDD makes it easier to talk about the process. We&rsquo;ll spend the bulk of this module focusing on some of the concepts behind modeling bounded contexts, concepts that are critical to this process, but, unfortunately, often misunderstood. ‑I&rsquo;ve definitely had my challenges with some of the DDD concepts. Some of my issues were because the terms overlap with other technologies I use. For example, I do a lot of work with Microsoft&rsquo;s ORM called Entity Framework. Entities are a key element in Entity Framework, and they&rsquo;re also a key element in DDD. So I thought my understanding of entities from Entity Framework was enough to translate to DDD entities, but it really wasn&rsquo;t, and my less than solid grasp on DDD entities caused problems when I was trying to model domains and implement the model and code. We also have the concept of a context in Entity Framework. While the real goal of that context is to provide interaction with the database, it also does provide a boundary around a model. But it&rsquo;s very different than the concept of a bounded context, and that definitely confused me for a while. Another important element in a DDD model is value objects. These got me pretty confused at first, and my ego was saved by discovering that others have also been confused by value objects. But I&rsquo;ve worked on my DDD education and sorted these problems out, so in this module, it&rsquo;s really important to both Steve and I that you start off on the right foot with a proper understanding of entities, value objects, and some of the other DDD puzzle pieces so that Domain‑Driven Design can help you with your complex problems, not complicate them even more.</p>
<p>Focusing on the Domain
It&rsquo;s important to remember that first D in DDD stands for Domain, and yeah, the other two Ds, Driven and Design. But we really want to focus on Domain here. ‑By now, you&rsquo;ve probably heard us talk about this plenty, but both Julie and I find that we constantly have to remind ourselves to focus on the domain. We hear ourselves begin to talk about the user interaction with the app and have to ask, well, what part of the vet clinic domain is this user? Yeah, obviously we care about the user and how the actual application will work from their perspective, but that&rsquo;s for another conversation, and we have to draw ourselves back to focusing on modeling the domain. ‑I have quite a long history with data access, and I catch myself worrying about how our domain model will translate to the database so that things definitely get persisted correctly. That&rsquo;s when Steve needs to give me that look, you&rsquo;re doing it again, Julie, and I have to bring my focus back to the domain of the vet clinic again. So while it may seem redundant to harp on domain, domain, domain, this diligent focus will help you avoid the complications and distractions that come from thinking outside of the domain or the subdomain that you&rsquo;re focused on. ‑Here&rsquo;s an important quote from Eric Evans&rsquo; book about this focus on the domain. &ldquo;The Domain Layer is responsible for representing concepts of the business, information about the business situation, and business rules. State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure. This layer of the domain is the heart of business software.&rdquo; ‑Just to reiterate, the domain model is the heart of the business software. This is the whole point behind Domain‑Driven Design. Focus on the domain, not the technical details of how the software will work. ‑In a typical database‑driven app, we&rsquo;re used to focusing on properties or attributes of classes. Our apps sometimes become all about editing property values and the state of our objects. However, when we are modeling a domain, we need to focus on the behaviors of that domain, not simply about changing the state of objects. ‑Michelle didn&rsquo;t talk to us about setting the name of a dog or editing the time of an appointment. She told us that she needs to schedule an appointment, and when she does that, she needs to book a room and create a schedule item on a doctor&rsquo;s calendar as well. So scheduling appointment is a lot more than setting the attributes of the objects involved, the appointment time and identity of the pet we&rsquo;re making the appointment for. We&rsquo;re talking instead about how the system behaves. In response to scheduling an appointment, the system should also book a room and do something to the calendars of the doctor and any vet techs that might be involved.</p>
<p>Identifying Events Leads to Understanding Behaviors
An important way to identify behaviors in your system is by focusing on events. Doing so gives you a great path to understanding the behaviors of your domain. Alberto Brandolini devised a great way to brainstorm with clients, which is referred to as event storming. It begins by having a somewhat chaotic brainstorming session with a good number of domain experts writing events on Post‑its and sticking them on a wall. The format of what they write is in the past tense. For example, an appointment was booked, a client contacted the office, or a dog was weighed in. I facilitated quite a few event storming workshops with clients, and I&rsquo;m a big fan of using this process to help get a picture of the domain, discover bounded contexts, and even discover key problems that should be addressed. Another interesting methodology for modeling a system based on events is called Event Modeling. Adam Dymitruk came up with this workflow and has had great success using it to help teams collaborate on learning about the domain and designing the flow of software. I was fortunate to participate in a three‑day workshop with Adam to learn about Event Modeling. We won&rsquo;t be teaching you about event storming or Event Modeling in this course, those are beyond the scope of our goals here, but we did want to be sure you were aware of them. You&rsquo;ll find links for more information about event storming and Event Modeling at the end of this module.</p>
<p>Comparing Anemic and Rich Domain Models
In order to understand the difference between design that&rsquo;s focused on attributes versus design focused on behaviors, it will help to understand two commonly‑used terms in domain‑driven design, anemic domain models and rich domain models. An anemic domain model is a domain model that is focused on the state of its objects, which is the antithesis of DDD. While the term is somewhat negative indicating a deficiency, you don&rsquo;t need to perceive it that way. There is nothing wrong with anemic classes when all you need to do is some CRUD logic, but if you are creating a domain model, you&rsquo;ve already made the decision that your domain is too complex for simple CRUD. So anemia in a domain model is considered an anti‑pattern. ‑Martin Fowler writes about anemic domain models with such drama that you may never mistakenly use them in your domain model. He says the basic symptom of an anemic domain model is that at first blush it looks like the real thing. There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have. The catch comes when you look at the behavior and you realize that there is hardly any behavior on these objects making them little more than bags of getters and setters. Indeed, often these models come with design rules that say you are not to put any domain logic in the domain objects. Instead, there are a set of service objects would capture all the domain logic. These services live on top of the domain model and use the domain model for data. ‑What we aim for then is rich domain models, not anemic domain models when we are modelling our domain. Rich domain models will represent the behaviors and business logic of your domain. Classes that simply affect state are considered an anti‑pattern in a domain model, and therefore, get the nasty label of anemic, even though they are perfectly fine in a CRUD model. Martin Fowler doesn&rsquo;t mince words when it comes to anemic domain models saying the fundamental horror of this anti‑pattern is that it&rsquo;s so contrary to the basic idea of object‑oriented design, which is to combine data and process together. I have to say I agree and I&rsquo;ve worked with many teams who have had to deal with the self‑inflicted pain of treating their domain entities like DTOs lacking any encapsulation or behavior. That can work for simple CRUD apps, but it&rsquo;s often a disaster in a DDD model. ‑While Martin Fowler and other DDDers have strong words to say about anemic domain models, we&rsquo;d like to share a gentler message, which is to strive for rich domain models and have an awareness of the strengths and weaknesses of those that are not so rich.</p>
<p>Understanding Entities
Even though a DDD app is driven by behavior, we still need objects. DDD expresses two types of objects, those which are defined by an identity and those which are defined by their values. We&rsquo;ll focus first on the objects that are defined by their identity. These objects are called entities. ‑An entity is something we need to be able to track, locate, retrieve, and store, and we do that with an identity key. Its properties may change, so we can&rsquo;t use its properties to identify the object. If you&rsquo;ve done any type of data persistence in software, you&rsquo;re probably pretty familiar with entities and their keys. When we are modeling a problem, we can talk about entities without having to think about how they are implemented in the resulting software. But when it is time to start coding, there are patterns to follow to ensure that these objects have the technical attributes of Domain‑Driven Design entities. ‑As you can see from this section of the DDD navigation map, entities are pretty integral to our software. So, before we can learn about these other elements, domain events, repositories, factories, and more, you should have a very good understanding of an entity. ‑The most important entity in our model is Appointment. This is what we will be creating, editing, and retrieving in the context of scheduling appointments. Appointment inherits from a base class we&rsquo;ve created called Entity. We&rsquo;ll look at that more in just a bit. Notice that all of the classes shown here are inheriting from the identity base class. However, although the other classes are entities, after our discussions with Michelle, we came to the conclusion that we would like to have a separate utility for managing client and patient information and to manage information about staff and staff scheduling. Thus, we don&rsquo;t need very much information or behavior related to these collaborating entities within the bounded context of appointment scheduling.</p>
<p>Differentiating CRUD from Complex Problems that Benefit from DDD
‑Let&rsquo;s take a closer look at that data that supports scheduling appointments in our system. ‑We determined that managing the client, patient, and staff information, which is external to this model, was well‑suited to just simple CRUD. We didn&rsquo;t identify complex rules or behaviors for creating and editing that data. Thus, the concepts of doctors, rooms, clients, and patients are managed outside of the scheduling bounded context. ‑For comparison, look at the CRUD classes for Patient and Client in the other bounded context. They&rsquo;re very simple. They don&rsquo;t inherit from our entity base class, and most interestingly, their ID properties are integers. We&rsquo;ll let the database assign the IDs when we create these classes. So these classes are not designed using domain‑driven design. Now let&rsquo;s go back to the appointment scheduling context. The client, patient, doctor, and room classes here are completely different from the CRUD classes we just saw. However, they do have a subset of the same fields from those CRUD classes. All we need to know about these objects when we&rsquo;re scheduling is their IDs, their names, and maybe a few other details. But here, they&rsquo;re simply used as look‑up data, and they&rsquo;reread‑only.</p>
<p>Switching Between Contexts in a UI
Even though our domain is split up into a number of bounded context, the user interface can be designed in a way that moving from one context to another is seamless to the end users, they don&rsquo;t need to know that these things are in separate bounded contexts. While maintaining client and patient data is a completely separate task from scheduling appointments, Michelle wanted to be sure that anyone working at the front desk is able to easily move between these tasks in the software without disrupting their workflow. So let&rsquo;s say the person at the clinic who does the scheduling is on the phone with Kim and about to make an appointment for Roxy to come in, but then the other line rings, they put Kim on hold, and it&rsquo;s me. And in the nicest way possible, I&rsquo;ve called to just let her know they&rsquo;ve got my last name spelled wrong. That happens all the time. People just want to put that h in there. Even though they&rsquo;re in the middle of scheduling and scheduling has its own backend, its own bounded context, and is totally separate from client management, they can still drive the app right over to the Client Management area and very quickly fix my name and save that. Then they can just flip back to the schedule. Notice that Kim is still the active scheduling client that&rsquo;s showing up in the left‑hand corner and the change to the spelling of my last name is already visible on the schedule. And so now that person can go ahead and finish up with Kim scheduling the very adorable Roxy for a wellness exam. To the user, there is no real difference between doing the scheduling and doing the client management, it&rsquo;s just a nice smooth flow between the two, it doesn&rsquo;t feel like, oh, now we have to open up a different application in order to do this other thing and doesn&rsquo;t break everything they&rsquo;re in the middle of, but for the purposes of designing our application, everything is bound within its own individual context. And when designing this context, we don&rsquo;t have to worry about switching from one context to another. ‑So remember, we&rsquo;re talking about what makes these all entities. An appointment object needs to be located and tracked and we need to be able to edit them easily. Using a unique identity allows us to persist and retrieve an appointment even if some of its values change. Appointment is definitely an entity in our system. We actually had to think a little more about client, patient, doctor, and room in this particular context. Our discussions highlighted the fact that when creating appointments, we only need access to some of the high‑level information about the client, patient, doctor, and room, but these objects won&rsquo;t be edited. So we wanted these stripped down read‑only types that give us minimal amount of detail for each. We do still need to be able to uniquely identify them though, they do have some identity. If the client&rsquo;s name changes, a change we would make in the client management system, that new name will need to be reflected when we look at the appointment scheduling for that client. There should only ever be one record to represent a particular client in this bounded context. So client and the other types that are reference types in this context are still entities. We triple checked our decision with another kind of domain expert, Vaughn Vernon, a DDD expert, and we were happy to get his thumbs up on this particular decision. So Julie, Michelle, and I also talked about how to name the types that are simply reference types in this particular bounded context. At first, we were worried that we might get confused by having different definitions of client, patient, doctor, and room. We wanted to call them client details or client view or something like that, but thanks to the ubiquitous language, the fact that we are in the scheduling context drives our comprehension of what a client means in this particular space. ‑A client in scheduling is still a client, so we use the same name, even though it&rsquo;s a differently defined pipe than the client we work with in the Client/Patient Management app. ‑Right, and thanks to namespaces in our code, we&rsquo;re able to keep it clear which ones are which in the code.</p>
<p>Using GUIDs or Ints for Identity Values
So, all these types inherit from our base entity class. However, notice that those reference types use int for their base entity&rsquo;s ID and not the GUID that&rsquo;s used by appointment. That&rsquo;s because all of the management of those other types happens to be done using CRUD, and with CRUD, it&rsquo;s easy to just use database‑generated ints. Appointment is built using DDD principles, and you&rsquo;ll see that it&rsquo;s much easier to use GUIDs when building DDD entities and their related logic rather than relying on the database to provide the identity values. Not only is it easier, but it follows DDD principals more clearly, since we will build all of our domain logic around appointments without involving the database. We would have a hard time working with appointments in our model and in our unit tests as we develop the application if we always needed a database to assign their IDs. ‑So that&rsquo;s not to say that you can&rsquo;t use integer IDs If you&rsquo;re going to use a DDD style of application; it just makes it a little harder. Wouldn&rsquo;t you say, Julie? ‑Yeah, yeah, and I&rsquo;ve definitely come up against that. With the stuff that I do with Entity Framework, I&rsquo;ve made sure that I show patterns for continuing to use the database‑generated ints because I didn&rsquo;t want to give people the impression that they had to throw away, like, for me like 25 years of this dependency. And like all of a sudden I have to go cold turkey and move over to GUIDs. ‑Sure, I mean, there&rsquo;s trade‑offs in what you choose to use for your ID, but having an ID that we can generate in the client and just in our code has a lot of value. ‑Every time we&rsquo;ve been working on some of our different unit tests and we needed as part of the test to instantiate something that was an int, we were like, ugh, now we have to find another way to get that in there because we were protecting it and it was a problem. As our own experience grew, we realized there&rsquo;s another way to bridge this conflict by using both GUIDs and database‑generated ints in an entity. This way, while creating objects, you&rsquo;ve got the control over key generation with the GUIDs, and they&rsquo;re not depending on the database. However, once the data has been created in the database and int keys exist for it, then you can benefit from those when adding indexes and performing queries in the database.</p>
<p>Talking with Eric Evans About the Responsibility of Entities
We talked with Eric Evans to gain some additional insight into entities. Specifically, I asked him how entities align with the single responsibility principle. ‑‑If you&rsquo;re not familiar with this object‑oriented programming principle, you can learn more about it in Steve&rsquo;s SOLID course right here, on Pluralsight. ‑‑One of the questions that I&rsquo;ve heard is, What is the single responsibility for an entity? Or to put it another way, does having an entity that has a lot of business logic in it violate the single responsibility principle? ‑‑Eric told us that entities are very central, and so it&rsquo;s natural that they get heaped up with lots of functionality. ‑‑But there&rsquo;s a downside to this. As you build out the system, there are more and more conflicting demands for these central entities, so they end up being huge. Evans said that the main responsibility is the identity and the lifecycle. ‑‑Eric also told us that single responsibility is a good principle to apply to entities, and it points you towards the sort of responsibility that an entity should retain. Anything that doesn&rsquo;t fall into that category, we ought to put somewhere else.</p>
<p>Implementing Entities in Code
Let&rsquo;s take a look at an entity in our veterinary appointment scheduling application, FrontDesk. We&rsquo;re going to look at the Appointment class, which defines all the information that we need to schedule an appointment for a particular animal or patient. It associates the patient with the doctor, room, and appointment type, and also includes the start and end time for the appointment. Now, the Appointment class inherits from BaseEntity<T>, which is a generic base class. In this case, it&rsquo;s BaseEntity<Guid>, as you can see here. The GUID is defining the type of our identity property, our ID. ‑Right. And we talked about that earlier when we were looking at the structure of the different entities in this model. We wanted Appointment to have a GUID because we&rsquo;re creating new appointments on the fly. So, let&rsquo;s take a look at that BaseEntity class. First of all, it&rsquo;s an abstract class. So we can&rsquo;t just create a BaseEntity object, we have to create something that is a BaseEntity, such as an appointment. And using generics, we&rsquo;re saying that the BaseEntity is going to use whatever type we ask it to, and that type is for defining the ID. So for Appointment, we said BaseEntity is going to be using a GUID as its identity. I mentioned this earlier, why I would need GUID for appointment in this context because I need to be able to create new appointments in this context, and I&rsquo;m not going to be waiting for the database to generate the ID for me. So using a GUID lets me create that ID right up front as I&rsquo;m creating that new appointment. So I&rsquo;m giving it its ID. The BaseEntity class also has a property to hold a list of domain events that will define explicitly for each of the types that inherit from this base entity. You&rsquo;ll learn more about domain events further on in this course. ‑All right, so let&rsquo;s take a look back at the rest of Appointment. Now, since Appointment has more behavior than just state, we don&rsquo;t want to have it just be a bag of properties that our application can get and set however they would like. ‑Because that would be an anemic domain model. ‑Yes, because that would tend to lead us toward a more anemic domain model. ‑And we want a rich one. ‑Now, in particular, we&rsquo;re also constraining how we create this appointment. We want to ensure we create appointments in a valid state, so that means passing in the minimum necessary elements an appointment needs to have. Sometimes we&rsquo;ll want to update an appointment. Remember, these aren&rsquo;t value objects. They&rsquo;re not immutable, so we can change them. When we need to modify an appointment, we&rsquo;re going to do that through methods. And so, for instance, if we decide we want to modify what room an appointment is scheduled in, we&rsquo;re going to do that through a method rather than just a setter. We do this because there&rsquo;s additional behavior we may want to do. In this case, we have some guards, again to ensure a valid value is being passed. ‑These guards are a set of reusable functions that you&rsquo;ll find in the shared kernel of our solution. ‑And we also want to raise an appointmentUpdatedEvent, that we might handle and send a notification or perform some other action as a result of what happened. ‑And that also gives us the flexibility in the future to change what type of logic we want to trigger. ‑And that&rsquo;s something we can&rsquo;t do very easily If we just let anybody in the application set the value. ‑Right. ‑By providing a method to use to update room explicitly and otherwise making the setter private, we force all interaction with the model to use this method, which gives us just one place to model behavior that should be associated with this operation. It&rsquo;s the same as with the constructor, we need to do our best to keep our domain model in a consistent state so the rest of the application can count on it being correct. ‑Right, because otherwise somebody could satisfy the requirement that they pass in the room ID, but they might pass it in as 0, which would be invalid. So, we&rsquo;re further constraining that they don&rsquo;t do that either. The appointment would be invalid if it had a room ID that didn&rsquo;t correspond to an actual room entity. And in any case, the database wouldn&rsquo;t let that fly since there&rsquo;s a foreign key relationship between appointment and room. ‑Yes, but we want to make at least some effort to catch such problems in our code, rather than relying on the persistent store to inform us of a user error. Overall, using guard clauses, like the ones you&rsquo;ve seen here, help us ensure our entities aren&rsquo;t partially constructed and inconsistent. Once we&rsquo;ve created an appointment, we need to record it as part of the clinic schedule, which involves some additional rich behavior. So, if we scroll down to the bottom, we have this method called Schedule. And this is where we&rsquo;re going to do the additional work involved with actually saving an appointment and ensuring it fits in with other appointments that have already been scheduled. We&rsquo;re not going to worry about the code at the moment, but the idea is that this method would query the database for other appointments that might be near this one and make sure there is an available slot in the schedule that this one fits into. Then it will save the appointment and raise an event, letting the rest of the app know that a new appointment has been scheduled. In the next module, we&rsquo;ll investigate this design further and revise it a little bit. Now, let&rsquo;s look at one more simple entity that this bounded context needs, the Doctor class. You can see that Doctor inherits from BaseEntity as well, but in this case it&rsquo;s using an int for its key. The only other property it has is a string Name property. ‑This is a minimal implementation of the Doctor type that satisfies the scheduling bounded context. It&rsquo;s essentially no more than a reference type. Doctor and the other similar types, Patient, Room, etc., are all organized into this folder called SyncedAggregates.</p>
<p>Synchronizing Data Across Bounded Contexts
Let&rsquo;s dig a little more into how these reference types in the scheduling bounded context are getting their data from the Clinic Management app, especially if the two BCs aren&rsquo;t sharing a database. If you recall from seeing the class descriptions of all of these classes, the AppointmentType, Client, Doctor, Patient, and Room, we had explicitly decided that these are reference entities where we&rsquo;re actually doing their maintenance elsewhere so they&rsquo;re not adding any unneeded complexity to the Front Desk application. ‑‑Right. And they&rsquo;re just READONLY. So we&rsquo;re never having to create or modify them. ‑‑And we&rsquo;re using the ints that were created by the database when we persisted these with a CRUD context in a different application, but there are still entities here, just entities of type integer. The Clinic Management bounded context is responsible for updating these types. When changes are made, application events are published by Clinic Management, and this Front Desk bounded context subscribes to those events and updates its copies of the entities. ‑‑One of the questions we get all the time when we describe how bounded contexts have separate databases is, How do we synchronize changes between these two apps? This is one of the simplest and most common approaches. One app is responsible for updates, and the other apps just subscribe to the changes and are notified when they occur. ‑‑This is an example of eventual consistency. The two systems aren&rsquo;t immediately kept in sync using a transaction or something similar, but through message queues, eventually the different bounded contexts are updated to the new state when a change is made.</p>
<p>Review and Resources
We&rsquo;ve covered a lot of ground in this module and you&rsquo;ve learned a lot of new terms, so we just want to review some of them with you before we move onto the next module. The first is a pair of terms that often go hand in hand, anemic domain models versus rich domain models. And remember the anemic domain models, while often looked down upon from the perspective of DDD, they&rsquo;re perfectly fine for CRUD. These are models that look a lot more like a database schema than a class that has lots of methods and rich behavior in it. On the other side of that is a rich domain model, which is what we strive for in domain‑driven design, and that&rsquo;s a model that really is focused on behavior, not just changing the values of properties. ‑Then we talked about entities and entities tend to be one of the core pieces of our domain model. The key thing that distinguishes an entity from other types in our model is that it has some kind of identity that we can use to track it over time and to bring it in and out of persistence. This module provided you with your first look at implementing a bounded context in code, an important part of tactical design. You learned about the difference between anemic models and rich models, and that while anemic models have their place, focusing on behavior with rich domain models is how DDD lets us solve complex problems. Entities are the classes in our domain models that are tracked by an identifier allowing us to build graphs and eventually persist and retrieve that data. ‑Sometimes we are working with entities whose behavior and rules are critical to the bounded context in which we&rsquo;re working. Other entities may only provide supporting or reference data. You learned how to help identify the differences between them. Then you got to look at the appointment class in our scheduling app to see how we have applied rules and behaviors in that entity. You also looked at one of the reference entities and learned how we use message queues to ensure the reference and the data that is maintained in the clinic management app is made available to the scheduling bounded context, even though they do not share a database. ‑In the next module, we&rsquo;ll focus on some more important elements of a domain model, value objects and domain services. We&rsquo;ve referenced a lot of interesting and helpful resources in this module and here are two pages of links for you to follow up with if you want to dig in a little further, including Steve&rsquo;s Pluralsight course on SOLID principles of object‑oriented design and information on event storming and event modeling. This is Julie Lerman ‑and this is Steve Smith, and thanks for watching our course, Domain‑Driven Design Fundamentals.</p>
<p>Understanding Value Objects &amp; Services in the Model
Introduction and Overview
Hello! I&rsquo;m Julie Lerman. ‑And I&rsquo;m Steve Smith. Welcome back to Domain‑Driven Design Fundamentals. In this module, we&rsquo;ll continue exploring the elements of a domain model as we dig into value objects and domain services. ‑Value objects are a confusing concept. So we&rsquo;ll begin by looking at where they fit into the mind map and introducing what makes an object a value object, and how they relate to entities in a model. ‑We&rsquo;ll share some more guidance from Eric Evans and Vaughn Vernon, and then show how we&rsquo;ve implemented value objects in our code. ‑Next, you&rsquo;ll gain a high‑level understanding of domain services, and solidify that by exploring their features, and then some examples of domain services.</p>
<p>Getting Acquainted with Value Objects
When introducing entities, Steve and I talked about objects that were defined by a thread of continuity and identity, not defined by their values. So, what about objects that are defined by their values? These are called value objects, and they play an equally important role in a domain model, as entity objects do. ‑A value object has very specific characteristics. It is an object that is used to measure, quantify, or describe something in your domain. Rather than having an identity key, its identity is based on the composition of the values of all of its properties. Because the property values define a value object, it should be immutable. In other words, you shouldn&rsquo;t be able to change any of the properties once you&rsquo;ve created one of these objects. Instead, you would simply create another instance with the new values. If you need to compare two value objects to determine if they are equal, you should do so by comparing all of the values. Value objects may have methods and behavior, but they should never have side effects. Any methods on the value objects should only compute things; they shouldn&rsquo;t change the state of the value object, since it&rsquo;s immutable, or the system. If a new value is needed, a new value object should be returned. Don&rsquo;t confuse the value object&rsquo;s pattern with C# and .NET support for value types and reference types. Custom value types in C# are defined with structs, while reference types are defined as classes. In DDD, both entities and value objects are typically defined as classes. Classes have advantages over structs when it comes to encapsulation and support for inheritance‑based extension and reuse.</p>
<p>Recognizing Commonly Used Value Objects
To help you better understand the basics of value objects, let&rsquo;s take a look at some value objects that you probably use all the time as a developer. The most commonly employed value object is a string. In .NET and many other languages, a string type is immutable, and you now know that immutability is one of the key attributes of a value object. A string is a collection of characters, and the combination of all those characters give that string meaning. For example, C‑A‑R in English, a car. If a string were mutable, we could change the R to T. Now the string is C‑A‑T, a cat, which has a very different meaning than a car. Or we could add a letter, maybe put an S in front of it, turning CAR to SCAR, also completely changing the meaning of car. But it&rsquo;s not just the array of characters that gives a string its meaning, the order of them is also critical. Just think of the word dog, d‑o‑g. Shifting its letters around gives us something with a very different meaning. ‑So one of the things that .NET makes it really easy to do is to modify strings, like you can change the length of it or make one all upper case. But when you call, for example, ToUpper on a string, it doesn&rsquo;t just change that string object, it gives you a new instance of a string that now has all uppercase characters. ‑Many developers say that monetary values in financial systems have been perfect candidates for value objects in their system. And Ward Cunningham provides us with a really helpful example, a company&rsquo;s worth. If a company is worth 50 million dollars, that means something, 50 million dollars. It&rsquo;s a very specific measurement. Fifty million on its own is not a measurement, it has no meaning without the unit, which in this case is dollars. But dollars alone doesn&rsquo;t describe worth either. In fact, dollars doesn&rsquo;t really help, does it, because is it US dollars or Canadian dollars, Australian dollars? It only makes sense when you put the two together as 50 million US dollars. There&rsquo;s actually one more factor to take into account, is the point in time of this 50 million dollars because of the way financial systems work and the fluidity of monetary values. ‑We could still just have the two properties in this Company class, but by creating a value object you also protect and constrain the measurement. For instance, we might have a class called Company. It might have one decimal property that represents the worth amount and another string property that represents the worth unit. The problem with this approach is that it doesn&rsquo;t tie these properties together in any way. These two properties appear to be independent of one another, but they&rsquo;re obviously closely related. If an update is made just to the Worth Unit string, it could obviously have a tremendous impact on the company&rsquo;s worth as a combination of these two concepts. Fifty million rupees has a very different worth than 50 million US dollars. To ensure nobody can set the unit without also specifying the amount, a separate value object can be introduced to represent the entire worth concept. This ensures the entire object must be updated as a whole. Since the worth type is immutable, the only way to make updates to the Worth property on the Company class is by replacing the whole instance with a new one, not just changing an isolated field. ‑A value object is not always for a measurement though. It can be another type of description. Eric Evans calls out dates as a great example for value objects. I&rsquo;ve used this one often, DateTimeRange, and it was perfect for the vet appointment scheduling app. We usually set a start and an end time together and can&rsquo;t really set one without the other. Also, we often need to pass the two values, start and end time, around from one method to another. So we&rsquo;ve encapsulated them in a value object called DateTimeRange. The properties have private setters, which makes the object immutable since we can&rsquo;t change them. We aren&rsquo;t showing the full logic of the class here, but when we look at the value objects in our application you&rsquo;ll see more of how we implement a value object in our software to ensure that it meets all of the attributes, not just immutability, but how we handle equality, comparison, and other logic.</p>
<p>Getting More Insight from Eric Evans and Vaughn Vernon
In his book, Implementing Domain‑Driven Design, Vaughn Vernon recommends that we should try to use value objects, instead of entities, wherever possible. He says, it may surprise you to learn that we should strive to model using value objects instead of entities wherever possible. Even when a domain concept must be modeled as an entity, the entity&rsquo;s design should be biased towards serving as a value container rather than a child entity container. What this means is that you&rsquo;ll find that your design will have a number of entities who have very little logic of their own or very few primitives as their properties, but instead will have a number of properties that each are themselves a value object. ‑So he&rsquo;s not saying everything should be value objects, but that it&rsquo;s probably our natural instinct to start by thinking of things as entities and then maybe once in a while go, oh, maybe that should be a value object. So what Vaughn is suggesting is really start by thinking every time should this be a value object and you will surprise yourself at how many times something that you originally might have thought of as an entity really does make a lot more sense as a value object. ‑Or sometimes when you&rsquo;re looking at an entity, there might be a couple of properties that seem to always go together, you might be able to bundle these properties into a single value object. It&rsquo;s interesting to note that identity values can be treated as value objects as well. In many systems, entities have a primitive type, usually int or GUID as their ID, but this means that it&rsquo;s easy to substitute a client ID for a patient ID if developers are not careful. By creating actual value objects for client ID and patient ID, which can still be stored as ints or GUIDs, it can eliminate this kind of error from our design. ‑Here is an example of a Client class that&rsquo;s inheriting from base entity, but specifying that the type will be ClientIdValueObject rather than a scalar type like int or GUID, that&rsquo;s followed by a service class that has a CreateAppointmentFor method which takes a clientId and a patientId. If those IDs were both GUIDs, the runtime code would allow you to accidentally pass them in in the wrong order because the signature is only constraining that you pass in two GUIDs and that could create a big problem when you&rsquo;re trying to build an appointment. But with the specialized value objects, you can tightly constrain the parameters to avoid this problem rather than adding a lot of extra logic elsewhere to protect you from making that mistake. For me, this highlights the beauty of DDD thinking. With this little bit of upfront work, you&rsquo;re removing the complexity of solving the kind of problem that could be created by accidentally transposing the client id and patient id. In our conversations with Eric Evans, we asked him for his thoughts on putting logic into value objects. He told us that he thinks value objects are a really good place to put methods and logic because we can do our reasoning without side effects and especially the complications that identity brings along, all those things that make logic tricky. We can put functions on those value objects and then do the pure reasoning right there in the value object. ‑Eric also called out date libraries as a good example of a value object. They perform common functions on dates so we don&rsquo;t have to keep coding them ourselves in our entities or services. For example, a date library could be used for calculating a person&rsquo;s age from their birth date. As long as the library causes no side effects to the date in question, it can work well as a value object.</p>
<p>Implementing Value Objects in Code
Our primary demo involves scheduling appointments. Appointments have a start and an end time. These two things always go together, so they make sense to extract as a value object. Here&rsquo;s a closer look at the DateTimeRange ValueObject we created for the course&rsquo;s demo. We also have a DateTimeOffsetRange, which is identical, but includes support for time zones. Because DateTimeRange is a pretty low‑level concept that could be useful in a number of different applications, it&rsquo;s implemented in the shared kernel package. The class inherits from a ValueObject base class that provides flexible equality checking behavior, so we don&rsquo;t need to clutter our class with overloads for Equals, GetHashCode, et cetera. It was written by fellow author and DDD expert, Vladimir Khorikov. ‑Because this is a ValueObject, you can see that all of its properties are read only. Recent versions of C# and Entity Framework Core do allow us to avoid even having a setter in there when we want to define read‑only properties, and we also now have the use of records in C#. EF Core can comprehend read‑only properties that don&rsquo;t have any setters at all, and it takes advantage of fields. But here we&rsquo;ve written our value objects in a more generalized way that&rsquo;s not taking advantage of any specific or specialized features. However, you can adapt these samples to benefit from those specific APIs and language versions that you&rsquo;re working with. The important goal here, though, however you implement it, is that the state of the value object should not be changed once it&rsquo;s been created and as part of the domain model. ‑Right. Value objects should get all of their state through their constructor, and any invariants that need to be checked should happen in a constructor as well. In this case, the date time range is guarding against having a start time that exceeds its end time. If it does, an exception will be thrown. The second constructor that takes a timespan calls the first one using constructor chaining, so in either case, the guard will always be enforced. Since the DateTimeRange is immutable and cannot be created in an invalid state, the rest of the domain model can count on it being valid. ‑Our DateTimeRange type does have some additional methods that let us create new DateTimeRange instances from existing ones, much like the DateTime type provides options to create new date times by adding time to an existing instance. In our type, for example, to change an appointment set to end at 10:30 instead of ending at 11:00, a new instance of DateTimeRange can be created using the newEnd method. Finally, the base ValueObject class requires overriding a GetEqualityComponents method. This is used when comparing two instances of the ValueObject, and it&rsquo;s up to you to decide which properties should or shouldn&rsquo;t be included. In the case of DateTimeRange, the start and end times are sufficient. If two DateTimeRange instances have the same start and end values, they should be considered equal. ‑Custom logic needed to determine whether one appointment overlaps with another is another area where the ValueObject can help. The whole appointment isn&rsquo;t needed to determine if there is an overlap in appointments. Only the DateTimeRange is used in such a calculation. Thus, the Overlaps method, shown here, has been moved out of the Schedule and Appointment classes and into the ValueObject, where it is more reusable, and it reduces the complexity and responsibilities of the other domain types. ‑We asked Eric to share his thoughts on moving logic out of entities into value objects. He agreed that it&rsquo;s a good idea. What he said was if there&rsquo;s logic that&rsquo;s really the classic software logic, I like to add that in value objects. You can really test value objects much easier than entities, and you can use them much more freely. So your entity becomes this critical piece of glue, an orchestrator among different value objects. But that doesn&rsquo;t mean that you won&rsquo;t have some logic in the entity. It&rsquo;ll just be very concise. ‑Eric also said that it&rsquo;s a nice way to work towards the ubiquitous language to the point where you look in the methods of the entity and you see higher‑level things. They read like use case level communication, rather than nitty gritty detail. My personal takeaway from this is to keep an eye on the properties of your entities, and specifically, their types. If you find that they&rsquo;re all primitive types, like ints and strings, think about if any of those primitive things could be grouped together as value objects instead. Another value object that we can point out here is the AnimalType. This is just to give you an idea that our value objects can be extremely simple. In this case, AnimalType is just a combination of the species and the breed of a particular pet or patient that we&rsquo;re dealing with at the vet clinic. And there&rsquo;s not a whole lot of other behavior here. But it does provide us with a container by encapsulating these two related properties together as a single value object.</p>
<p>Understanding Domain Services
When an operation is important to the model but doesn&rsquo;t necessarily belong on any one entity or value object, a service is often appropriate. But don&rsquo;t be too quick to give up on finding a natural home for the operation on an existing entity or value object or you may end up with a very procedural anemic model. Frequently, domain services serve as orchestrators for operations that require several different collaborating entities or value objects. Evans notes that good domain services must first and foremost not be a natural part of an existing entity or value object. Again, we don&rsquo;t want to shift all of our rich behavior from our entities and value objects to our services. Services should also have a defined interface that&rsquo;s comprised of domain model elements. And finally, domain services should be stateless, though they may have side effects. What this means is we should always be able to simply create a new instance of a service to perform an operation, rather than having to rely on any previous history that might have occurred within a particular service instance. But of course, the result of calling a method on a service might result in changes to the state of the system itself. These rules apply specifically to domain services which belong in the core of our application. Your software will likely also use services to perform work related to infrastructure or as part of the front end of the application. ‑Here are some examples of the kinds of services we might find in different layers of a DDD application. The UI layer represents the front end of the system and should have as little business logic as possible. It is frequently combined with the application layer, which should be concerned with behavior necessary for the application, but unrelated to the customer&rsquo;s problem domain. For example, the application may need to work with file formats or parse some XML, and it might have services for these purposes, but these are unrelated to the domain. In the core of the application where we store our core model and domain objects, we will define any domain services for operations that don&rsquo;t belong somewhere else. These services will frequently involve operations on multiple domain elements or may be responsible for orchestrating some kind of workflow. For instance, processing an order might involve a series of steps and multiple domain elements as the system checks inventory, verifies customer information, maybe charges a credit card, and then sends messages to ship the order, notify the customer, and reduce inventory. Finally, we have infrastructure‑level services. These will usually implement interfaces that are defined in the core of the domain, such as I send email. But since they require access to external dependencies, like file systems, databases, or network resources, they live in the infrastructure layer of the system. With respect to our domain, you may find infrastructure not very interesting, ‑although the people who create the internal workings of those services might find them quite fascinating. We&rsquo;ll look at implementing services in our application later on in the course.</p>
<p>Review and Resources
Let&rsquo;s review some of the important terms you learned in this module. You heard us talk about immutability, which is a really critical attribute for value objects. And immutability just means once an object has been instantiated, you can&rsquo;t change the value of any of its properties. ‑Another important term we learned about is the value object. A value object is an immutable class that is defined by the sum of the different properties that it has. We don&rsquo;t need an identity for a particular value object. In fact, a value object doesn&rsquo;t have any identity outside of the individual properties that it has. And in order for us to compare value objects, we simply compare all of its properties, and if they all match, then we can consider these two value objects to be equal. We also learned about domain services and these are interesting because domain services give you a place to put logic and behavior that you can&rsquo;t find a home for in the entities and value objects in your domain. ‑And the last term that we want to review is side effects. Side effects are changes that occur in your application or any kind of interaction with the outside world. Now, technically any change to the state of the application can be considered a side effect, but generally when we&rsquo;re talking about them, we&rsquo;re talking about things that changed other than the main intent of the operation that you&rsquo;re performing. For instance, it&rsquo;s often a good idea to keep operations that query information separate from those that change state, and if you follow this practice, then any queries that you make, that result in changes to state would be said to have side effects. That brings us to this module&rsquo;s key takeaways. Most of this module was focused on value objects, which are used in your domain model to measure quantify or describe something in the domain. Value objects typically don&rsquo;t exist alone, they&rsquo;re usually applied to an entity to describe something about it. ‑Value objects should be compared using only their values. They don&rsquo;t have an identity. Any two value objects that share the same values should be considered equal. And value objects in our domain should be designed to be immutable taking all of their needed values in their constructor and they shouldn&rsquo;t have any side effects. ‑We looked at a few examples of value objects in this module. We mentioned the .NET Framework string type that you&rsquo;ve no doubt used. Strings and datetimes are value objects that are available to any .NET application and can be used as a model for how you should design your own value objects. We also looked at a couple of custom value objects we used in our sample application, the datetime range and the animal type objects. ‑Finally, we wrapped up the module by introducing domain services, which are used to orchestrate operations between different parts of your domain model. Remember that domain services should generally only be used if you don&rsquo;t have an entity or value object where the behavior makes sense. Overuse of domain services can lead to an anemic domain model. In the next module, you&rsquo;ll learn how to build aggregates from entities and value objects while respecting their relationships. Here are some links and resources relevant to the topics of value objects and domain services that we discussed in this module. Thanks for watching Domain‑Driven Design Fundamentals.</p>
<p>Tackling Complexity with Aggregates
Introduction and Overview
Hello, this is Julie Lerman. ‑And this is Steve Smith. ‑Welcome back to Domain‑Driven Design Fundamentals. In this module, you&rsquo;ll learn more about aggregates and the associations between entities. ‑We&rsquo;ve talked about the domain model and the need to have effective communication in order to ensure the model is a useful representation of the customer&rsquo;s problem space. However, most problems that weren&rsquo;t using domain‑driven design can be quite complex. So now we&rsquo;re going to specifically look at some patterns and techniques that can be used to manage this complexity. ‑We&rsquo;ll cover several new terms along the way, including aggregates and aggregate roots. You&rsquo;ll learn about invariants and the aggregate roots&rsquo; responsibility for them. Aggregates often contain related data, so we will explore how to model relationships, often referred to as associations in DDD. ‑Then, we&rsquo;ll look at our application and see how thinking about the aggregate roots pattern helps us revise and simplify our model. ‑And finally, we&rsquo;ll walk through how we&rsquo;ve implemented this pattern in our code.</p>
<p>Tackling Data Complexity
Let&rsquo;s start by considering data complexity. If you&rsquo;ve ever worked on a relatively large or mature application, you&rsquo;ve probably seen some fairly complex data models. One way to reduce the complexity that we already talked about is using aggregates and aggregate roots, which you&rsquo;ve seen in the DDD mind map. Another is by limiting how many bidirectional relationships you have in that data model. ‑If your design doesn&rsquo;t have any clear notion of aggregates, the dependencies between your entities may grow out of control, resulting in a model like this one. And if your object model reflects a data model like this one, trying to populate all of the dependent objects of one object might result in trying to load the entire database into memory. And the same problem exists when it comes time to save changes. With a model like this, there&rsquo;s just no limit to which areas of the data model might be affected. ‑Even though in the real world at the highest levels of your system all of these things really do interrelate, we need to be able to separate them to keep the complexity of the system in check. ‑I&rsquo;ve gone into a lot of clients where their entity data model looks like this, and they&rsquo;re using this one big, huge single model throughout their entire system. So, one of the things that I work on with them is breaking this down and using the whole concept of bounded contexts to start looking at what makes sense for smaller models. ‑Yeah, a system that&rsquo;s designed like this is what we tend to call a big ball of mud because everything is just kind of slapped together, and it collapses under its own weight once it gets to a certain level of complexity. ‑Great. So, let&rsquo;s see how we can use aggregates to help solve the problem.</p>
<p>Introducing Aggregates and Aggregate Roots
Aggregates consist of one or more entities and value objects that change together. We need to treat them as a unit for data changes, and we need to consider the entire aggregate&rsquo;s consistency before we apply changes. In the examples shown here, the address is part of the customer and the component is quite literally a part of the product. We can treat a set of changes to a customer and their address as a single transaction. Every aggregate must have an aggregate root, which is the parent object of all members of the aggregate, and it&rsquo;s possible to have an aggregate that consists of just one object, in which case that object would still be the aggregate root. ‑In some cases, the aggregate may have rules that enforce data consistency that apply across multiple objects. For instance, maybe our product consists of a collection of components, but in order to be in a valid state, it needs to have a specific set of such components. As an example, if the product is a Lego minifig, the collection of parts won&rsquo;t be a valid product unless it includes a head, an upper torso, a lower torso, two arms, two hands, and two legs. If we allowed the collection of components to be modified independently of the product it was associated with, we could easily end up with consistency problems. If we want to modify the composition of a product, in this example, we should do so as a transaction, so that we start and end with a valid product. Data changes to the aggregate should follow ACID, that is they should be atomic, consistent, isolated, and durable. It&rsquo;s also the responsibility of the aggregate root to maintain its invariants, such as the number and type of components it requires in the example. An invariant is a condition that should always be true for the system to be in a consistent state. When considering whether particular objects should be treated as an aggregate root, you should think about whether deleting it should cascade, in other words, if you need to also delete the other objects in its aggregate hierarchy. If so, it&rsquo;s likely the object in question should be considered an aggregate root. ‑Another way to think about whether it makes sense to have an object as an aggregate root is to ask, does it make sense to have just this object detached from its parent? In the example shown here, if you&rsquo;re deleting the minifig, then you have to delete all of its parts. Conversely, if you have to delete a head, maybe it got broken, you don&rsquo;t need to delete the rest of the parts. Therefore it doesn&rsquo;t make sense for the head to be the root of this aggregate. ‑In the Domain‑Driven Design book, Eric Evans states this pretty simply, he says, an aggregate is a cluster of associated objects that we treat as a unit for the purpose of data changes.</p>
<p>Considering Associations in Aggregates
When considering aggregates, which, as Evan says is a cluster of associated objects, it&rsquo;s also important to think about relationships between those associated objects, especially those which exist within the aggregate. Before diving into how related entities participate in an aggregate, it&rsquo;s important to learn some important concepts that DDD brings to us when considering relationships among entities. ‑Many developers, myself included, tend to define relationships between classes in both directions. For example, an order has a line item and a line item has an order, a pet owner has pets and a pet has an owner. Many of us tend to think in bidirectional relationships by default. Because domain‑driven design aims for simplicity in the model, we start recognizing more quickly that the bidirectional relationships can often make things overly complex. For instance, I&rsquo;ve often found this to be true when it comes to adding in my persistence layer, and I happen to mostly use an ORM Entity Framework, which brings along its own behavior and assumptions about how relationships are managed. Sometimes the fact that my model includes navigation properties that may not be totally necessary can be the cause of some grief that&rsquo;s led me to take some time to consider if I really need that navigation or not. ‑Domain‑driven design guides you to default to one way, or unidirectional relationships. That&rsquo;s not to say that you shouldn&rsquo;t ever have bidirectional relationships, but that because of the extra complexity involved, you should spend some time considering if that complexity is justified. ‑A relationship, also known as an association, should be part of a type&rsquo;s definition, and we do that using properties that allow us to traverse from one end of the relationship to the other. In this example, we have a client type with a Patients property, and in a patient type, we have a Client property; not just an ID value, but a property that leads to a complete object or set of objects. If you introduce a bidirectional relationship, as shown in this code, using properties that let you traverse in both directions, you should only do so when neither object can be defined without the other. If that&rsquo;s not the case, then you need to be specific about the direction of the relationship, also called the traversal direction, to keep your model design simple. ‑Eric Evans puts it this way, &ldquo;A bidirectional association means that both objects can be understood only together. When application requirements do not call for traversal in both directions, adding a traversal direction reduces interdependence and simplifies the design.&rdquo; ‑So with a DDDI, we can look at our model and ask, can we define a client without identifying their pets? Can we define a pet without identifying the client who&rsquo;s responsible for them? ‑This may sound like a simple set of questions, but it could lead to a whole lot of debate. For example, why would a person be scheduling an appointment if they didn&rsquo;t have a pet? So in the context of scheduling appointments, a client doesn&rsquo;t make a whole lot of sense without one or more pets or patients. ‑Or from another perspective, a cat can&rsquo;t pay a bill or call to make an appointment, so how can we define a pet without a client? These are both pretty reasonable arguments, but neither one gets us anywhere. ‑So, let&rsquo;s start again with defaulting to a one‑way relationship. A client would need a patient to schedule an appointment. A client would not need a patient to pay a bill. ‑Okay, and if we started from the patient end, a patient doesn&rsquo;t schedule an appointment, so that becomes a moot point. Nor does a patient pay the bill. And, you know, because my dog doesn&rsquo;t have a credit card. He can&rsquo;t use the phone very well, either. So, when would you start with a patient and need to know something about the client responsible for that patient? That&rsquo;s an interesting question. So, in the context of scheduling an appointment, one could argue that we should define the traversal from client to patient and that we gain nothing by having a way to traverse from a patient back to a client. You may balk at that notion, but remember that all we care about right now is scheduling an appointment, not all the other possible scenarios where it might make sense to traverse from patient to client. ‑Sure. It&rsquo;s another example of YAGNI, you&rsquo;re not going to need it. In fact, we originally had owner as a property on patient in this context, but we realized it wasn&rsquo;t necessary, so we removed it. However, we kept the ID because we had some scenarios where it was useful. ‑So in the end, we chose to define relationships that traverse from appointment to doctor, patient, and client, and to define one that traverses from client to patients or their pets, but not the other way. ‑You may have experienced another type of bidirectional relationship problem if you&rsquo;ve seen related data gets serialized in your applications. When objects are serialized, the serializer typically traverses all of the object&rsquo;s properties recursively, If there is a bidirectional relationship, it can create a loop that will cause serialization to fail. You can think of saving aggregates in much the same way, and in fact, depending on how your persistence layer is implemented, serialization may actually be required as part of how your app persists its aggregates. In our aggregates, the single direction that we would use would go from the root to its dependents, and never the other way around.</p>
<p>Handling Relationships that Span Aggregates
Aggregates serve as boundaries between logical groupings within our application. We enforce these boundaries by prohibiting direct references to objects within an aggregate that aren&rsquo;t the root of the aggregate. Consider the customer with the address. It&rsquo;s perfectly okay for customer to reference address. Address might be an entity, or it might be a value object; it doesn&rsquo;t really matter in this scenario. What&rsquo;s important, though, is that the only way to get to the address in this aggregate is through the customer. We won&rsquo;t be referencing an address by some identity outside of this aggregate, but that&rsquo;s not the case for customer. Since the customer is the aggregate root, it can be referenced from other aggregates. ‑In this common example, an order might reference a customer. Depending on our context, it might make sense for a customer to reference an order. In this case, let&rsquo;s assume it only makes sense for the order to be central to the application&rsquo;s design. What&rsquo;s not okay is for the order to reference a customer&rsquo;s address directly. This violates the integrity of the customer aggregate. ‑Remember that aggregates and aggregate roots only apply to objects, not data. And when we&rsquo;re talking about references, we&rsquo;re talking about object references, properties that use an object directly. This is especially important with ORMs. For example, if you were to save an address that had a customer object attached to the customer property, there are scenarios in which Entity Framework would involve the customer in the database INSERT or UPDATE, possibly even a DELETE. And this behavior leads to a lot of confusion. I frequently advise developers to just remove the navigation property and use the foreign key ID instead. It&rsquo;s a little more work, but removing some of the ORM magic results in more control over the behavior. And this aligns perfectly with the fact that one common way to enforce aggregates is to replace direct navigation properties in the model&rsquo;s non‑root types with key references, and this reduces the number of dependency relationships within the model.</p>
<p>Evolving the Appointments Aggregate
Since we&rsquo;re dealing with appointment scheduling, our initial design might look something like this. An appointment involves bringing together a patient and a doctor in an exam room for a particular type of exam, and since we&rsquo;ll typically need to know the owner&rsquo;s information when we deal with the scheduling, it&rsquo;s important to have a reference to the client from the patient also. So if we model our system this way, any time we saved an appointment, it&rsquo;s going to scan all of these objects for changes and save them as well. So modeling it this way, the scope of our domain for appointment scheduling is much greater than it needs to be since, in our case, we don&rsquo;t expect to modify any of the other objects when we&rsquo;re creating an appointment. ‑Right, an appointment is basically just a list of resources tied to a particular timespan, it models who, what, when, and where, but it doesn&rsquo;t ever need to change any of these associated concepts. As a result, we can simplify our design by eliminating most of these object relationships from the appointment classes designed. Recall that for an object to be a good candidate for being an aggregate root, it should be the case that deleting an object should also delete the other objects within the aggregate. In the design shown here, if a customer cancels an appointment and we delete it from the system, it doesn&rsquo;t make sense that this should delete all of the associated objects. ‑So here is another perspective on that same model. By simply including the IDs of the related concepts rather than object references, we&rsquo;re able to ensure that creating and changing appointments has a minimal impact on our system when we persist the appointment. This relationship works because an appointment in the real world is really just a note that includes a place, time, and additional details. Adding and removing appointments shouldn&rsquo;t impact the people and places involved, and this revised design reflects this.</p>
<p>Using Invariants to Better Understand Our Aggregate
We do still have a bit more learning to do with this model though. Somewhere in our design, we need to enforce certain invariants about appointments like that they shouldn&rsquo;t be double booked. Our current thinking is that appointments need to include this rich behavior with regard to how they&rsquo;re scheduled. It&rsquo;s the aggregate roots responsibility to verify any invariance the aggregate may have, and in this case, the appointment is still acting as an aggregate root, even if we have eliminated the navigation properties to the other objects that it might be working with. Let&rsquo;s make sure we&rsquo;re clear on invariants and then we&rsquo;ll see how invariants in our application impact our design. An example of an invariant in the real world is the speed of light, which is a constant that you just can&rsquo;t break in terms of the physics of the universe as we know it. Some things in your system must be true in order for the model to be consistent or valid. Other examples of invariants might be that the total of the items on a purchase order do not exceed the PO amount, or that appointments do not overlap, or that an end date on an object must follow the begin date on that object. Sometimes an invariant only involves a single object, maybe a particular property or field such as name is required. In this case, we may model the system such that one can&rsquo;t even create the object without the required information. Our value objects are like this. For example, you can&rsquo;t create an instance of a datetime range object without defining both the start and end time. However, sometimes the invariants involved how multiple objects relate to one another. ‑In the example here, the purchase order and the individual line items would most likely be modeled as separate objects, however, the purchase order would be the aggregate root, and as such, it would be responsible for verifying this invariant. The individual line items on the purchase order probably don&rsquo;t know anything about one another nor should they, so it wouldn&rsquo;t make sense to put the responsibility for enforcing this invariant in the line item object. What about appointments? How does one appointment know whether it overlaps another?</p>
<p>Modeling Breakthroughs and Refactoring
As we focused on these invariants and where they belong in our design, it became clear to us that the appointment didn&rsquo;t really make sense as an aggregate root. If you apply this thinking to our appointment scheduling context, it follows that one appointment doesn&rsquo;t really know anything about other appointments, but the schedule knows about such things. Let&rsquo;s evolve our domain model to follow this pattern and see where that leads us. ‑This feels like a big change to the model, and these kind of epiphanies happen when you&rsquo;re working on the model. But that&rsquo;s not a bad thing. It&rsquo;s not like you&rsquo;ve wasted a lot of time focusing on appointment as an aggregate root. This is the beauty of modeling your domain, having conversations with different people, with the domain experts, because ideas like this bubble up, and suddenly, something big like this becomes clear. So, you&rsquo;re not going to get it 100% right the first time. Your understanding will evolve as you learn more about the domain. And from time to time, you&rsquo;ll realize there are big changes that can dramatically improve your design. In the Domain‑Driven Design book, Eric Evans talks about these breakthroughs in his section about refactoring toward deeper insight. This is really an important part of domain‑driven design, and about a quarter of the book is dedicated to it.</p>
<p>Recognizing Signs of a Misidentified Aggregate
Let&rsquo;s take a look at the signs that Steve and I eventually recognized in our domain, which led us to shift our appointment aggregate to a schedule aggregate. ‑Originally, our solution had the appointment as the central focus of the design. I had figured it would be its own aggregate with appointment at the root and its various properties as its children. As we&rsquo;ve just discussed, that doesn&rsquo;t really work as well as I&rsquo;d hoped, so now we&rsquo;re refactoring the design to introduce a new type, the schedule. Before we show that, though, let&rsquo;s review the original structure and some of the reasons it didn&rsquo;t work as well as an aggregate in our solution. ‑You can see the original structure had appointment in its own folder and marked with the IAggregateRoot interface, which is required for it to be accessible from our repository methods. It has essentially the same properties as the later version, except for ScheduleId, since there&rsquo;s no schedule type yet. And it has the same basic set of methods for modifying its room, doctor, time, and other properties. None of that really changed since all of those operations only had to deal with this single appointment instance. ‑However, when the appointment tried to enforce the invariant that appointments whose times overlap for the same pet should be marked as potentially conflicting, things were a bit messier. You see, this appointment doesn&rsquo;t actually have any association with any other appointments, so the only way to enforce this is to use a repository to get those other appointments for the same date as this one. Since entities don&rsquo;t support dependency injection through their constructor, this means an instance of the repository needs to be passed into this method. Creating this repository instance was the responsibility of the calling code, which may not otherwise have needed it. Note also that because the repository&rsquo;s interface is async, this method must now be async as well, even though no other methods on the appointment entity are async. ‑The real problem here, from a DDD perspective, is that cross‑aggregate invariants should not be enforced by any one aggregate. In the case of something like a unique constraint between all aggregates, you might need to use a domain service, or another approach. However, in other cases, the need to do this may indicate that you&rsquo;ve missed an important part of your model. ‑Right. In this case, the whole thing that the user is interacting with is the clinic schedule, but nothing in our original model referred to the schedule itself. Since some of our business rules, like what to do with appointments that conflict, only make sense at this higher level, it made sense to introduce a change to our model, the schedule aggregate.</p>
<p>Considering Schedule as Our New Aggregate
So, even though the initial design we had was about scheduling, the schedule itself was never part of our model. Once we include schedule as its own explicit object in our model, it makes the design much simpler. Appointments no longer need to know anything about other appointments. The responsibility for ensuring that appointments are not double booked and similar invariants can be performed by the schedule, which is the aggregate root. ‑So, let&rsquo;s see if this passes our other tests about defining aggregate roots. A schedule will certainly help us ensure that appointments don&rsquo;t overlap one another. When we save changes to a schedule, does it make sense to update any changed appointments? Yes, it does make sense. And if we were to delete an entire schedule, would it make sense to delete all of its appointments? Yeah, I think that would make sense also. ‑Yeah, I think this is the schedule for a particular clinic. At the moment, we only have one clinic, but if we imagine a scenario in which multiple clinics each have their own schedule, it wouldn&rsquo;t make sense to delete a clinic&rsquo;s schedule but then keep its appointments floating around. So I think that works. ‑Great. And if a schedule exists for each clinic, then it makes sense to persist the schedule, which means that it needs an ID, and therefore is truly an entity. And when we retrieve a schedule, we&rsquo;ll most likely be filtering which related appointments we want to look at, for example today&rsquo;s schedule or this week&rsquo;s schedule. That would mean we want all of today&rsquo;s or all of this week&rsquo;s appointments from a particular clinic&rsquo;s schedule. It really does make a lot more sense to me to tie the appointments to a schedule than directly to a clinic. Now, let&rsquo;s see how this effects our design.</p>
<p>Exploring the Schedule Aggregate in Our Application
Now I&rsquo;ll show you the new schedule aggregate implementation in our application. In the refactored solution, we&rsquo;ve renamed the folder so that now it&rsquo;s ScheduleAggregate. This folder only includes schedule and appointment, as well as related guards and specifications. In larger applications, it can help to organize your domain model by grouping everything related to a particular aggregate in its folder. Looking at the ScheduleAggregate&rsquo;s code, you can see that it inherits from our common BaseEntity type and uses a GUID for its id key, just like appointment. This lets us set the key ourselves, rather than relying on a database to do it for us. The class is also marked as an aggregate root with an interface. In the next module, you&rsquo;ll see how we use that to protect the integrity of our aggregates. ‑Right. We&rsquo;ll see how that works when we look at our repository and specification implementations. ‑Next, the Schedule&rsquo;s constructor just takes in its id, its dateRange, and its associated clinicId. In our sample, the clinicId is always hard‑coded but in a real application, there might be several clinics using the same software, and they would each have their own ids. The constructor is responsible for ensuring that the incoming values are valid so that it&rsquo;s always created in a consistent state. Schedule has just a few properties. There is the ClinicId, the associated set of appointments, and the DateRange. We&rsquo;re careful to only expose a read‑only IEnumerable of appointments because our aggregate must encapsulate its internal state. We don&rsquo;t want other parts of our application to add or delete appointments without going through the schedule&rsquo;s explicit methods designed for this purpose. Also, the date range isn&rsquo;t persisted since it can vary with any given instantiate ation of the schedule. ‑Yeah, and for performance reasons, you wouldn&rsquo;t really want to load the ScheduleAggregate with every appointment that had ever been made included in it. By using a property like this, we make it clear to the rest of the domain what set of dates this instance of the aggregate holds. The actual population of the appointments that match this range is left as a responsibility of the specification and repository classes that are used to retrieve the schedule from the database. ‑Yes. And the configuration of the aggregate&rsquo;s persistent details is done in the infrastructure project&rsquo;s Data Config folder. This is where every entity&rsquo;s EF Core‑specific mappings and configuration is performed, which keeps these details out of our domain model. You can see here that we&rsquo;re also letting EF Core know that we don&rsquo;t want the database to supply an id when we create a new schedule. We&rsquo;ve marked that property as ValueGeneratedNever. ‑Getting back to the schedule, let&rsquo;s have a look at its methods. The first method is for adding new appointments. Our design forces all new appointments to come through this method, so we don&rsquo;t have to have duplicate behavior anywhere else in the application to take care of whatever should happen when a new appointment is added. It&rsquo;s all right here in one place, easy to understand, and easy to test. The method validates the inputs to ensure we&rsquo;re not adding bad data to our aggregate, and then it adds the appointment. When a new appointment is added, the schedule is responsible for marking any appointments that might be conflicting. It&rsquo;s the right place for this behavior to live, since the schedule knows about all the appointments and knows anytime appointments are added or removed. After marking any conflicts, an appointmentScheduledEvent is added to the aggregate&rsquo;s event collection. We&rsquo;ll see how this works in the module on domain events. The DeleteAppointment method is similar. After deleting an appointment, the schedule needs to once more mark any appointments that might be conflicting. There&rsquo;s also a TODO comment here. These are left as exercises for you to learn more about how to work with the patterns introduced in this course. You&rsquo;ll find a number of TODO exercises scattered throughout the sample. ‑We hope you&rsquo;ll take some time to download the code, run it locally, and try implementing some of the TODO tasks using the existing functionality as a guide. There are a couple more in the MarkConflictingAppointments method, which, remember, was originally on the appointment type when we started out with that as its own aggregate. This method is responsible for detecting and marking appointments that might conflict. The basic rule, shown here, just checks whether the patient has two appointments that overlap. If any such appointments are found, they are updated to set their conflicting property to true. Then, the current appointment&rsquo;s property is set based on whether there are any other appointments that conflict with it. ‑This is an important part of the business logic for this application, and it&rsquo;s encapsulated right in our schedule aggregate. In a lot of data‑driven applications, this kind of logic might be in a stored procedure, or perhaps just implemented in the user interface. But in a domain‑driven application, we want these rules to be explicit and defined in our domain model. ‑The last method on schedule provides a hook for its appointments to use to notify it when changes are made to one of them. Because we don&rsquo;t have navigation properties from appointment back to schedule, we can&rsquo;t directly call methods on the aggregate root from appointment methods. There are a few different patterns we can use to accomplish this task. For this sample, we chose this one because it&rsquo;s simple and easy to follow. This handler simply calls MarkConflictingAppointments, but it&rsquo;s exposed as its own separate method because it could do other things as well, and we don&rsquo;t want to expose the internal behavior of the schedule to the rest of the app. To see how it&rsquo;s used, let&rsquo;s look at the appointment class&rsquo;s UpdateStartTime method. When the application needs to update the start time for an appointment, it will call this method. Because appointment is part of a scheduling aggregate, we know the app will already have loaded the schedule before calling this method. So the second parameter in the method asks for the handler on the schedule that will be called. The call to update the schedule is made after updating the TimeRange property on the appointment, so when mark conflicting appointments is called, it will use the new value for the time range. There are a lot of other ways you can set up this communication, using C# events, static domain events, or some kind of double dispatch approach. They all have trade‑offs, and when you need to do this in your apps, you should choose the one that works best for your app and your team. ‑Let&rsquo;s see the final result in the application. This change to our model of adding in a schedule aggregate made a big difference to how the domain model is organized. It gave us a much better place to put the logic of enforcing business rules around combinations of appointments and business logic that needs to run when appointments are added or removed. ‑Right. Without the schedule, we would have had to use a domain service or something to add behavior around the newly added or removed appointments. But with this design, we can go into the schedule, add a new appointment for Rosie, and then add another one, and you can see the notifications being triggered by the events, as well as the red outline representing the conflict in these two appointments. Not only is our domain model clean and easy to test, but even more important, it actually works! ‑And notice that as we move one of those conflicting appointments to another spot, the red alerts disappear. Good job, Steve! I am so grateful that you let me off the hook for working on the front‑end of this application. You know I&rsquo;m more of a back‑end developer.</p>
<p>Sharing Our Tips for Aggregate Design
So let&rsquo;s step back a moment and review some of the things we&rsquo;ve just learned about designing aggregates. First of all, aggregates exist to reduce complexity. You might not always need an aggregate. Don&rsquo;t add complexity just for the sake of using an aggregate. Another is that entities with an aggregate can only reference the root entity of another aggregate. ‑But you can always use foreign key values as a reference to entities inside another aggregate. It&rsquo;s perfectly okay to use this, and it will avoid the need for when you go to save that aggregate for it to cascade its persistence into other aggregates. If you find you&rsquo;re needing to use a lot of foreign key references to aggregate children often, you may need to reconsider the design of your aggregate in your domain model. ‑Another pointer was don&rsquo;t be afraid to have an aggregate of one, in other words, an aggregate that only has one object in it. ‑And finally, don&rsquo;t forget the rule of cascading deletes. Remember, one test for whether or not a particular object makes sense as an aggregate root is to consider whether deleting that object should also delete all of the other child objects in that object&rsquo;s hierarchy. If it doesn&rsquo;t, then you have probably chosen the wrong structure for your aggregate.</p>
<p>Review and Resources
Once again, we have covered quite a bit in this module. Let&rsquo;s review some of the terms that you learned in this video. The first thing we talked about was an aggregate. An aggregate is a group of related objects that work together in a transaction. The root becomes the entry point through which you do any work with the aggregate, and the root also is what&rsquo;s in charge of making sure that all of the rules that apply to that graph of objects are met. ‑Each of the rules that describes the state that the system must be in in order to be valid is called an invariant. Within our aggregates, we have objects that are related to one another. In DDD, we refer to these relationships as associations. If you use an ORM, you may hear the term navigation properties, which refers to those properties that reference the related objects in the model. And we talked about the importance of defaulting to one‑way relationships, which we also refer to as unidirectional relationships. ‑In addition to these important terms, Steve and I shared a lot of guidance around creating aggregates and roots in your domain models. Nobody wants to work with a big ball of mud. We use aggregates to organize our model. An aggregate is a set of related objects that live in a single transaction while encapsulating the rules and enforcing invariance of that transaction, making sure that the system is in a consistent state. When designing how related objects work together, your job will be easier with one‑way relationships. Use those as a default, and only introduce bidirectional navigation if you really need to. ‑And most importantly, don&rsquo;t resist updating your model as you and your team of domain experts learn more about the domain. Hopefully, most of this will happen early on, and then just once in a while you might have a big breakthrough, like we did when we realized that the schedule made more sense as an aggregate root than trying to have each appointment be its own aggregate. Up next, you&rsquo;ll learn about repositories which are a critical pattern in domain‑driven design. This is Steve Smith, ‑and I&rsquo;m Julie Lerman. Thanks for watching Domain‑Driven Design Fundamentals.</p>
<p>Working with Repositories
Introduction and Overview
‑Hello. I&rsquo;m Julie Lerman. ‑And this is Steve Smith. ‑In this module of Domain‑Driven Design Fundamentals, you&rsquo;ll learn about repositories, another critical pattern for Domain‑Driven Design. ‑We&rsquo;ll start by defining what repositories are, and then we&rsquo;ll provide some tips for working with them, as well as talking about some of their benefits. There are different ways to define repositories and plenty of debate around their use. We&rsquo;ll address some of these points. ‑Next, we&rsquo;ll introduce you to the specification pattern and how it can be really helpful when you&rsquo;re implementing repositories. Then we&rsquo;ll open up Visual Studio again and show you how we&rsquo;ve implemented some repositories in the scheduling app.</p>
<p>Introducing Repositories
‑Now, Julie, if this were an in‑person class, I&rsquo;d definitely ask for a show of hands who has heard of the repository design pattern. I would expect most hands to go up. ‑I hope so too. I think the repository pattern is by far the most popular element of DDD to be practiced outside of Domain‑Driven Design. They can be valuable in so many applications as a way to simplify data access and enforce separation of concerns. When I began learning about repositories and implementing them in my own software design, it had a huge impact on my application architecture. Along with automated testing practices, it really forced me to consider separation of concerns with each method and behavior added to my software. ‑Personally, I love the pattern, and I find it makes it much easier for me to write good, testable code. We&rsquo;re going to talk about using repositories within a DDD application, but if you want to learn more about the pattern itself, you can look in the design patterns library, and I know Julie also discusses using them with Entity Framework in her Entity Framework in the Enterprise course. ‑You can see the repositories are part of the DDD mind map, as they&rsquo;re used to access entities and aggregates. Any system that needs to persist between restarts has some kind of persistent storage for the state of the system, like a database. Many applications focus a great deal of effort on the mechanics of querying, fetching, and translating data to and from objects to the point where it distracts from the model that these objects are meant to represent. And having ad hoc access to the data source also promotes having developers query for any bit of data they want anytime they want, rather than using aggregates. This makes it pretty difficult to manage the consistency of aggregates by enforcing their invariants. At best, the logic for enforcing the integrity of the model becomes scattered among many queries, and at worst, it&rsquo;s not done at all. ‑Applying Model‑First design and separation of concerns means pushing persistence behavior into its own set of abstractions, which we refer to as repositories. Only certain objects, like specifically aggregate roots, should be available via global requests. Repositories provide this access, and through omission, prevent access to non‑aggregate objects, except through their aggregate roots. They give you the ability to constrain the data access, so you avoid lots of random data access code throughout your application. ‑When you think about the life cycle of an object in your application, you should consider two cases. In the first case, you have objects that are not persisted. These objects are created, perform some work, and then they&rsquo;re destroyed. In the second case, you have objects that are persisted. These objects have a slightly more involved lifecycle since after the object is created, it must be reconstituted with whatever state it had when it was last saved. Then it can perform whatever work the application needs it to do, after which it may need to save its state to some persistent storage before finally being destroyed. You can use repositories to manage the lifecycle of your persistent objects without the objects having to know anything about their persistence. We call these objects persistence ignorant because they&rsquo;re ignorant of how they&rsquo;re stored into and retrieve from a data store. ‑In his book, Domain‑Driven Design, Eric Evans speaks quite a bit about repositories. They can be summed up by saying that a repository represents all objects of a certain type as a conceptual set, like a collection with more elaborate querying capability.</p>
<p>Repository Benefits
‑Repositories can add a number of benefits to our application. First of all, they provide a common abstraction for all of our persistence concerns, which provides a means for clients to very simply obtain model objects and to manage their lifecycle. They also promote separation of concerns. The domain logic and the user interface can both vary independently from the data in the back‑end data source that is used by the application. ‑The public interface of a repository very clearly communicates our design decisions. Only certain objects should be accessed directly, so repositories provide and control this access. Another important benefit is that repositories make it easier to test our code. They reduce tight coupling to external resources like database, which would normally make unit testing difficult. Having a repository separate from client code and domain logic means that we can easily make improvements to optimize data access for this application, tuning for performance, adding caching behavior, etc. is all much easier and safer when the code for data access is all encapsulated in one or more well‑known classes. All of this makes your code easier to maintain.</p>
<p>Repository Tips
‑Here&rsquo;s some basic guidance you should keep in mind when designing repositories. First, a repository should have the illusion of a collection of a specific type of object. You&rsquo;ll be adding the objects to the collection, removing them, and retrieving objects from the collection, but that it is an illusion of a collection is important to keep in mind. When you interact with the repository, these are the types of methods you&rsquo;ll be calling, add, remove, and retrieve. Your calling code doesn&rsquo;t care how the repository performs those actions. So in the repository, you might have code that responds to a retrieve method, goes out to a database and gets data, but it could be getting data that&rsquo;s already in memory, or it might be grabbing data from a text file on your computer. ‑Another important recommendation for repositories is to set up access through a well‑known global interface. That way, developers that need to interact with the repository will be familiar with a common pattern for using it. ‑Here&rsquo;s a simple repository interface example. Depending on the size and complexity of your software, you may have a few layers of interfaces. ‑For example, if you anticipate having a number of repositories for a schedule aggregate used in different bounded contexts, you might want an IScheduleRepository interface that not only implements the lower‑level interface, but defines some other methods or properties that every schedule repository is required to have regardless of the bounded context it might reside in. Because a repository acts like a collection, you&rsquo;ll want methods to add and remove objects to encapsulate the underlying data insertion and deletion operations. We&rsquo;ve got these defined in our IRepository. It is up to each concrete implementation to define how add and remove will actually work. ‑It&rsquo;s not unusual to need to add specific query methods to individual repositories. Whether you need a custom subset of entities or a specific way to load entities&rsquo; relationships, custom methods are a simple way to achieve this. For example, if we wanted to fetch a schedule instance with all the appointments for a given day, we could add a method to the ScheduleRepository that might have an EF Core implementation like this one. ‑Likewise, if we just wanted to be able to fetch a client with their patients, we could add a method like this one, which will eager load the patients when it loads the client. Be careful with this approach though, as it can grow out of hand, and your repositories may end up with many different query methods. A simple way to address this is to use specifications instead, which we&rsquo;ll cover later in this module. In addition to these specific tips for implementing repositories, you should also keep in mind these more overarching tips. First, be sure to provide repositories only for aggregate roots that require direct access. And next, keep the clients focused on the model, while delegating all of the object storage and access concerns to the repositories.</p>
<p>Avoiding Repository Blunders
We&rsquo;re not always going to land on the happy path, so we do want to share with you some common problems that you might run into, how to recognize them, and most importantly, how to avoid them. ‑Remember your client code can be ignorant of the implementation of your repositories, ‑but developers cannot. ‑It&rsquo;s important that developers understand how your specific repository is implemented, otherwise, they can run into a number of different problems. ‑So we&rsquo;re talking about not just the developers who are implementing the repository, but also the developers who are using the repository. ‑One of the common repository problems the developers working with repositories often encounter is called an N+1 query error. This is where in order to display a list of rows from the database, you end up calling one query to get the list and then a number of queries equal to the count of that list to fetch each item individually. ‑Another one that I see a lot is when people are fetching related data. With Entity Framework, they&rsquo;re either using eager loading or lazy loading, and especially with lazy loading, there are a lot of developers who don&rsquo;t really know what to expect from it and just because it&rsquo;s easy and it just works, they use it and then run into all kinds of problems because of it. ‑And depending on how your data is structured, sometimes if you&rsquo;re trying to fetch just one or two properties that are represented in a particular column in a data table, you might end up fetching more data than required if you pull back the entire row which might include dozens of columns and a lot of actual data there. These are things that knowing how your underlying data is persisted and how your repository is implemented, how those things work, can make a huge difference in your application. ‑Most of these blunders impact how data is accessed in a data store and that means that one of the best tools you have for surfacing these problems is profiling your data store. Many of the IDEs we use for managing databases have profilers built in, some examples are SQL Server Profiler, Jetbrains DataGrip, and Azure Data Studio. Many of the APIs we use also have logging capabilities that can relate database activity. As a .NET developer, I often use the .NET Core logging API or some of the features built into Entity Framework Core, but most any language you use can do this and all of the cloud providers have ways to trace activity in their various data stores. There are even third‑party tools dedicated to database profiling. The suite of profilers from Hibernating Rhinos is a great example. They have profilers for RavenDB, Azure CosmosDB, and the EF Core, and Hibernate ORMs.</p>
<p>Addressing the Debates Around Using Repositories
Many developers have strong opinions about the use, and some might say overuse, of the repository design pattern. Let&rsquo;s consider some of the common arguments made about repositories. It&rsquo;s worth remembering that like Bjarne Stroustrup&rsquo;s famous quote about programming languages, there are two kinds of design patterns, too. It&rsquo;s no surprise, really, that as the repository pattern grew in popularity, that there would be many complaints about when and how to implement it. ‑Here&rsquo;s one that really gets me. EF Core, the .NET ORM which we&rsquo;re using this course, has a built‑in repository for its data access. It&rsquo;s called the DbContext. I&rsquo;ve heard and read comments from so many people who say never use a repository on top of EF Core because it already has a repository built in. And then I hear others who say you should always use a repository to interact with EF Core. I am not a fan of the words always and never. Maybe it&rsquo;s because I&rsquo;m a libra, who knows. So, these strongly held opinions really frustrate me. What Steve and I want to do here is give you the information you need so that you can make educated decisions about when to use repository and when to opt for something else. ‑Let&rsquo;s remember for a moment what repositories are and where they live in a domain‑driven application. Repositories are abstractions. They&rsquo;re part of your domain model. They define the persistence operations the model will use. That&rsquo;s it. There&rsquo;s nothing in the domain model patterns produced through model‑driven design espousing the use of Entity Framework, or NHibernate, or any other specific vendor tool for doing persistence. It doesn&rsquo;t even know if you&rsquo;re doing Java or .NET. It&rsquo;s meant to be totally abstract and just types. ‑The domain model should be persistence ignorant, and it shouldn&rsquo;t depend on implementation details. ‑Right. One of the things I really appreciate about DDD and the way it isolates domain expressions within a layered architecture is that it aligns perfectly with SOLID design principles, like the dependency inversion principle. ‑You are a big fan of SOLID, Steve. ‑Guilty! In this case, in terms of SOLID, using an abstraction for persistence enables us to follow dependency inversion because we can define an abstraction in our domain model and then implement it in another project that depends on the domain model. We can also write our application and its user interface so that it depends on our persistence abstraction, too, rather than on the implementation details. That&rsquo;s the heart of dependency inversion. ‑And that makes it easier to follow the interface segregation principle, which I also learned about from your SOLID course. This principle prefers smaller interfaces, so if your app is using a DbContext directly, that is not a small interface. Along with DbContext repository features, it exposes a lot of other functionality. Using an abstraction that limits what your app needs to do with regard to persistence makes for a much simpler design in our model, reducing complexity. ‑Right. In that way, it&rsquo;s similar to the facade pattern because it lets us work with a much simpler view of what could otherwise be a potentially very complex and powerful persistence library. ‑So, when we&rsquo;re following DDD, our domain model shouldn&rsquo;t know anything about EF Core, or whatever APIs you&rsquo;re using for your data persistence. If our model requires persistence, like most do, we should define abstractions in the model that describe what our needs are without specifying how they&rsquo;re done. ‑Exactly. The abstraction defines what needs done, the specific implementation is all about how to do it. ‑And one really popular and powerful way to do persistence in .NET is with Entity Framework Core. And because it implements methods that map pretty closely to most common persistence abstractions, it&rsquo;s usually pretty easy to implement a particular abstraction with a class that calls into EF Core. ‑Definitely. ‑EF Core works great for this in most of the apps I work on, but we should never couple it tightly to our domain model. ‑Exactly. The whole point of DDD is that we shouldn&rsquo;t be coupling our domain problems with our persistence problems.</p>
<p>Returning IQueryables: Pros and Cons
Another question I get all the time, and which I&rsquo;ve discussed in some of my other Entity Framework courses, is whether repositories should return IQueryable, and yes, I do have my opinions on that. ‑Yes, this is another source of some debate. On the face of it, it sounds like it would be a great idea. Your most basic repository abstraction might not provide much in the way of complex filtering options and you can avoid having to think about that sort of thing if you just return an IQueryable. ‑Right, because then any code that consumes an IQueryable can extend the expression adding additional filters or projections to the query before it&rsquo;s actually executed. On the surface, it sounds pretty good, right? ‑Well, it turns out that a lot of query logic is actually business logic, and if you return an IQueryable, it has two not‑so‑good effects. It can leak a lot of the implementation details so your application code&rsquo;s behavior changes significantly based on the implementation of the repository and it tends to put the business rules for querying all over the application. ‑Let&rsquo;s say we have an MVC application with a controller so that&rsquo;s the server‑side logic of the UI layer and it returns a view to the UI. The controller calls into a service to get its list of customers and the service contains a customer repository interface. That repository calls into an infrastructure project and the infrastructure project is where we&rsquo;re using EF Core and it&rsquo;s DBContext, but to limit what&rsquo;s exposed outside of the infrastructure project, there is a repository there as well. The repository and the service makes its calls to the repository in the infrastructure layer. It sounds like a lot of layers, but that&rsquo;s not a problem because we have reduced coupling and made a maintainable solution. The real problem here is where can we put our query logic in this example? ‑Well obviously the repository, and it wouldn&rsquo;t be unusual for the method in the service to further modify the query, but since it&rsquo;s also returning an IQueryable, the controller action could further modify that same expression tree, and assuming the controller just passes that same IQueryable to the view, which we&rsquo;ve both seen teams do, even the view could further refine the query. So is this a good thing or a bad thing? ‑Well on the plus side, we get a lot of flexibility without having to write a lot of code for our repository. We&rsquo;re also able to tailor the data we need to the specific place it&rsquo;s used and even modify the query from multiple steps in the app. At the same time, we get to reuse a simple repository interface everywhere in our app. ‑Right, but on the other hand, that query logic is now spread out everywhere. Every class that&rsquo;s adding query logic, in addition to whatever else it&rsquo;s doing, is now violating the single responsibility principle. Then there is separation of concerns. Query logic should be separate from other concerns in most of these classes. ‑And another problem I see a lot with this approach is confusion about when the actual query is executed and what runs on the database server versus in‑memory in the application. ‑Many developers will assume the query runs inside the repository and the result they get back is from the data store. And of course that&rsquo;s true for most calls, but not necessarily for those that return IQueryable. ‑Right, the query will execute the first time any code tries to enumerate the result. That could happen inside the repository, but it could also happen in the service, or in the controller, or even in the view. ‑Yeah, I see that a lot. a related issue is that developers at any step of this process can add additional logic that may compile just fine, but then at runtime when EF tries to interpret it, it blows up. ‑Anything you add to the query expression that Entity Framework doesn&rsquo;t know how to translate into SQL is likely to cause an exception, at least with recent versions of EF Core. ‑And it may be redundant at this point, but it&rsquo;s probably worth adding here that there is no encapsulation when you use this approach. ‑There is a way we can fix at least some of these issues though. For example, instead of returning IQueryable, we can still create flexible repository methods by passing in predicates. Then in the implementation, this predicate can be passed along to the DBContext as its Where expression providing the necessary filter. If you&rsquo;re not familiar with the term predicate, but you&rsquo;ve used the link where method, that&rsquo;s what the method takes as its parameter, which is why we&rsquo;re able to pass it right to the WHERE clause. ‑That does help part of the problem. Where before the query could have been executed at any of these points, at least now we know that whatever comes back from the repository will be the in‑memory result. The actual query is always executed in the repository itself. Of course, if the service takes in a predicate, it still means that any code anywhere in the system could be responsible for creating the query logic with the possible exception of the view if it&rsquo;s just being passed an IEnumerable at this point. ‑Okay, so with predicates, they&rsquo;re still very flexible, but they&rsquo;re not as easy to build up from multiple locations in your application, especially compared to IQueryable. The rest of the good points still hold though. ‑The only thing we&rsquo;ve really changed on the bad side is confusion about when the query actually executes. Being a fan of solid and encapsulation and knowing some other patterns we&rsquo;ll share later in this module, I&rsquo;m usually going to vote against this approach too. ‑Well another way we tend to solve this conundrum is going the custom query route. We even suggested this as a tip earlier, but you can definitely take it too far. Every little change to a query means another method, customer with orders, customers by shoe size, by shoe size, customers by favorite Netflix show. Hey, you never know what problems your domain experts are going to share with you. ‑The problem with this approach if it goes beyond one or two methods, is that you really start to feel the pain of the open/closed principle violation. Every time another custom query requirement comes in, you have to change the repository abstraction and all of its implementations, and the bigger the type gets, the more it violates the interface segregation principle, too. The more complex your problem is, the more query methods you&rsquo;ll be adding to your solution. This can surely be an untenable situation, and we will show you some better alternatives a little later in this module.</p>
<p>Considering Generic Repositories and Interfaces
Using generic interfaces for persistence is great from a code‑reuse point of view. With just one simple interface, any entity can be persisted using a standard set of operations. If you&rsquo;re using aggregates, you can use generic constraints in this simple marker interface to ensure that only aggregate roots can be persisted using your interface. It can work really well. ‑But there are trade‑offs. What if you have certain aggregates that should never be deleted, but your generic repository includes a delete method? Does it make sense to have operations defined in your domain model that should never be used? This is where you need to make a judgment call. Is the convenience of having a single consistent way of dealing with persistence throughout your model more valuable than having only the necessary and appropriate persistence operations exposed? There&rsquo;s no one right answer. Pick what makes sense for your app, your model, and your team. ‑In our demo, partially for the sake of simplicity, we are using a single generic repository for all of our operations, even though, yes, this means there are operations on some aggregates that are never called and some that never should be called, for example, deleting the entire schedule. ‑If we didn&rsquo;t go that route, our model would need to include separate repository interfaces for each of the aggregates in our model, including schedule, doctor, room, client, and appointment type. Each would define only the operations that were actually needed by the application. For a larger model, this could result in quite a few interfaces, and possibly implementations, but would provide a more pure representation of the domain model. ‑If you do choose to create a generic repository interface, that doesn&rsquo;t necessarily mean you&rsquo;ll implement it generically. You might only choose to create implementations for each aggregate root, which would comply with DDD recommendations. However, it can be convenient to create a generic Repository of T implementation class that you can then use with any entity. ‑This is what we&rsquo;re using in our sample, both for the front desk app and for the clinic management app. In both cases, if you review the sample, you&rsquo;ll see there&rsquo;s very little persistence‑specific code in either solution. ‑If you really like the code reuse you get from having a generic repository implementation, one way to keep it from allowing too much access to the internals of your aggregates would be to use a marker interface, perhaps one that simply extends the entity interface to identify your aggregate roots. Then you can update your generic repository to require this interface, rather than working with any entity. ‑At that point, code that uses the repository won&rsquo;t be able to instantiate the generic repository with non‑root entities, so we&rsquo;re able to use our repository to restrict access to non‑root entities from client‑server model. Using marker interfaces to identify aggregate roots is one way you can enforce your design decisions in your model using the compiler rather than relying on code reviews or other less effective practices. ‑Repository abstractions, especially generic ones, can sometimes get to be pretty large. Large interfaces violate the interface segregation principle, one of the solid principles that I cover in my Solid Principles for C# Developers course. One way to keep these interfaces smaller and more focused is to split them into read and write operations. This is related to the concept of Command Query Responsibility Segregation, or CQRS. Read operations are queries, write operations are commands. There are many benefits to leveraging CQRS that we don&rsquo;t have time to cover in this course, but one area where you may immediately benefit is with modifying behavior related to these kinds of operations. Queries often benefit from data caching, and it&rsquo;s very easy to add data caching to just the read operations. ‑Commands often benefit from being performed asynchronously using a queue, and having a separate interface for commands makes it easy to implement this behavior. These are just two ways you can quickly leverage splitting up your repository definitions between reads and writes. Of course, if you have a lot of different read methods, this can make it more and more difficult to implement custom caching logic, since every new method will also need to be added to the caching layer. Fortunately, this is easily solved by using the specification pattern.</p>
<p>Exploring Repositories in our Application
Steve is going to give you a guided tour of how data access and persistence are handled in the FrontDesk application using repository abstractions. Because he&rsquo;s been fine tuning versions of this demo application for many years, it&rsquo;s quite impressive, and he truly is the best guide for walking you through this implementation. ‑We&rsquo;ll start from the front end of the application, which is our Blazor client. Let&rsquo;s take a look at editing an appointment. Here&rsquo;s an appointment for Julie&rsquo;s dog, Samson. You can see that on the edit screen, in addition to showing the details for the appointment, it also provides us with a list of the doctors and appointment types. When we hit the drop‑down list, we can see all of the different doctors who are available that we could schedule to work with this particular appointment. That&rsquo;s actually accomplished through a back end API that&rsquo;s coming from a different project. Let&rsquo;s take a look at that. We&rsquo;ll start by examining the API using our Swagger endpoint. Looking at Swagger for DoctorEndpoints, you can see that there are two endpoints, one to get a specific doctor by ID and another one that returns a list of doctors. We just saw the list of doctors in action. Let&rsquo;s go ahead and run it again from Swagger. Here you can see the resulting set of three doctors, just like we saw in the drop‑down list. You&rsquo;ll find the code for this particular endpoint inside the FrontDesk.Api project. Within there, there&rsquo;s an Endpoints folder with subfolders for each of the different types of entities that we expose API endpoints for. Inside of Doctor, you can see there&rsquo;s a GetById and a List, and we&rsquo;re looking at the List endpoint here. When we define an endpoint, we simply inherit from BaseAsyncEndpoint, and specify the request type, if any, and the response type, if any. We can also do dependency injection through the constructor, just as you would with a controller. Each endpoint has a single Handle or HandleAsync method, and this is where the actual work of the endpoint is done. You can see in this example that we are simply awaiting on the repository&rsquo;s ListAsync method in order to get our list of doctors. Once we have the list, we map it to our DTO that we&rsquo;re going to actually return, and pass that back as part of that response type. The response, as we just saw in Swagger, includes the Doctors as JSON, as well as a Count property that includes the total number of those doctors. Now let&rsquo;s look a little bit more closely at that repository. You can see in the dependency injection that&rsquo;s occurring in the constructor that we&rsquo;re depending on an IReadRepository<Doctor>, but where is that defined? For that, we need to look at our SharedKernel project. Inside the separate SharedKernel project, which FrontDesk references as a NuGet package, you can see that we have defined an IReadRepository<T> interface. This inherits from IReadRepositoryBase<T>, which is actually itself defined in another NuGet package, the Ardalis.Specification type. The reason why we&rsquo;re creating our own interface here is so that we have complete control over it and we can add additional behavior. For example, in this case we&rsquo;re adding a generic constraint. We&rsquo;ve said that this particular interface will only work with types that have the IAggregateRoot interface attached to them or applied to them. Looking at that particular interface, you can see that there&rsquo;s nothing to it. It&rsquo;s simply a marker. It&rsquo;s a way that we tell the compiler that our intent for a particular class or entity is that it should be treated as an aggregate root. We use that marker to enforce our design and our encapsulation to make it so that we don&rsquo;t accidentally just load up a child entity out of an aggregate, when instead we&rsquo;ve made a design choice that we want to work with that entire aggregate as a unit. You can see that we&rsquo;ve also implemented IRepository<T> similarly. It also inherits from a type that comes from Ardalis.Specification, and also has the same IAggregateRoot restriction. Now let&rsquo;s return to our FrontDesk application and see how we implement this. First, we should look at the DefaultInfrastructureModule. This is an artifact module that defines how we&rsquo;re going to wire up our abstractions with their implementations. And here you can see all the important bits of how we wire up EfRepository to IRepository, as well as IReadRepository. But notice for the IReadRepository we&rsquo;re actually wiring up a different type, a CachedRepository. This acts as a decorator around the underlying EfRepository, and will provide additional caching logic. Inside of the CachedRepository, when we asked for a list of doctors, it actually checked the cache first, and then if it wasn&rsquo;t in the cache, it would go and fetch the result from the EfRepository, which in turn would make the request to the database. We can see in this example here that the logging is showing us that we&rsquo;re actually hitting CachedRepository, and some of the times we&rsquo;re fetching the source data and other times were fetching the data from the cache. The actual EfRepository that is also defined inside of FrontDesk.Infrastructure is shown here, and once more, you can see that there&rsquo;s not much to it. Most of the behavior we&rsquo;re simply inheriting from the EfRepository that exists in the Ardalis.Specification package. It&rsquo;s called RepositoryBase<T>. However, when we inherited it, we were able to add additional constraints, and so you&rsquo;ll see here as well that we specify that this only works with IAggregateRoot. You can see the definition of the RepositoryBase<T> in the Ardalis.Specification NuGet package, which is available on GitHub. The details of it are shown here. The ListAsync method simply delegates to dbContext.Set of the appropriate T type, and then calls its ToListAsync, passing along a cancellationToken if one was provided. Now the last piece of the puzzle is our own AppDbContext. Inside our AppDbContext, we define the DB sets that we&rsquo;re working with and we also pass in some additional configuration. One thing to notice and take away from this example is how many places in our solution we have to reference AppDbContext or EntityFramework. It&rsquo;s almost nowhere in the entire code base. The only place that we talk about it at all is inside of AppDbContext, EfRepository, and some related folders such as Configuration and Migrations. Everywhere else, and especially in our domain model, we&rsquo;re completely persistence ignorant, relying only on abstractions that we&rsquo;ve defined.</p>
<p>Introducing the Specification Pattern
Eric Evans introduces the specification pattern in the original book on domain‑driven design. Although it&rsquo;s covered in Evans&rsquo;s DDD blue book, the specification pattern isn&rsquo;t listed in the book&rsquo;s mind map, and honestly, it doesn&rsquo;t get the attention it deserves. Factories are in the book&rsquo;s mind map, but specifications aren&rsquo;t? Even though in my experience they play a much larger role in producing a clean domain model design. ‑In the book, Evans says that specifications mesh smoothly with repositories, which are the building‑block mechanisms for providing query access to domain objects and encapsulating the interface to the database. It&rsquo;s this powerful combination of specification and repository patterns that truly result in a clean, extensible, and testable design. Let&rsquo;s dig a little more into the specification pattern and how it integrates with repositories before we show you how we&rsquo;ve implemented it in the front desk application. ‑Specifications are used to specify the state of an object, and as such, are primarily used in three ways, validation, selection and querying, and creation for a specific purpose. In our app, we are primarily leveraging specifications in our queries. Create explicit predicate‑like value objects for specialized purposes. A specification is a predicate that determines if an object satisfies some criteria, according to Eric Evans. The most basic specification simply provides a method typically named IsSatisfiedBy, which accepts some object and returns a Boolean. These methods perform their logic in memory, and unfortunately, in remote data querying scenarios, this approach would require every row to be transferred to the application before the specification logic could be run against it. ‑However, more sophisticated specifications can be used in conjunction with ORMs like Entity Framework Core to encapsulate the details of a query while still allowing EF Core to translate the query into SQL that executes on the database server. Our sample application uses such a specification in the form of a NuGet package, ardalis.specification, which is maintained by, guess who, Steve Smith. ‑Recall that one of the benefits of using the repository pattern and abstraction was that it prevented query logic from being spread throughout the application. This was also the reason for not returning IQueryable from repository methods. The same logic can be applied to repositories that accept arbitrary predicates since, again, that means the complexity of these predicates would need to live in the code calling the repository, which might be in the user interface for example. Using repository interfaces that accept specifications instead of custom predicates addresses this problem very elegantly. ‑What about the issue we learned about earlier in this module where generic repositories weren&rsquo;t suited to aggregates with custom query needs? So, individually typed repository interfaces were required, and each additional custom query needed to be added to this new specific interface. Well, specifications solves that problem too. Generic methods accepting generic specifications allows for custom queries where needed for any given aggregate. ‑A few more benefits of specifications. They&rsquo;re named classes that live in your domain model. You can easily unit test them in isolation, or if necessary, integration test them with a test database. They&rsquo;re highly reusable. They keep persistence logic out of your domain and your user interface. They keep business logic out of your database and persistence layer. They help your entities and aggregates follow the single responsibility principle by keeping complex filtering or validation logic out of them. You can easily create your own specification interface and implementation. Feel free to look at the source for ardalis.specification on GitHub and take just the bits you find useful. Or, you can reference that package and leverage all of its features and just start adding the specifications that your domain needs. It&rsquo;s up to you. Either way, you will need to write the specifications themselves. These belong in your domain model. When you don&rsquo;t have many of them, you might just put them in a root specifications folder. However, as your model grows, if you&rsquo;re using aggregates, it may make sense to have each aggregate include in its own folder the specifications that go with it. This makes them easy to locate as they grow in number. ‑Each specification class is a value object, so it should be immutable. Generally, they do all of their work in their constructor. Any variable part of the specification should be supplied as a constructor argument. And once constructed, the specification needs to be supplied to your query implementation. You can use specifications directly with EF Core or you can use a repository abstraction that supports them. In either case, pass the specification to the query object and it will be used to build the query, which is then executed and results are returned. The resulting code for most queries turns into one line to create the specification and another line to execute the query by passing the specification to a repository or a DbContext method. Note that our sample is built on top of a repository abstraction that&rsquo;s provided with the ArdalisSpecification package, and so it&rsquo;s fully compatible with its specification types. We&rsquo;ll look at the code more in the next section. ‑Here&rsquo;s an updated mind map that I have created which shows how specifications work with repositories to define the queries for aggregates and entities. If you&rsquo;ve been using repositories without specifications and have experienced any of the pain points we&rsquo;ve described in this module, try refactoring to use specifications and I&rsquo;ll bet you&rsquo;ll be surprised what a positive difference it makes.</p>
<p>Using Specifications with Repositories in Our App
Now it&rsquo;s time to see just how specifications are implemented in the sample app. While the application code does lean on Steve&rsquo;s specification API, there is still plenty to see. Most of what you&rsquo;ll see here is the application&rsquo;s code, but occasionally you&rsquo;ll also see some of the code that&rsquo;s in the Ardalis.Specification API. Once again, Steve is going to walk you through this demo, and he&rsquo;ll do so from the perspective of how the app retrieves data, starting with the front‑end. ‑When we first load the schedule page in the FrontDesk app, it loads our Blazor WebAssembly application, which then makes some API calls to fetch the appointments and related data. One of those calls is shown here. It&rsquo;s used to get the list of appointments for the schedule. Looking at Swagger, we can see there are a bunch of appointment endpoints. Our API is designed to serve the needs of the client app. Its endpoints won&rsquo;t necessarily match up with how our domain model is constructed, so it&rsquo;s perfectly fine to have an endpoint for appointments, even though appointment is not an aggregate root. It just means we need to pass in the aggregate root ID as part of the request so that we can get the schedule that owns the appointments. If we test the list AppointmentsEndpoint, we can pass in the same schedule ID that Blazor was using, and we get back a list of appointments as expected, and these are, in fact, the same appointments that are being used in the front end. Looking at the source code for this endpoint, you can see that, again, it&rsquo;s in the API project in the Endpoints folder in an Appointment folder, and within that, we&rsquo;re looking at the List endpoint. Now, when we pass in the request, we&rsquo;re specifying a ScheduleId, and if that ScheduleId is missing or empty, then we&rsquo;re going to return NotFound from this API. Otherwise, it uses the ScheduleByIdWithAppointmentSpec to encapsulate the query that it&rsquo;s going to use. On the page in question, we only want the appointments for one day. It&rsquo;s worth noting that this specification does not perform any filtering by date; it returns all appointments for this schedule. We&rsquo;ve left a to do task here for you to implement this behavior by creating a new specification. Now, the specification that we&rsquo;re using here is passed to the repository method, GetBySpecAsync. We&rsquo;ll look at that in a moment. For now, let&rsquo;s take a look at this specification. All of the schedule specifications are in the ScheduleAggregate folder in the Core project. The ScheduleByIdWithAppointmentSpec is pretty simple and has just three details worth pointing out. First, it has a WHERE clause, making sure it only matches schedules that have a matching ID. Second, it eager loads it&rsquo;s associated appointments by using it .Include statement. And third, it implements another marker interface, ISingleResultSpecification. This interface is used to mark specifications that are expected to only return a single result. It is required when passing a specification to a repository method that only returns a single instance of a type rather than a collection or enumerable. Considering that this is being called from a List endpoint on the API, this may seem strange, but remember, we are only loading a single schedule aggregate, and it is then just the container for the set of appointments that the endpoint is going to return. The method the endpoint is calling, GetBySpecAsync, is defined in Ardalis.Specification, as shown here. Note that it has a generic constraint requiring any specification passed to it to have that ISingleResultSpecification marker interface. The sample code is calling this first method, which just works with one entity type and then returns it. If you need to use projection, though, you can use the second method, which operates on your entity type, but returns a different type using a .select. You can use this to optimize queries to return only needed properties. Remember that specifications are useful to define the expected shape of returned data in a query. This doesn&rsquo;t just mean filtering the number of rows using a WHERE clause, but also determining which associations should be brought back with the query, and even which columns should be included. Let&rsquo;s see an example of that. Returning to the specifications for the schedule, there&rsquo;s another one called ScheduleForClinicAndDateWithAppointmentsSpec. One of the newer features in EF Core is &ldquo;filtered includes,&rdquo; and so by adding an include filter, we can make sure that this schedule, which is being used with a particular ClinicId, will only load in its appointments where they are for a given date that gets passed into the specification. You can use this specification, by the way, as an example when you complete that to do task that we just saw in the list endpoint. Compare this code to how we solve this problem in the previous version of this course using custom SQL queries and a custom ScheduleRepository. The specification has replaced all of that with a single specification class containing all the query logic, and the calling code simply needs to create the specification and then pass it to the repository. Unlike custom LINQ expressions that might be anywhere in our application, specifications are easily tested in isolation. In the IntegrationTests project, you&rsquo;ll see several different tests that demonstrate the various schedule specifications and ensures they work as expected. These tests use a real database, since .include logic can&rsquo;t be tested with an in‑memory collection. For the last specification that we looked at, which only includes the appointments for a given date, you&rsquo;ll see that there&rsquo;s an integration test that adds a number of appointments on different dates and then uses a repository to fetch back a schedule using the ScheduleForClinicAndDateWithAppointmentsSpec and a specific date, and it verifies that we only get back the appointments for that date and not the appointments that are on different dates, which verify the behavior of many of the abstractions and implementations in our domain model.</p>
<p>Review and Resources
Once again, let&rsquo;s begin a review with some of the important terms you learned in this module. First, and most importantly, the focus of the module, repositories, which encapsulate the data persistence logic, add, update, delete, and retrieve. In the case of domain‑driven design, we use repositories to focus on aggregate roots. Key to building flexible repositories is the specification pattern, which guides you to encapsulate business rules in a way that they can be passed around and acted upon in other methods, classes or APIs. You learned about persistence ignorance, which describes objects being ignorant about how they are persisted into data storage. It&rsquo;s another critical aspect of domain‑driven design. Steve and I also talked about ACID, an acronym to describe transactions as being atomic, consistent, isolated, and durable. Another acronym we talked about is SOLID, which is a collection of software design patterns. ‑After introducing you to repositories and how they fit into the DDD mind map, you learned about their benefits and some tips for designing them. ‑We also addressed some of the debates around repositories, not only if you should even use them, but how to use them, for example, whether or not to return IQueryables. Many of these debates exist because of the complexity of balancing clean repositories with repositories that help you achieve the variations of queries required by your domain. ‑We introduced you to an often overlooked pattern, the specification, that plays a critical role in solving this problem with DDD. Remember that you are not on your own building specifications. You can lean on the NuGet packages that I created or just dig into my GitHub repo to pick and choose what you want to adopt. Links are coming up. ‑Steve gave you a great tour of how repositories are implemented in the FrontDesk application and then more deeply to see how these repositories are using specifications to provide the rich querying needed in the application. ‑Here are a number of links to not only my GitHub repo and NuGet packages, but a number of other resources we referenced, as well as some additional ones that we think you&rsquo;ll find useful. ‑In the next module, you&rsquo;ll learn about two more critical pieces of the DDD mind map, domain events and anti‑corruption layers, both which help provide some data pathways between the various parts of your software. Thanks again for watching Domain‑Driven Design Fundamentals. I&rsquo;m Julie Lerman, ‑and I&rsquo;m Steve Smith. Thanks for watching.</p>
<p>Adding in Domain Events and Anti-corruption Layers
Introduction and Overview
Hi, this is Steve Smith. ‑And this is Julie Lerman. ‑In this module of Domain‑Driven Design Fundamentals, you will learn about domain events and anti‑corruption layers, two patterns for decoupling how the domain model communicates internally and with other systems. ‑We&rsquo;ll start with domain events, which can be used to separate concerns, allowing different areas of the application to evolve independently, and sometimes helping with scalability as well. You&rsquo;ll learn how to identify domain events in your system, and how to design domain event classes. Then we&rsquo;ll show you domain events being used in a simple application, so you can get a feel for the structure and the workflow. ‑Then, you&rsquo;ll get to see the domain events we built in our sample application, which are a bit more realistic. After this, we&rsquo;ll turn our attention to another important element of domain modeling, anti‑corruption layers, which can be used as translators between bounded contexts and Legacy APIs.</p>
<p>Introducing Domain Events
Domain events are a critical part of a bounded context. They provide a way to describe important activities or state changes that occur in the system. Then, other parts of the domain can respond to these events in a loosely coupled manner. ‑In this way, the objects that are raising the events don&rsquo;t need to worry about the behavior that needs to occur when the event happens. And likewise, the event handling objects don&rsquo;t need to know where the event came from. This is similar to how repositories allow us to encapsulate all of our data access codes, so the rest of the domain doesn&rsquo;t need to know about it. ‑We can also use events to communicate outside of our domain, which we&rsquo;ll look at in just a moment. Another thing that&rsquo;s worth remembering is that domain events are encapsulated as objects. This may be different from how you&rsquo;re used to coding events. It certainly was different for me when I first started learning about them. For example, in a user interface, events are more commonly written as some form of a delegate in another class, but here they&rsquo;re first class members of the domain model. ‑Right. Although you can implement domain events using techniques, like the event keyword in C#, the domain events themselves should be full‑fledged classes. In fact, all of these parts of domain‑driven design are defined as objects in our domain model. ‑Vaughn Vernon describes domain events simply, saying we should use a domain event to capture an occurrence of something that happened in the domain. The domain events should be part of our ubiquitous language. The customer or domain expert should understand what you&rsquo;re talking about when you say when an appointment is confirmed, an appointment confirmed event is raised. ‑You may already be familiar with the idea of events from working with user interfaces. ‑Many user interface clients, like .NET Windows Forms, Electron, or web pages, like the one shown here, make heavy use of events and event handlers. In this example, there&rsquo;s a single page with a single button, and in the markup, you can see there&rsquo;s an onclick attribute in the button that leads to a little JavaScript method defining what the app should do in response to a user clicking the button. ‑Events are helpful because they let us avoid a lot of conditional logic. Instead, we can write code that signals a certain thing has happened, and we can have other code in our system listen for these signals and take action accordingly. So in this kind of code, you don&rsquo;t have a separate class for an onclick event, and it may take some getting used to that now in our model, we&rsquo;re going to create a whole class to represent an event. Domain events offer the same advantages to our model as the events in the user interface. Rather than having to include all of the behavior that might need to occur whenever the state of one of our objects changes, instead, we can raise an event. Then, we could write separate code to deal with the event, keeping the design of our model simple, and helping to ensure that each of our classes has only one responsibility. Essentially, a domain event is a message, a record about something that occurred in the past, which may be of interest to other parts of our application, or even other applications entirely.</p>
<p>Identifying Domain Events in Our System
‑Be especially attentive to these kinds of phrases when discussing the application with your domain experts. When this happens, then something else should happen. If that happens, notify the user when, or inform the user if, these types of phrases frequently refer to situations that are important to the domain expert, the system, or the user. It might therefore be worth modeling these types of things as domain events. You may also discover behavior in the application that will benefit from being treated as domain events that may be the domain expert isn&rsquo;t initially aware of. ‑Remember that domain events represents something that happened. Since we can&rsquo;t generally alter history, this means they should be immutable. It&rsquo;s a good idea to name the event using terms from the bounded context&rsquo;s ubiquitous language describing clearly what occurred. If they&rsquo;re fired as part of a command on a domain object, be sure to use the command name. Here&rsquo;s some examples. ‑Depending on the application, it might be important to have events to represent when a user has authenticated, when an appointment has been confirmed, or when a payment has been received. Be sure to only create events as you need them in your model. You should follow the YAGNI principle, that&rsquo;s you ain&rsquo;t gonna need it. In other words, don&rsquo;t create domain events unless you have some behavior that needs to occur when the event takes place, and you want to decouple the behavior from its trigger. You really only need to do this when the behavior doesn&rsquo;t belong in the class that&rsquo;s triggering it.</p>
<p>Designing Domain Events
Here&rsquo;s some more things to keep in mind when you&rsquo;re creating domain events. We&rsquo;ve already mentioned that domain events are objects, but to be more specific, each domain event should be its own class. It&rsquo;s also usually a good idea to note when the event took place since frequently the code that&rsquo;s handling the event might run some time after the event occurred. It can be helpful to create an interface or a base class that defines the common requirements of your domain events. For example, capturing the date and time the event occurred. ‑Also, when you&rsquo;re designing your event, you need to think about the event‑specific details you want to capture. If it&rsquo;s related to an entity, you might want to include the current state of the entity in the events definition. Think about what information you would need to trigger the event again. This can provide you with the set of information that is important to this event. Similarly, you may need to know the identities of any aggregates involved in the event, even if you don&rsquo;t include the entire aggregate itself. This will allow event handlers to pull the information back from the system that they might require when they&rsquo;re handling the event. Ideally, domain event objects should be lightweight, so you want to be sure you capture sufficient information to handle the event, but not so much that the event object itself becomes bloated. Since the main events are immutable, they&rsquo;re typically fully instantiated via their constructors. And since they&rsquo;re simply noting that something has happened in the system, they don&rsquo;t usually have any behavior or side effects of their own.</p>
<p>Applying Domain Events to a Simple App
We&rsquo;ve put together a simple console application that we&rsquo;re going to use to demonstrate the value that domain events can have in your application. The idea behind this is to strip things down to as small a level as possible. Then, we&rsquo;ll also show how domain events are playing a real role in a more real‑world way when we get to our veterinary scheduling application. This is a .NET console application with dependency injection. The main program just loads the needed services and runs the app. The app has a simple run method, which goes through the following steps. We can step through it with the debugger, so you can see the output in real time. The app loads services and starts running. It shows what happens when an appointment is created using a service. The service calls a factory method that creates the appointment. After instantiating the appointment, the factory method sends an email, which you can imagine includes code like what is in the comments here. Then, it similarly sends a notification to the user interface, again, with code like what&rsquo;s in the comments before finally returning to the service. The service, then saves the new appointment in the database. Then, the app creates a different appointment and saves it directly using a repository instead of a service. And once more, the notifications and the save occur in the same order. Finally, the appointment is confirmed, which triggers some UI notification, and then that change, too, is saved. The main thing to take away from this example so far is that the Appointment class has a lot of concerns. The act of creating an appointment, especially, involves a lot of code that could fail. It&rsquo;s also worth noting that notifications and emails are going out before the state of the entity is saved. So if something goes wrong, users will have been told the operation was successful, and people may have been notified via email when, in fact, the update itself might never go through. ‑The reason we&rsquo;re showing the behavior both from a service and with the appointment directly is because our domains should be designed to work either way. Earlier in this course when you learned about domain services, we explained that forcing all operations on your domain to go through a set of services tends to lead to an anemic domain. Ideally, your aggregates and entities should behave correctly, whether they&rsquo;re being used directly or through a set of services. One way we can improve this design would be to move the responsibilities of actually sending emails or updating the UI to help our methods or other services. Then, we could call them from appointment.create instead of having all the code in here. This would make for less code inside of Appointment. ‑That would definitely be better, but it would still mean that appointment would need to be updated every time a new requirement came along. There&rsquo;s a principle we can use to avoid that, though, called the Hollywood principle. ‑I love the name of this principle. Its name comes from an old saying from Hollywood agents, don&rsquo;t call us, we&rsquo;ll call you. ‑Exactly. Applied to software, the principle is closely related to dependency inversion from solid. Instead of forcing appointment.create to have to know about and call every possible thing that might be involved in the appointment creation workflow, instead, it can just let the app know something happened and let the app respond by calling handlers. ‑Instead of putting all the logic into this method, potentially making it huge and complicated and really hard to read, we move that logic into handlers, and the app calls the handlers. We don&rsquo;t call the handlers, the app calls us. And beyond just reducing the amount of code and responsibility inside Appointment, this approach also lets us make sure that notifications to the user don&rsquo;t occur until persistence is successful. And it still keeps the model&rsquo;s behavior consistent without requiring a service to perform any of the work. Let&rsquo;s see how it works. ‑Domain events is a pretty simple pattern, but you do need to have some plumbing code to support it. You also need to think about whether you want your events to fire before or after persistence. In many cases, what you really want is postpersistence events for the reasons we mentioned above. You want to make sure your persistance succeeds before you send any notifications outside of your app. Also, although occasionally I&rsquo;ve used them for validation in the past, ideally, your domain events and handlers should never fail. That is, don&rsquo;t build your behavior around exceptions that might be thrown from event handlers. Use a different pattern if you need that type of behavior. ‑In this simple demo, which mirrors how our sample app works, we just need a collection of events on each entity. We&rsquo;re creating simplistic types to represent domain events and the respective handlers. You can implement the logic to find and call handlers whenever an event is dispatched in a number of ways. For this sample, we&rsquo;re using the MediatR NuGet package created by Jimmy Bogard. Steve mentioned that you&rsquo;ll need some plumbing to start, and that plumbing is the interfaces or base classes, if you prefer, for handler and domain event classes. In our example, we&rsquo;re using interfaces. Here&rsquo;s the IDomainEvent interface and the IHandle interface. ‑Once you&rsquo;ve set up your event and handler interfaces or base types, it&rsquo;s time to create some events and their associated handlers. ‑For this scenario, there are two things happening, an appointment is scheduled or created and an appointment is confirmed. An event is something that already happened. So we name our events in the past tense, and we have AppointmentCreated and AppointmentConfirmed. The event classes are pretty simple and just include the instance that triggered them, so handlers have access to any properties they might need from it. Once the events have been defined, you just take each individual responsibility out of the original method and create a separate handler for it. It&rsquo;s fine to have multiple handlers for the same event. Ideally, your design shouldn&rsquo;t depend on the order in which the handlers execute. But if it does, you can think about adding a sequence to your handler interface and ensuring they&rsquo;re called in sequence order. ‑The last thing you need to do is register or record the events on the entity. In this sample, that just means adding them to the list of events that are on that entity. The actual implementation for dispatching the events is done in the repository after the save is successful. And in our veterinary sample, this work is done in the DbContext SaveChanges method. ‑Let&rsquo;s step through the code again now that it&rsquo;s using domain events. ‑The app starts up as before. We enter the appointment.create method. ‑And look how much smaller that method is now. ‑Definitely. It&rsquo;s way easier to see what&rsquo;s going on here. Now the domain event is added to the collection, but notice that when we step over this, nothing actually happens yet. ‑Right, it&rsquo;s just holding it until after the entity is persisted. ‑Which is now. Notice that we&rsquo;re in the repository Save method. And for every event that we have stored on this entity, we&rsquo;re using MediatR to publish it at this point in time. ‑This is still in process on the same thread. There&rsquo;s no out‑of‑process queue or anything involved here. ‑Right, there&rsquo;s nothing to install using this pattern except for MediatR, and that just runs in‑memory. And, of course, you could wire this up with your own code that simply loops over your set of events and then dispatches out to your handlers. There&rsquo;s nothing that says you have to use MediatR. Notice in the output that the DATABASE Saved occurred, and then the UI and email notifications. ‑As expected, we only triggered side effects outside our domain after persisting. Now let&rsquo;s see the version that uses the repository directly and doesn&rsquo;t bother going through the service. ‑We basically see the same behavior, DATABASE Saved, UI, EMAIL. ‑All that&rsquo;s left now is the confirm and save, which should look similar, entity saved, and then the UI is updated. ‑That&rsquo;s basically it. I created a small GitHub repo, which has just this sample in it. It&rsquo;s at github.com/ardalis/DomainEventsConsole. There&rsquo;s a branch there showing how things work without events. Of course, you can also download it from the course details. ‑If you want to start your solution with all of this plumbing already in place, you can use Steve&rsquo;s CleanArchitecture solution template, which is also on GitHub. He is one productive guy. Everything shown here is already in place in the template, which is designed for you to use as a starting point for your app.</p>
<p>Exploring Domain Events in Our Application
Now let&rsquo;s look at how we&rsquo;re leveraging domain events in the veterinary FrontDesk scheduling app that we&rsquo;ve been working with. Again, we&rsquo;ll start by showing you the code, and then we&rsquo;ll debug through it so you can see it in action. ‑In our Appointment class, we&rsquo;re going to record a domain event when certain changes are made to the appointment. So, if we scroll down and take a look at the UpdateRoom method, you&rsquo;ll see that it creates and saves an appointmentUpdatedEvent. The same is true for the other update methods like UpdateDoctor, UpdateStartTime, etc. They each will create an appointmentUpdatedEvent and pass it the current instance of the appointment, and then this is saved into the entity&rsquo;s Events collection. ‑In the case of the Confirm method, it&rsquo;s similar, but it creates a different event, an appointmentConfirmedEvent. Essentially, the appointment entity can trigger two kinds of events directly, change and confirmed. And you&rsquo;ll notice it only does so if an actual change takes place. Calling an update that doesn&rsquo;t change the current value will not trigger a new event. ‑Let&rsquo;s take a look at the appointmentUpdatedEvent, and this is similar to the one we saw in the simpler console app in the previous demo. It inherits from BaseDomainEvent, which is defined in our shared kernel, and it adds a UTC timestamp property called DateOccurred that is set when the event is created. This can be useful for debugging purposes. The only other property the class takes is the appointment itself. The AppointmentConfirmedEvent, shown here, is similar. ‑Notice that these domain events are all defined in the core project with our domain model. For this sample, they&rsquo;re in an Events folder in the root. However, in a large application with many events, it might make more sense to put them with the aggregate that they correspond to. In this case, the ScheduleAggregate. There&rsquo;s one more domain event in our sample, which is the AppointmentScheduled event. It&rsquo;s similar in structure to the others, but it&rsquo;s actually created elsewhere. ‑Once you start working in event‑driven applications, it can be a bit more difficult to follow the flow of execution in the app where events are concerned. It really just takes some getting used to, and then you&rsquo;ll find it to be second nature. The best way to see where events are raised and where they are handled is by looking at an individual event and examining its references. Looking at AppointmentScheduled, you can see that it is handled in the API project and in the core project. It is only created inside of the ScheduleAggregate itself. Let&rsquo;s have a look at where that happens. ‑In Schedule, the AddNewAppointment method creates and saves the AppointmentScheduled event after adding the appointment to its collection and marking whether or not it&rsquo;s conflicting. Once the schedule is saved, any appointments that have had domain events added to their respective collections will have them dispatched after the save to persistence is complete. ‑Before we step through the code, let&rsquo;s have a look at one of the AppointmentScheduledEvent handlers. The thing to notice is that these handlers don&rsquo;t get created or called anywhere in our code. That&rsquo;s that Hollywood agent again from the Hollywood principle saying, don&rsquo;t call us, we&rsquo;ll call you. The event dispatching logic, in this case, using MediatR, is what calls these handlers at runtime. But at compile time, nothing references them directly. ‑Now let&rsquo;s see the flow of domain events in our application when we change an appointment. We&rsquo;ll modify this appointment for my little baby, Sampson, and change the appointment from a wellness exam to a diagnostic exam. But a diagnostic exam takes more time, and this will automatically change the duration of the visit, which should trigger a conflict with one of Sampson&rsquo;s other appointments. Yes, he likes to go to the vet quite a lot. ‑The change initially hits the AppointmentUpdate endpoint. It loads the schedule and the appropriate appointment and calls its Update methods. In this case, the only one that has a change is the change to the appointment type. This intern adds an appointmentUpdatedEvent. Once the change is saved, the event is dispatched. The API project also has a handler, AppointmentUpdateHandler, that responds to this event by sending a message to the Blazor client using a SignalR hub. This will trigger a real‑time notification in the app. ‑What about communication between bounded context or apps using events? Applications and microservices frequently use events to communicate, too, but these aren&rsquo;t domain events since they extend beyond a single domain. They&rsquo;re frequently called integration events, and they may be defined as part of your domain or in a separate project or package. For simplicity, ours are here in this IntegrationEvents folder. ‑The FrontDesk has just two integration events, the AppointmentConfirmLinkClickedIntegrationEvent is published by another app and consumed by this one, and AppointmentScheduledIntegrationEvent is an event this app publishes and another app consumes. It&rsquo;s important that the structure of the published and consumed types match, which is why frequently a shared package is used to define these kinds of events. ‑We don&rsquo;t have time to dive deeply into distributed application architecture, but one thing you need to remember when designing integration events is that they typically will be enriched and denormalized when compared to a similar domain event. For instance, the AppointmentScheduled domain event just has a reference to appointment, and that only has IDs for the client, patient, and doctor. However, the integration event includes many more details like client name and email, patient name, and doctor name. The reason for this is to ensure that consumers of the event have enough information from the event to perform whatever actions they need to without having to immediately call back to the publishing app to ask it for more details. You can imagine that the performance of a system would suffer if every time an appointment event was published, one or possibly many apps that were consuming that event, turned around and immediately had to make calls to this app&rsquo;s API asking for client details, patient details, and doctor details. Hence, we have a handler that is responsible for taking in a domain event and enriching it with the additional details shown here on the integration event. We&rsquo;ll put these integration events to use in the next module.</p>
<p>Introducing Anti-Corruption Layers
The last topic we want to discuss in this module is anti‑corruption layers. An anti‑corruption layer, as the name implies, helps to prevent corruption in your domain model. ‑Right, just like superheroes help to fight corruption, these layers provide a sense of security to your model when it needs to interact with other systems or bounded contexts. ‑Returning to our mind map, you can see that the anti‑corruption layer is used to translate and insulate as part of a context map, mapping between a bounded context and foreign systems. ‑When your system needs to communicate with other systems, especially legacy applications that weren&rsquo;t written or modeled as well as your current system, you need to be careful not to let assumptions and design decisions from that system bleed into your model. For instance, if the other system&rsquo;s model includes a customer, even if that customer refers to the same actual business customer, it&rsquo;s likely that it will be modeled differently than a customer in your system. It&rsquo;s best to have a layer that can translate to and from other systems&rsquo; models. In DDD, this is the job of an anti‑corruption layer. ‑Right, like we mentioned in the beginning of the course, even other bounded contexts in your own system may be different enough to merit having an anti‑corruption layer in place to protect the two distinct models from one another. And, of course, legacy applications frequently use very different models from newer systems. An anti‑corruption layer isn&rsquo;t a design pattern, however, it&rsquo;s usually comprised of several design patterns. The job of the layer is simply to translate between the foreign system&rsquo;s model and your own. ‑In addition to translating the objects themselves, the anti‑corruption layer can also clean up the way in which you must communicate with the other system. It may provide a façade to simplify the API or an adapter to make the foreign system behave in a way that is known to your system. You can learn more about these design patterns in the Design Patterns Library on Pluralsight. ‑We&rsquo;re usually most concerned with having an anti‑corruption layer in place when communicating with legacy systems. Eric Evans notes why that&rsquo;s important. ‑Even when the other system is well designed, it is not based on the same model as the client, and often the other system is not well designed. ‑Since this is a fundamentals course, we&rsquo;re not going to dig deeply into anti‑corruption layers, because they can be fairly complex, as well as very customized to each scenario, but here&rsquo;s an example structure of one which comes from Eric Evans&rsquo; book, showing how an anti‑corruption layer can connect your beautiful system on the left with a not so beautiful system on the right. ‑I really like this diagram. I think Eric had some fun putting it together. ‑Gee, what gives you that impression, Steve? ‑Of course, in the middle you can see how the anti‑corruption layer is using a façade and some adapters, but on the right it&rsquo;s protecting us from a big complicated interface, some messy classes, and some things we just don&rsquo;t even want to know about. ‑Right, and of course, your own system is comprised of an elegant class, a very expressive class, and of course even more good stuff, and maybe even some stuff we should be refactoring as well. ‑There&rsquo;s no one way to create an anti‑corruption layer. Whatever you need in order to insulate your system from the systems it works with is what you should put inside of this layer, which should allow you to simplify how you interact with other systems, ensure that their domain decisions do not bleed into your design, and ensure any necessary translation is done along the way.</p>
<p>Review and Resources
We&rsquo;ve covered some new topics in this module, and there&rsquo;s a few new terms that we want to make sure we review. Domain events are a type of object that actually represents something that occurred within the domain that other parts of the system may find interesting and want to tie their behavior to. And this is a great way to keep your system decoupled and to keep your individual objects simpler because they don&rsquo;t have to know about all of the behavior that might occur when some event takes place. We also referred to the Hollywood principle, which can be summed up as don&rsquo;t call us, we&rsquo;ll call you. This principle is related to the dependency inversion principle from SOLID and is frequently used to decouple systems from one another. Instead of us putting all the logic we need in our code, we architect the system so that it calls back to us at the appropriate time. And we put our code into handlers that the app calls, rather than directly coupling our model to these actions. ‑And finally, we looked at anti‑corruption layers, which can be used to ensure that our model that we worked so hard to produce doesn&rsquo;t become polluted by the models of other systems we work with based on objects they wanted to return to us or the type of API that they want us to code to. So we put anti‑corruption layers in place to shield our model from those other systems or bounded contexts that we might work with from our bounded context. ‑In this module, we introduced domain events, and hopefully, you have a good idea of what they are at this point. ‑We&rsquo;ve talked about how you can identify opportunities to use domain events based on the kinds of requirements your customers give you, as well as when you see code in your model that&rsquo;s doing too much and could be more loosely coupled. ‑We gave you some tips for designing and naming domain events, and then we showed them in action, both in a relatively simple console app, as well as in our much larger veterinary clinic sample application. ‑Finally, we introduced the concept of anti‑corruption layers, which use a variety of design patterns to insulate our model from the design choices of other applications or bounded contexts. Here are a number of resources where you can learn more about domain events and anti‑corruption layers. Some of these, including a few Pluralsight courses, we mentioned in this module, but there are others that we find to be relevant, even if we didn&rsquo;t explicitly mention them. ‑Up next, we&rsquo;re going to wrap up this course by adding a new feature to the application. Because of our clean architecture and well‑designed domain model, it&rsquo;s going to be pretty easy to integrate into our existing app. I&rsquo;m Steve Smith, ‑and I&rsquo;m Julie Lerman, and thanks for watching this module of our Domain‑Driven Design Fundamentals course.</p>
<p>Evolving the Application Easily Thanks to DDD
Introduction and Overview
Hello, this is Julie Lerman, ‑and this is Steve Smith. In this module, we&rsquo;re going to wrap up our course on Domain‑Driven Design Fundamentals by showing how we can reap the benefits of our design when it&rsquo;s time to add additional functionality to the system. ‑In this module, we&rsquo;ll first review our current system design and see how it incorporates DDD patterns and practices. Then, we&rsquo;ll circle back to our customer, Michelle, to see how the new vet clinic appointment management system is working out. ‑During that quick conversation, we&rsquo;ll learn about a new feature, and we&rsquo;ll show how we can implement that feature. ‑We&rsquo;ll leverage message queues to implement this feature, so we&rsquo;ll definitely be sure to share with you some of the basics about message queues before we show you that code. ‑The main benefit of our design choices is the ease with which the system can be extended and maintained in the future. And we hope you&rsquo;ll agree that adding to the current design is quite straightforward.</p>
<p>Reviewing Our Current System Design
So far, our system is pretty simple, though it&rsquo;s fairly complex, as most course demo apps go. ‑The system is currently two different web applications, although the user interface makes it look like a single app. Our main focus has been the application used by clinic employees to schedule appointments. There&rsquo;s a lot of complexity with scheduling, so this benefited from domain‑driven design. There&rsquo;s also a clinic management application that&rsquo;s used to do simpler data‑in/data‑out tasks like record keeping and maintaining information about doctors, clients, patients, and more. Let&rsquo;s review the scheduling app a little more closely. ‑We have a single aggregate for a schedule, which contains a number of appointments. We limit access to the schedule through the schedule repository class, which is responsible for retrieving and storing the schedule in our database. We&rsquo;ve identified a couple of value objects that allow us to better model concepts in the domain, and we&rsquo;re making use of domain events to allow our domain in other parts of our system to respond to changes in the state of our model. ‑It&rsquo;s taken us a while to get to this point, but now that we&rsquo;re here, the design of the system is very clean, and it reflects the customers domain, as well as we&rsquo;ve been able to model it so far, of course, given some time constraints. ‑Yes, we do have to ship the app, I mean, this course, at some point. ‑Right, of course, as we build on this application, our model would continue to evolve. But we&rsquo;ve shown you techniques you can use to ensure that you can grow the application without being overwhelmed by the complexity you&rsquo;re trying to model. ‑Actually, as it turns out, the customer does have one more request for us. She said something about customers forgetting their appointments. Let&rsquo;s have another quick conversation.</p>
<p>Addressing a New Feature with the Domain Expert
As it turns out, the customer does have one more request for us. She said something about customers forgetting their appointments. Let&rsquo;s have another quick conversation. ‑Hey, Michelle, great to see you. How are things going with the new scheduling application? ‑It&rsquo;s been fantastic. We&rsquo;re really able to see very easily who scheduled each day, and book new appointments, and move things around is needed, and the front desk folks really appreciate that it highlights the appointments that are conflicting or unconfirmed. That makes it much easier for them. But one thing that&rsquo;s still a problem is the fact that sometimes our clients forget their appointments. It probably happens at least a couple of times every day, and our staff really don&rsquo;t have the time to call every client to make sure they remember ahead of time. ‑So, you&rsquo;d like the system to call them then? ‑Well, we understand there&rsquo;s services that&rsquo;ll do that sort of thing and we might move to that eventually, but for now, if we could just send an email that would probably help remind clients to put it in their calendar. ‑Oh, okay, so, do you want an email to go out when they schedule the appointment or on the day before they&rsquo;re scheduled to come in, or maybe even both? ‑Oh wow, if we could do both, that would be great, one to let them know when they&rsquo;ve booked so that they know that we&rsquo;ve got it in our schedule and another one to remind them that they have an appointment the next day, just in case they forgot. ‑That shouldn&rsquo;t be too hard. Our model already handles certain events that occur, like when appointments are scheduled, and appointments already support being marked as confirmed too. ‑Sure, and I think all we&rsquo;ll really need to build that&rsquo;ll be new is some kind of service for sending the emails and some way for clients to click a link in the email so they can confirm the appointment. Since it&rsquo;s email, it shouldn&rsquo;t be a problem to send these out the day before, even if that day isn&rsquo;t a week day or a work day, right? ‑No, I think that should be fine. It shouldn&rsquo;t hurt anything to send an email on a Sunday or a holiday, and of course, we&rsquo;ll ask our clients to opt into these reminders so we&rsquo;re not sending anything unsolicited. ‑Sounds good. We&rsquo;ll get started, and should have something for you to review real soon.</p>
<p>Planning Our Implementation Steps
Before we get into the gory details of the implementation, we just want to make sure that you understand the very high level of what we&rsquo;re doing here. The first thing is triggered when the appointment is scheduled. And in response to that, our system will send a confirmation email to a client. ‑Once the client gets that confirmation email, they can click a link to confirm that they&rsquo;re going to make it to the appointment, and the system will then mark that appointment as confirmed so that on the schedule, the staff will see that it&rsquo;s got a green box around it, and they should expect the client will actually show up. ‑What&rsquo;s nice about this implementation is that it benefits so much from a lot of the infrastructure we already have in place. And thanks to our DDD‑based architecture, it&rsquo;s just as easy to add in a few extra features that we need to make this work. ‑So as we go through this, you&rsquo;ll see us using some existing and some new domain events, some application events, a number of event handlers and services. One new tool you&rsquo;ll see is something we haven&rsquo;t talked about yet, messaging queues to communicate between separate applications. The application we&rsquo;ve been working with will need to communicate with a public website that the customers will interact with when they confirm their appointment.</p>
<p>Introducing Message Queues
Before we go any further, we did just mention something new, which is message queues. And we just want to talk about that a little bit. It&rsquo;s a pretty advanced topic for this fundamentals course, so we&rsquo;re going to talk about it at pretty much a high level. ‑Message queues are nice to use between applications for a number of reasons. They can help decouple them and make it so that one of the applications can just drop off something into a message queue and continue on with its work and not have to worry about what happens to the message after that. ‑Right, or if whichever application or applications it&rsquo;s trying to communicate with, it doesn&rsquo;t need to worry if that application is available and listening at that very moment. The message can sit in the queue and when the other application is ready to grab it, it does. With a message queue, we&rsquo;re really just dealing with a single message. One application drops it, and the other one takes it, and then the message is gone. ‑Yeah, and there&rsquo;s lots of different implementations of message queues that you can find online. Some of them are free. Most of the cloud services that are out there now have these types of things built in as well. ‑And what we&rsquo;re doing here is dealing with a single message at a time in something of a silo app since we control both applications that are communicating with each other. But sometimes you need to have a lot more flexibility than that, you might actually have a number of applications that are interested in that message and you may not even know in advance or control those applications. So this is when something called a service bus comes into play. ‑Right, so you&rsquo;ll frequently hear about something called an enterprise service bus. And there&rsquo;s, again, a number of examples of these that you can find available. It usually sits on top of message queues and other features. And one of the responsibilities it has is making sure that messages get delivered to the different applications that care about that message. ‑It might even be an application that didn&rsquo;t even exist or you didn&rsquo;t know about when you were first setting up the message queue. So even at that point, because service bus allows you to decouple the routing of the message, it&rsquo;s possible to go ahead and hook up other applications to listen to the queue. ‑Right, so you&rsquo;ll see in our scenario that we have our scheduling application raising an event that an appointment was created. And it might be that maybe in the future we would want to add some other application that wants to react to that event. ‑We could publish it to social media, hey, I&rsquo;m going to go see the vet. ‑Exactly. If we had a service bus, we could simply wire up in our service bus for this new social media notifier service, pick up that event. But with just message queues, as you&rsquo;ll see in our implementation, we would have to change our scheduler application to know about this new app and write to its queue because we don&rsquo;t have any advanced routing, everything&rsquo;s hardcoded in our simple scenario. The message queue we are using is RabbitMQ. It&rsquo;s a mature, open‑source message broker that you can get set up and running with zero install by using a prebuilt Docker container. It has a lot of capabilities, but we&rsquo;re keeping it simple and just using it to define a few specific queues, which are separate bounded contexts we&rsquo;ll use to publish and consume events.</p>
<p>Sending a Message to the Queue
Now let&rsquo;s take a look at how we&rsquo;re adding message queues into our solution. The first part of the process happens when the appointment is scheduled. And you&rsquo;ve already seen our AddNewAppointment method inside the schedule aggregate root. And you saw how the domain uses domain events and domain services to notify the user interface if there&rsquo;s a conflict in the schedule. In the previous module, we showed you MediatR, which we&rsquo;re using to publish these domain events. And we also talked about integration events, which are structured to be shared between different applications. So what we&rsquo;re going to do in our system is add RabbitMQ into the mix at the same point where MediatR is publishing the domain events. But we&rsquo;ll ask RabbitMQ to publish our integration events. These events will be formatted as JSON data before they&rsquo;re inserted into the queue. So let&rsquo;s see what this looks like in the application. We&rsquo;ll be looking at the code that makes all of this work a little further on in this module. We&rsquo;ll go ahead and create a new appointment. Let&rsquo;s bring Sampson in to see Dr. Jones again. So there&rsquo;s the appointment. Nothing has changed from the perspective of the user. RabbitMQ includes a user interface to inspect the queues, and in the Front Desk app the menu has a link so that you can open up this admin page and see what&rsquo;s going on with the queues that are associated with this application. We&rsquo;ll head to the Queues page and then drill into the vetclinicpublic queue, which is a queue that we set up to handle communication between the Front Desk app and the VetClinicPublic app. And you can see that the one and only message that RabbitMQ is tracking is in that queue. So we&rsquo;ll drill into that queue and then scroll down to see the details of the message itself. And the most interesting part, the payload, which is the JSON expression of the event data. You can see the GUID value of the AppointmentId, the ClientName is Julie Lerman, an email address, which is not really my email address, the PatientName is Sampson, and other relevant details that came from the integration event. So the Front Desk app knew to publish the message to this queue, and our VetClinicPublic app knows to read from this very specific queue in order to perform the task of emailing the client.</p>
<p>Reading From the Message Queue and Acting on the Message
Now that the message is waiting in the message queue, it&rsquo;s time to read the message and act on it. And acting on it is the next step in a workflow, sending an email to the client to let them know about the appointment they&rsquo;ve just scheduled. We can&rsquo;t do this easily from our scheduler application because we need for the user to be able to click on a link that specifies that they want to confirm their appointment, so it needs to be publicly accessible. So we&rsquo;ve decided to put this on the veterinary clinic&rsquo;s public website, and so that will be responsible both for sending the emails and for hosting the link that the customer will click. The public site uses a hosted service to periodically check for new things in its queue. Once it finds a message on the queue, it will retrieve the information from that message to create a confirmation email using code like what you see here. One of the most important pieces of this email is a link back to the public website, not really localhost, which includes the GUID that represents the appointment ID. The website then sends the email. That&rsquo;s what the user will end up clicking on in their email and trigger a confirmation using the website. Alright, so now we&rsquo;re looking at the vet clinic public website, which is a super simple demo solution that we put together. And one of the things it does when it starts is start checking for messages, which you can see here. But we don&rsquo;t have it running quite yet because it would&rsquo;ve already pulled the message out of the queue. First, we&rsquo;ll show you the code that&rsquo;s making this all work, and in a bit, we&rsquo;ll step through while debugging. The public website has a hosted service called FrontDeskRabbitMqService, which periodically checks the message queue to see if anything new has arrived. As soon as it finds one of those messages off of the message queue, it&rsquo;s going to send an email, and we&rsquo;re going to use a tool called Papercut, which will emulate a local email server for the purpose of testing. Rather than installing this on our dev machines, we&rsquo;re running a Docker container to host Papercut. You can view emails Papercut has received by clicking the Sent Emails link from the FrontDesk app&rsquo;s menu. Currently, there aren&rsquo;t any emails in Papercut, but as soon as we start the web application, it&rsquo;s going to check our message queue and then send an email that we should see appear in Papercut. There&rsquo;s a message, the same message that we sent out for Sampson&rsquo;s appointment. There&rsquo;s a hyperlink that leads us back to being able to confirm. Let&rsquo;s see first, high level, what happens when we click on that CONFIRM button, and then we&rsquo;ll come back and click it and watch it in action. So now the user has the email, and their beautiful CONFIRM link in the email. When they click that, it opens up the website, browsing directly to the GUID that was their appointment. And in response, the website calls its own method called confirm, which takes the relevant appointment ID and pushes it into another one of the queues. You&rsquo;ve seen the message queue that was used for relaying the message from FrontDesk to the public website, and that was named fdvcp‑vetclinicpublic‑in. Try to say that five times fast. But you can have as many queues defined in your system as you need. And one of the other queues that we&rsquo;ve defined is for relaying messages from the public website, in other words, when the client has clicked on the button to confirm their appointment back to the FrontDesk app.</p>
<p>Using Multiple Queues to Handle Various Communications
Now that the email&rsquo;s been sent, let&rsquo;s see what happens when the client clicks on the CONFIRM link in that email. ‑When we click on that, we&rsquo;ve now confirmed the appointment. Once the user clicks on the CONFIRM link, it drops the message with the confirmation back into the scheduler queue, and you can see that message right here. ‑Yeah, this middle queue shows that there&rsquo;s one message. Let&rsquo;s look at it. We&rsquo;ll scroll down to the Get Message(s) button, and the message is retrieved and displayed. We&rsquo;ve seen this before where the payload is the JSON data we&rsquo;re looking for, and this one contains the appointment ID that&rsquo;s just been confirmed. Now you can see that the two different applications are communicating back and forth with each other using their two separate message queues. We&rsquo;ve named the queues so that it&rsquo;s clear which applications are using them to communicate and in which direction. The initial acronym specifies which two applications are involved. Fdvcp means frontdesk and vet clinic public. The latter part of the queue&rsquo;s name says which app is listening to it. The last step now is for this confirmation information that&rsquo;s sitting in the queue to get back to the scheduling app. ‑Now in our scheduler application, we have implemented a hosted service just like you saw in the public website This one is called the VetClinicPublicRabbitMQService, and it listens to the appropriate queue to see if there are incoming messages that it needs to deal with. When it finds one, it responds to the AppointmentConfirmLinkClickedIntegrationEvent, yes, it&rsquo;s a long name, with the email confirmation handler. The handler looks up the appointment from the AppointmentId that was contained inside of the message, and from there, it calls Appointment.Confirm. Appointment, as you recall, is our entity, and its confirm method also then triggers some domain events, which for instance, our user interface listens to. And when it sees that that event has been fired, it triggers a change in the UI, enhancing the appointment with a green bar across the top to show that the appointment has been confirmed. Okay, so all that&rsquo;s going to happen at this point is that when the message comes through, it&rsquo;s going to make the Sampson appointment right here have a green border and pop up a dialog to let us know that a change has occurred. ‑It&rsquo;s very slick. This is actually really easy to implement because we already had the website listening for events. Remember how it was able to display new appointments and display conflicts? We&rsquo;ve implemented another design role based on a particular property of the appointment, which is confirm. All we did was set up another event handler. ‑We wrote the original sample for the first version of this course in 2013. At the time, things like SignalR and WebSocket, as well as emails with confirmation links were relatively rare, although we certainly didn&rsquo;t invent these kinds of app interactions. ‑Right, but now, every time I make an appointment for my dentist or hair and even for Sampson in real life to go to the vet, I&rsquo;m getting texts or emails with exactly these kinds of confirmation links. ‑I know, I guess maybe a lot of businesses watched our course.</p>
<p>Debugging to See the Detailed Implementation in Code
Now we&rsquo;re going to take a deep dive into the code that makes all this work, and we&rsquo;ll go through it step by step so that you can see how all this is wired together. And we&rsquo;ll do that by literally just debugging through the whole process, so you can see how all the code links up. Remember, all of the code for this sample is available on GitHub, and we encourage you to run it yourself to really understand how it works. The README file has instructions for running the solution using Docker, which is the recommended approach if you just want to see it running. There are also instructions for using Visual Studio or VS Code, which you will need if you want to debug the apps as we&rsquo;re about to do. For instance, I need to run RabbitMQ and PaperCut using the Docker commands shown here, before I can debug the app, as we&rsquo;re about to see. We&rsquo;re back in the vet manager, and the user is on the phone with Steve who wants to make an appointment with Darwin. Everything works just the same way it&rsquo;s worked before. We&rsquo;ll go ahead and add a new appointment and save the appointment, which triggers the ScheduleAggregate root&rsquo;s AddNewAppointment method. We&rsquo;ll leave the Locals window open while we&rsquo;re debugging so that if you want to pause the video and take a look at any of those values, you can do that. We haven&rsquo;t changed anything in the method. The only thing that&rsquo;s different is that now we&rsquo;ve got an additional subscriber that&rsquo;s listening for this domain event, this particular domain event, the AppointmentScheduled event, to be raised. So we&rsquo;ll go ahead and raise the event and watch what happens. At this point, we&rsquo;re looking at a new class that we created, which is this RelayAppointmentScheduled service, and what it&rsquo;s responsible for is creating the event that is going to get pushed onto the message queue that the public website is listening to. This is the new piece of logic that&rsquo;s listening for the event that we just raised. You can see it&rsquo;s listening for AppointmentScheduledEvent, a domain event, and in the method, the first thing we do is to create the AppointmentScheduledIntegrationEvent that represents our cross‑domain message that will be sent using RabbitMQ. The functionality we need from this event right now is to be able to send an email to the client, so we make sure to include all of the data that such an email would require. Now we&rsquo;re in the Publish method that lives inside of RabbitMessagePublisher, and that&rsquo;s inside of an infrastructure project. We&rsquo;ve moved out of the core domain, but this is still part of the main front desk scheduling application. Yes, and what it&rsquo;s responsible for doing is actually getting that message into a structure, a format that RabbitMQ can use. That means putting things into JSON format in this case, and then actually sending the message. Once this fires, we should be able to inspect the message queue in RabbitMQ, and verify that our message has actually been queued up for the VetClinicPublic input queue as expected. That&rsquo;s what we did before, but this time we&rsquo;re actually seeing the code that&rsquo;s making all of this happen. Alright, so that completes the actual thread of the UI. The response is complete for this part of the application. Now we&rsquo;ll pause this and switch over to the VetClinicPublic application. We&rsquo;ve just started it up again, and we&rsquo;ve shown this to you before. Now we&rsquo;re going to watch the flow of the code after the hosted service starts up. Jumping to the next breakpoint, you can see now we&rsquo;re inside of the actual HandleMessage method, which gets the message as a string. It&rsquo;s responsible for parsing the string using JSON, and deserializing it into an appropriate type. This is just demo code, so it&rsquo;s not the most reusable or elegant, but it works for this app. Remember that any change to the integration event in the front desk app will require changes here as well, which is one reason why a shared package can be useful for keeping applications in sync. Once we&rsquo;ve deserialized the message into a command, we use mediator to send the command, and a separate handler to actually send the email. This keeps extra code out of the hosted service, and lets the handler use dependency injection to get any services it needs. In this case, it&rsquo;s an implementation of, I send confirmation emails, called ConfirmationEmailSender. It&rsquo;s the service that builds the email with its details, including the URL behind the CONFIRM link in the email that the client receives. Remember, the whole reason why we need a separate app to implement this feature is that the end user needs to be able to click a link that goes to a public location on the internet. The front desk app is an internal app that runs inside the vet clinic&rsquo;s network so it&rsquo;s not accessible. The public website is a good place to send users, and while they&rsquo;re there, they can get more details about the clinic, or buy something from its theoretical online store, etc. After the email has been sent, we can see it in PaperCut, and opening it, we can see the CONFIRM hyperlink. Clicking the link brings us back into the VetClinicPublic application&rsquo;s, AppointmentController class. This endpoint simply creates a new event. This is the one with a really long name, AppointmentConfirmLinkClickedIntegrationEvent. Unlike the name of the event, the message itself is really simple, and just includes the appointment ID that was confirmed, and when it happened. The controller action then sends the event using a RabbitMQ messagePublisher that&rsquo;s identical to the one we just saw the front desk app use. However, this publisher&rsquo;s destination is actually a different queue, the front desk input queue. Technically, the front desk has two input queues, one for messages from the ClinicManagement app, and another for messages from the VetClinicPublic app. In this case, we&rsquo;re talking about the VetClinicPublic one. Back in the front desk scheduling app&rsquo;s hosted service, it discovers the message on the queue, and calls into the HandleMessage method in the service we&rsquo;ve seen a number of times, the VetClinicPublicRabbitMqService. Here, it parses the message and extracts the appointment ID, which it then uses to create and publish that really long‑named event again, AppointmentConfirmLinkClickedIntegrationEvent internally. This integration event triggers a call to the EmailConfirmationHandler, which loads the schedule aggregate, then locates the appropriate appointment, and calls its Confirm method. Finally, it saves the schedule. The appointment.confirm method makes an appointmentConfirmed domain event, which is fired once the aggregate is saved, and this event in turn triggers a handler in the UI. The appointmentConfirmed handler in the FrontDesk UI sends a message via SignalR, indicating the message was confirmed. This results in the browser showing a notification, and changing the format of the appointment to have a green border. You already saw similar logic used for the AppointmentUpdate and AppointmentScheduled handlers. That&rsquo;s the full round trip for how creating an appointment, getting an email, clicking a link, and confirming that appointment works for this application.</p>
<p>Considering Microservices
Since we published our original version of this course, which if you haven&rsquo;t watched, you&rsquo;ll find a link from either of our author pages, microservices have become incredibly popular. There are some benefits to microservices, even if they&rsquo;re probably a bit overhyped at the moment, and there are some obvious parallels between microservice design and DDD. ‑Microservices should be self‑contained and should not depend on other microservices. They should be independently deployable. Changing the internal behavior of a microservice should not break services that work with it, as long as it maintains compatibility with its external APIs and message interfaces. ‑So, basically what you&rsquo;re saying is each microservice should have a boundary around it, and within that boundary it should focus on a specific set of behaviors that its free to model however it sees fit. ‑That&rsquo;s right. ‑It&rsquo;s almost like each microservice can be considered its own context, and it has its own terminology and even language for how it&rsquo;s designed. ‑It is a lot like that, it&rsquo;s true, and it&rsquo;s not unusual for teams to treat individual microservices like bounded context with their own ubiquitous language and everything else that goes along with being a bounded context. But, beware of assuming that microservices and bounded context always have a perfect alignment. There can be plenty of scenarios where this could be a problem. My brilliant friend, Vladik Khononov, not to be confused with the also brilliant Pluralsight author, Vladimir Khorikov, has shared his experiences along these lines in his blog and also in recorded conference presentations. We&rsquo;ll include links to his content in the resources at the end of this module. ‑Now, this isn&rsquo;t a microservices course, but obviously if you&rsquo;re working on microservices, it would be helpful for you to have a good understanding of DDD concepts, because many of the problems that microservices solve are also solved by domain‑driven design. ‑In our sample application, there is an obvious candidate for a microservice. In fact, it&rsquo;s almost there already, the confirmation email sending logic that currently runs inside the public website. ‑We put the hosted service in that existing web application because it was convenient and because the two are loosely related since the emails include a clickable link that goes to a page on that public website. ‑But we could easily move that hosted service into its own process and treat it like a separate microservice, and that would simplify the public web app, so it would no longer need to have a two‑way relationship with a front desk app by way of message queues. Also, the front desk app is likely to be updated more frequently than the confirmation email logic, so it&rsquo;s possible that changes to the front desk application could break the email logic. ‑Yes, one of my favorite benefits of carving out a microservice is that if it&rsquo;s something stable and working, you get the benefit of just leaving it the heck alone. Updates to other parts of the app or system are much less likely to break a microservice that is in production and working, and not being deployed frequently. ‑Right, and the email sending logic is about as micro as a microservice can get, but in the future we might want to add other kinds of customer emails to send, and it would be a logical place to hold that logic. ‑Exactly, and since it has no user‑facing logic, it&rsquo;s a pretty simple change to make. Maybe some of our students could do that as another exercise.</p>
<p>Sharing Some Tips for Extending and Running the Sample Application
As we wrap up the course, we want to remind you, once more, that there are a number of to‑do items in the sample that you can use as ideas for ways to extend this demo app. Doing so would help you gain real experience working with the architecture and patterns you&rsquo;ve learned in this course. You&rsquo;re sure to learn and retain more from actually working with the code than from just listening to us or watching us show you the code. ‑We do have detailed instructions in the README for how to run the app. You can run the individual solutions in Visual Studio, but if you do so, keep in mind, you&rsquo;ll also need to make sure you have a local SQL Server running, and you&rsquo;ll need to update the connection strings and app settings for the applications to access it. You&rsquo;ll also need your own RabbitMQ and Papercut or similar test email server running, either as Docker containers or locally‑installed services. There&rsquo;s definitely a bit of effort involved in getting all of this set up and running the first time. ‑Alternatively, if you just want to run the app and see everything working, you should be able to do so with just two commands, assuming you have Docker installed. Just run docker‑compose build ‑‑parallel and then docker‑compose up. Each of these commands might take a few minutes. It usually takes about 2 minutes for the build step on my machine, and it&rsquo;s normal to see some errors when the docker‑compose up command runs until all of the services are up and running. Once the process stops outputting messages to the log window, you should be able to hit the application. To do that, take a look at the ports that are shown in the README file. And in the Docker column, you&rsquo;ll see the ports for all of the different applications and utilities that are used.</p>
<p>Considering the UI in the Domain Design
The control we used solved a number of the problems we thought we were going to have when embarking on this application. But the fact that the UI kind of impacted how we designed our domain begs the question about, well, if you&rsquo;re totally focused on the domain, why would you even be thinking about the UI? But thinking about the UI while we&rsquo;re working on the domain is not the anti‑pattern you may think it is. ‑Yes, we&rsquo;ve been focusing on the domain, but frequently the user interface needs to be considered, especially in the early stages of planning. You don&rsquo;t want to try to flesh out the whole domain design before you start thinking about the UI. ‑In a TechEd session I attended in 2013, Jimmy Nilsson, who&rsquo;s the author of the book Applying Domain‑Driven Design and Patterns, talked about the importance of thinking about the UI in the early stages of planning and revisiting it while modeling the domain, rather than ignoring it until the end. In his session, he describes how even the UI sketching he does in the early stages of his application planning can affect the whole design of the system. As we were building this scheduler sample for this course, we actually discovered a huge benefit to considering the UI early in the process. We initially had expected to encounter a lot of complexity in the appointment scheduling problem, but we found a UI control that helped visualize the schedule for the user, such that the system no longer needed to be as complex. In our scenario, scheduling is a big part of the application, but it isn&rsquo;t our domain, our domain is the veterinary clinic. We consider scheduling to be more of a cross‑cutting concern, and one that could be partially solved through a rich user interface. ‑By considering and using a rich user interface, we were able to do things like allowing conflicting appointments while making it obvious to the user that this had occurred. This gives the user more information, and they can make decisions about whether or not they need to correct the problem. When we initially considered the problem of appointment conflicts, we had thought the domain model would throw exceptions anytime something like that occurred. But this would have resulted in a much worse user experience. Frequently, in domain‑driven design, you need to consider the user experience, which at times may need to allow for models that are, at least temporarily, in an invalid or incomplete state. Keep this in mind as you design your domain model, and be careful not to make it too rigid to support scenarios your users may benefit from. ‑Thinking about the UI up front and discovering this kind of solution kept us from wasting a lot of time trying to solve certain scheduling problems in our domain. Of course, you don&rsquo;t want your UI to totally drive how you model your domain, but as Jimmy Nilsson notes, you shouldn&rsquo;t ignore it, either.</p>
<p>Modeling with Event Storming and Other Techniques
When you&rsquo;re developing apps using DDD, it can be helpful to visualize how processes communicate both within a bounded context and between context as part of a business process. As we mentioned earlier in this course, Alberto Brandolini has done a lot of work on a related practice called event storming. Event storming can be used by all parts of a business, not just developers, to describe how a part of the business works and to make the whole thing visible. Once this is done, later iterations of the diagrams and artifacts produced can be useful for modeling the software that will be used by the business. ‑You might recall the image we showed earlier of Julie facilitating an event storming workshop with a client. The result of that first iteration, called chaotic discovery, is not so easily captured, but it provides guidance for the later modeling you might do. ‑There are many ways to model your system. Another method, Event Modeling, championed by Adam Dymitruk, is another process, and this focuses on the inputs and outputs of events and how each of those events changes the system and changes state. And you can describe an entire system with this flow. ‑We&rsquo;ve used the wonderful online tool called a Miro board at miro.com to show one perspective of the scheduling system as information flows through the front desk application and into the VetClinicPublic website bounded context. The colors used here correspond to different things in our model, like aggregates, events, and other processes. ‑And there are other modeling processes that have been invented, adopted, and adapted within the DDD community. And many of us rely on a combination of processes and tools to help us and help our clients better understand their systems before embarking on design. But as always, balance is important. You&rsquo;ll want to beware of analysis paralysis. ‑Definitely. That reminds me of something Eric Evans talked to us about.</p>
<p>Eric Evans on the Fallacy of Perfectionism
Steve and I believe that it would be fitting to leave you with one last thought from the father of domain‑driven design, Eric Evans. Eric was kind enough to talk to us about DDD when we originally created this course so that we could share with you some of his wisdom. Eric talked about the fallacy of perfectionism, which aligns with our own sentiments about considering what you&rsquo;ve learned here to be guidance to help you solve complex software problems, not a roadblock to productivity. ‑Eric shared with us that what he&rsquo;s noticed is that there seems to be something about DDD that brings out the perfectionist in people, and they say, this model is not really good enough and churn and churn, trying to improve it. He says, no model is ever going to be perfect. ‑Eric goes on to say that we need to know what we&rsquo;re doing with this thing, the scenarios we&rsquo;re trying to address. We want a model that helps us do that, that makes it easier to make software that solves those problems. That&rsquo;s it. ‑This reminds me of the saying, all models are wrong, but some are useful. Our domain models don&rsquo;t need to be perfect. They just need to help us build the software that helps people solve problems and get work done. Don&rsquo;t strive for a perfect model, but rather just aim to develop a useful one.</p>
<p>Lessons Learned Since Our 2014 Course
Julie and I wanted to finish this course by spending a couple of minutes talking about some of the things we&rsquo;ve learned since we published the first edition of the course in 2014. ‑We&rsquo;ve received a ton of positive feedback from so many of you over the last few years, and we really appreciate it. So we did our best not to change the overall flow of this course too much since we know the last one was so well‑received. ‑Definitely. If you watched the original version, hopefully you found this one to be fresh, but familiar, and I suspect a lot of students will end up watching both as a way to cement some of these concepts or just to spend more time with us, right, Julie? ‑Maybe. Now let&rsquo;s highlight some of the things that have changed in the last few years. From a strict DDD perspective, there are a lot of new resources and techniques that have emerged as more and more companies are adopting DDD. Things like event storming an event modeling, which we&rsquo;ve touched on in this course, are starting to become mainstream parts of DDD for many organizations. ‑Yes, and the industry&rsquo;s use of some patterns have shifted too. There&rsquo;s a lot of pushback against the repository pattern these days. I think, in part, because it became very popular, but was often used without the context of DDD or other complementary patterns like the specification, and these can really help it shine. Our first course didn&rsquo;t really talk much about specification as a core DDD pattern, but it&rsquo;s something I use on most of my projects now. ‑From a technology perspective, our previous course was built for .NET developers, and at the same time, that meant .NET 4. The original veterinary application used ASP .NET, MVC, and Web API, and an early version of SignalR. And for data access, we used Entity Framework 6. ‑Since then, .NET Core, which is now .NET 5, has shipped and become the new standard for .NET developers, and the latest versions of EF Core have added a number of features that we&rsquo;re leveraging to help improve the design of our model like owned objects and filtered includes. We also shifted our use of domain events from being prepersistence to postpersistence. There are valid use cases for both kinds of domain events, but the latter is safer for any events that communicate outside of the domain, so we&rsquo;re defaulting to that this time around. ‑Right, especially since one of our key demos involve sending emails to the client. The original sample also used SQL Server for its message broker, which we chose because we didn&rsquo;t want to force our students to have to install a custom tool. But Docker is another technology that wasn&rsquo;t mainstream in 2014, but it is today, and it makes it a breeze to use custom bits of infrastructure. In this update to the course, we&rsquo;re definitely leveraging Docker to provide RabbitMQ messaging with 0 install, as well as to capture emails during development using Papercut in another Docker container. ‑Yeah, Docker should really make it trivial for students to run the application locally, even though it has a bunch of moving parts. If you don&rsquo;t have Docker, you can still run it in your IDE or from the command line, but with Docker, it&rsquo;s just a lot simpler to get going. ‑And along with Docker and containers, microservices have become a huge buzzword in the industry. Of course, Docker makes it much easier to deploy microservices, and DDD principles really shine when designing them. So all of these things, I think, are really complimentary. ‑Definitely, although I do think some companies are too quick to jump to microservices without fully understanding their domain and where to separate out different contexts. And on the topic of separation, our previous sample put everything in one giant solution, too, mostly to make it easier to find things. ‑This time, we went with something that should resemble a real‑world application even more with separate solutions for each bounded context. We even published the shared kernel as a NuGet package, in our case, hosted on nuget.org, although typically, your organization would probably have a private NuGet feed. ‑If you&rsquo;re still working with .NET Framework apps and you haven&rsquo;t watched the previous course, we encourage you to give it a look. Its samples are geared more toward that framework, and you should find a link to it on Julie or my author page here, on Pluralsight, or at this bit.ly link here. ‑And don&rsquo;t feel bad if it feels like there&rsquo;s still a lot you have to learn about DDD. It&rsquo;s a big topic. And as we&rsquo;ve just shared, Steve and I are constantly learning new ways to apply it, too. Be sure to check out other DDD courses here, on Pluralsight, and if you need direct help for you or your team, you can reach out to Steve or me, directly.</p>
<p>Review and Resources
If you remember nothing else from this particular module, the one thing to keep in mind is how simple it was for us to add in what was potentially a really complicated feature. Because of our DDD implementation and some of the infrastructure we had already built, it wasn&rsquo;t really very challenging to plug these new puzzle pieces into the application. ‑Right, we introduced a couple of new concepts. We talked about message queues, and those fit really nicely into our existing architecture because we were already using events to correspond to interesting things happening within our application. ‑And the message queue allowed us to stick a message in an external place by one application, and another application can come along and retrieve that message. So the message queue allows our applications to communicate with each other, but they can do it in a disconnected way. ‑And then we mentioned, but we didn&rsquo;t show, this concept of a service bus, often called an enterprise service bus, which you may want to introduce if you start having more than just a couple applications needing to talk to one another. ‑At the risk of being redundant, let&rsquo;s just pay homage one more time to how the decisions we made earlier on, when implementing the vet clinic solution, allowed us to add in a potentially complicated new feature, email notifications and responses into the application. ‑While we had used mediator to transfer domain events within the FrontDesk application, this time we took advantage of message queues to help us move events back and forth between applications. ‑Using RabbitMQ&rsquo;s API, we created three different queues that were specific to the cross‑application communications we needed. For example, a queue that the vet clinic public app could publish messages into for the FrontDesk application to retrieve so it could update the UI. ‑It&rsquo;s also important to note that we leveraged existing tools like RabbitMQ and Papercut to perform certain tasks. In DDD, we would refer to these as generic domains. You&rsquo;ve got to look under the covers to see how the code was making all the communication between the apps and the message keys possible, but without our domain model having to know about any of the details. ‑And then we shared some additional knowledge as we wrapped up the course. We talked about modeling practices like event storming and tools like MURAL. We talked about all of the new ideas that have evolved since we first published this course in 2014 and how they impacted this new version of the course and the sample application. ‑And we ended with some more wisdom from Eric Evans, to whom we are eternally grateful not only for bringing DDD to the software community, but also for spending time with us when we created the original course so that we could share his perspective and insights with you. ‑Like the end of a fireworks display when they shoot up many, many fireworks at once, we&rsquo;re sharing here a lot of resources and links because of the great many topics we brought into this last module. There are two pages of links here to articles and videos and other Pluralsight courses, so you might want to pause the video to be sure that you see them all. ‑So, from me, Steve Smith, ‑and from me, Julie Lerman, thanks so much for taking this journey with us through Domain‑Driven Design Fundamentals.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/http/">HTTP</a></li>
      <li><a href="http://localhost:1313/tags/soap/">SOAP</a></li>
      <li><a href="http://localhost:1313/tags/rest/">REST</a></li>
      <li><a href="http://localhost:1313/tags/.net/">.NET</a></li>
      <li><a href="http://localhost:1313/tags/wcf/">WCF</a></li>
      <li><a href="http://localhost:1313/tags/corewcf/">CoreWCF</a></li>
      <li><a href="http://localhost:1313/tags/asmx/">ASMX</a></li>
      <li><a href="http://localhost:1313/tags/c%23/">C#</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/nrtanalysispostgresql/">
    <span class="title">« Prev</span>
    <br>
    <span>Near real time API Monitoring with Grafana and PostgreSQL</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/apiupgrade/">
    <span class="title">Next »</span>
    <br>
    <span>Upgrading API: Learnings</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Domain driven Design: Learnings on x"
            href="https://x.com/intent/tweet/?text=Domain%20driven%20Design%3a%20Learnings&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdomain_driven_transcript_from_pluralsight%2f&amp;hashtags=HTTP%2cSOAP%2cREST%2c.NET%2cWCF%2cCoreWCF%2cASMX%2cC%23">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Domain driven Design: Learnings on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdomain_driven_transcript_from_pluralsight%2f&amp;title=Domain%20driven%20Design%3a%20Learnings&amp;summary=Domain%20driven%20Design%3a%20Learnings&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fdomain_driven_transcript_from_pluralsight%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Domain driven Design: Learnings on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdomain_driven_transcript_from_pluralsight%2f&title=Domain%20driven%20Design%3a%20Learnings">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Domain driven Design: Learnings on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fdomain_driven_transcript_from_pluralsight%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Domain driven Design: Learnings on whatsapp"
            href="https://api.whatsapp.com/send?text=Domain%20driven%20Design%3a%20Learnings%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fdomain_driven_transcript_from_pluralsight%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Domain driven Design: Learnings on telegram"
            href="https://telegram.me/share/url?text=Domain%20driven%20Design%3a%20Learnings&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fdomain_driven_transcript_from_pluralsight%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Domain driven Design: Learnings on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Domain%20driven%20Design%3a%20Learnings&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fdomain_driven_transcript_from_pluralsight%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>©</span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
