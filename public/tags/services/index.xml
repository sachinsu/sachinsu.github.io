<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Services on Learnings in IT</title>
    <link>http://localhost:1313/tags/services/</link>
    <description>Recent content in Services on Learnings in IT</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 15 Aug 2025 01:00:00 +0530</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/services/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Clean Architecture, Modular Monolith and Vertical Slice Architecture </title>
      <link>http://localhost:1313/posts/comparearchitecturestyles/</link>
      <pubDate>Fri, 15 Aug 2025 01:00:00 +0530</pubDate>
      <guid>http://localhost:1313/posts/comparearchitecturestyles/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Architecture plays a pivotal role in the delivery of software in terms of achieving business goals set forth for the software like maintainability, availability, performance and many more. It helps introduce structured approach to development by means of having appropriate abstractions. Typical driving forces for a software are, &#xA;    - Functional requirements &#xA;    - Quality attributes (performance, scalability, availability etc.)&#xA;    - Agility (Need to respond fluently to changes) &#xA;    - Constraints (Deployment platform)&#xA;    - Principles (Automated testing, Automated deployment etc.) &#xA;&#xA; In this pursuit, there are alternate styles to structure software. Lets look at below ones which are dominant, &#xA;&#xA;  - Monolith - Traditional approach involving tiering or layering by means of separation of concerns like UI, business logic and Data into layers/tiers. Each layer is &amp;quot;horizontally&amp;quot; sliced (Packaged by Layer). Promotes rules like UI/Controller must talk to Service which should only talk to Repository/Data Access layer. Typical observation is that changes to any one of the layers usually results in changes across all layers. Any change typically involves re-deployment of entire or most parts of Application.&#xA;&#xA;  - Microservices - an approach for developing a single application as a suite of small services, each running in it&#39;s own processes and communicating with lightweight mechanisms like HTTP based APIs. Services are built around business capabilities and are independently deployable. Key objective is bare minimum of centralized management. Typically suitable for Large, complex software projects. &#xA;&#xA;At a high level, Monolith approach has shown need for adaptation when it comes of agility expected from Software, while MicroServices provides agility , its often requires change in Organization&#39;s approach and found to be suitable for large use cases where benefits outweigh  related concerns like Eventual consistency, Operational Complexity and Distributed nature (Remote calls/(Fallacies of Distributed computing)[https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing]).&#xA;&#xA;Given this, are their tailored approaches aimed at specific requirements ?   Let&#39;s look at them , &#xA;    - Modular Monolith - Approach that tries to have golden mean between Monolith and Microservices by structuring the application into independent modules or components with well-defined boundaries with future possibilities of carving out microservices.&#xA;    - Vertical Slice Architecture (VSA)- Architecture is built around distinct requests, encapsulating and grouping all concerns from front-end to back-end.&#xA;    - Clean Architecture - Paradigm originally proposed by Robert Martin that isolates interfaces (user interfaces, databases, external systems, devices) from business logic. &#xA;&lt;/code&gt;&lt;/pr</description>
    </item>
  </channel>
</rss>
