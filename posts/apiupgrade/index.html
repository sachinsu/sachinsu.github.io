<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Upgrading API: Learnings | Learnings in IT</title><meta name=keywords content="HTTP,SOAP,REST,.NET,WCF,CoreWCF,ASMX,C#"><meta name=description content="Introduction
One of the design considerations stressed upon by Jeffrey richter about APIs (Read more here) is that &ldquo;API is expected to be stable over long period of time&rdquo;. Recently,for a .NET based project, we decided to upgrade some of the ASMX (legacy SOAP based approach) based APIs and were immediately reminded by Customer(s) to avoid any kind of impact on existing users.
This means that upgrade must be done keeping in mind,"><meta name=author content="Sachin Sunkle"><link rel=canonical href=https://sachinsu.github.io/posts/apiupgrade/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://sachinsu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sachinsu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sachinsu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://sachinsu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://sachinsu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sachinsu.github.io/posts/apiupgrade/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sachinsu.github.io/posts/apiupgrade/"><meta property="og:site_name" content="Learnings in IT"><meta property="og:title" content="Upgrading API: Learnings"><meta property="og:description" content="Introduction One of the design considerations stressed upon by Jeffrey richter about APIs (Read more here) is that “API is expected to be stable over long period of time”. Recently,for a .NET based project, we decided to upgrade some of the ASMX (legacy SOAP based approach) based APIs and were immediately reminded by Customer(s) to avoid any kind of impact on existing users.
This means that upgrade must be done keeping in mind,"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-15T01:00:00+05:30"><meta property="article:modified_time" content="2021-05-15T01:00:00+05:30"><meta property="article:tag" content="HTTP"><meta property="article:tag" content="SOAP"><meta property="article:tag" content="REST"><meta property="article:tag" content=".NET"><meta property="article:tag" content="WCF"><meta property="article:tag" content="CoreWCF"><meta property="og:image" content="https://sachinsu.github.io/images/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sachinsu.github.io/images/papermod-cover.png"><meta name=twitter:title content="Upgrading API: Learnings"><meta name=twitter:description content="Introduction
One of the design considerations stressed upon by Jeffrey richter about APIs (Read more here) is that &ldquo;API is expected to be stable over long period of time&rdquo;. Recently,for a .NET based project, we decided to upgrade some of the ASMX (legacy SOAP based approach) based APIs and were immediately reminded by Customer(s) to avoid any kind of impact on existing users.
This means that upgrade must be done keeping in mind,"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sachinsu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Upgrading API: Learnings","item":"https://sachinsu.github.io/posts/apiupgrade/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Upgrading API: Learnings","name":"Upgrading API: Learnings","description":"Introduction One of the design considerations stressed upon by Jeffrey richter about APIs (Read more here) is that \u0026ldquo;API is expected to be stable over long period of time\u0026rdquo;. Recently,for a .NET based project, we decided to upgrade some of the ASMX (legacy SOAP based approach) based APIs and were immediately reminded by Customer(s) to avoid any kind of impact on existing users.\nThis means that upgrade must be done keeping in mind,\n","keywords":["HTTP","SOAP","REST",".NET","WCF","CoreWCF","ASMX","C#"],"articleBody":"Introduction One of the design considerations stressed upon by Jeffrey richter about APIs (Read more here) is that “API is expected to be stable over long period of time”. Recently,for a .NET based project, we decided to upgrade some of the ASMX (legacy SOAP based approach) based APIs and were immediately reminded by Customer(s) to avoid any kind of impact on existing users.\nThis means that upgrade must be done keeping in mind,\nNo changes to API Contract (SOAP remains SOAP and so on) No changes to URLs Testing to ensure no impact Initial plan was to move away from SOAP to adopt REST based approach. This thinking was aided by fact that .NET core may not support WCF (framework that supports SOAP apart from ASMX Web Services) in addition to other aspects like simplicity and wide adoption of REST. However, even microsoft has now decided to support WCF in .NET Core via CoreWCF.\nWith this constraints, below alternatives were considered to upgrade ASMX based services to WCF (the only other framework that supports SOAP based services),\nApproach Description Have existing ASMX Service call new WCF Service using Async/Await This involves hosting additional WCF Service and making HTTP requests to it. It also means maintaining both ASMX \u0026 WCF endpoints. Also to be mindful of latency introduced due to HTTP communication between the two. New WCF Service and URL Rewrite rules to handle requests to ASMX This involves developing new WCF Service, compatible to current service contract, and configuration to route/re-write incoming requests to new service. Existing ASMX end point can be sunset New WCF Service and mapping .asmx handler to WCF handler This involves developing new WCF Service,compatible to current service contract, and configuration so that requests to .asmx url will be served by WCF handler. Existing ASMX end point can be sunset. Lets go through above approaches in detail.\nWCF service invoked from ASMX asynchronously This involves developing new WCF Service. Existing ASMX based web service will be modified to invoke new WCF Service. Asynchronously invocation should help in this case since whole operation is I/O bound (Asynchrony is a way to get concurrency without multithreading. E.g., freeing up the calling thread instead of blocking it while an I/O operation is in progress Stephen Cleary). Since ASMX is legacy framework and only support Event-based asynchronous pattern (EAP), it is necessary to combine EAP with Task based asynchronous pattern (TAP) which is what async/await uses. Below is sample snippet,\nprivate async Task FooAsync(int arg) { using (var resp = await client.GetAsync(string.Format(\"https://jsonplaceholder.typicode.com/todos/{0}\", arg)).ConfigureAwait(false)) { resp.EnsureSuccessStatusCode(); using (var contentStream = await resp.Content.ReadAsStreamAsync().ConfigureAwait(false)) { APIResponse obj = await JsonSerializer.DeserializeAsync(contentStream).ConfigureAwait(false); string output = string.Format(\"{0} at {1}\", obj.Title, DateTime.Now.Ticks); System.Diagnostics.Debug.WriteLine(output); return output; } } } [WebMethod] public IAsyncResult BeginFoo(int arg, AsyncCallback callback, object state) { return FooAsync(arg).ToApm(callback, state); } [WebMethod] public string EndFoo(IAsyncResult result) { try { return ((Task)result).Result; } catch (AggregateException ae) { throw ae.InnerException; } } Where ToApm is extension function from Stephen Toub’s excellent blog (link in code as comment),\npublic static Task ToApm(this Task task, AsyncCallback callback, object state) { if (task.AsyncState == state) { if (callback != null) { task.ContinueWith(delegate { callback(task); }, CancellationToken.None, TaskContinuationOptions.None, TaskScheduler.Default); } return task; } var tcs = new TaskCompletionSource(state); task.ContinueWith(delegate { if (task.IsFaulted) tcs.TrySetException(task.Exception.InnerExceptions); else if (task.IsCanceled) tcs.TrySetCanceled(); else tcs.TrySetResult(task.Result); if (callback != null) callback(tcs.Task); }, CancellationToken.None, TaskContinuationOptions.None, TaskScheduler.Default); return tcs.Task; } This approach involves,\nhosting and maintaining both (current and new) API end-points. We also came across issues where async/await was not working properly in case code blocks. Measuring and mitigating any latency induced due to this additional hop Additional Monitoring and logging to track WCF end-point We decided to explore alternative approaches instead of this.\nWCF service with URL re-write This requires hosting WCF Service which is backward compatible with ASMX based SOAP implementation.\nTypically this involves,\nsupporting basicHttpBinding Adding namespaces and support for XML Serialization to Service contract like, [ServiceContract(Name = \"RequestReplyService\", Namespace = \"http://tempuri.org/\"),XmlSerializerFormat] Adding Action to OperationContract attribute like, [OperationContract(IsOneWay = false, Action = \"http://tempuri.org/DoWork\")] Additional configuration to re-write incoming requests to .asmx to new service in web.config as below,\nOne may want to test above re-write settings in IIS as older versions of it require installation of URL Rewrite module.\nThis is followed by testing new WCF service from existing client(s), be it .NET based clients or other ones with no changes. .NET based clients typically invoke service through generated proxy class. For other clients, we basically simulated it via Postman.\nThis approach provides cleaner implementation vis-a-vis earlier approach such that it is still new WCF based implementation with no ASMX in use.\nWCF service with .asmx extension mapped to WCF handler This approach is very similar to last one with only change being instead of using URL re-write module, we will map .asmx extension to WCF Handler. So the changes are only in web.config as below,\n.... This was tested in same way as earlier with existing .NET and other clients.\nThis feels like even more cleaner approach than using URL re-write as it doesn’t involve using any additional module/library.\nFinally, we went ahead with this approach.\nHopefully,this article will be helpful to anyone involved in legacy modernization initiatives.\n[Update on 21-May-2021]\nASMX supports both SOAP as well as Form POST (i.e. content type application/x-www-form-urlencoded). This implies that there would be consumers of this API who are using either of the two formats to interact with API. Hence, it is necessary that new WCF based API supports both the formats. One way (If you are aware of any other approach, do let me know via comments) is to, Expose both SOAP and HTTP End-points like below,\nThis exposes SOAP end point at root (/) and HTTP end-point at (/http).\nSince clients are not aware of this new http end point, additional steps are needed to handle non soap requests seamlessly. This can be done in Global.asax as below,\nprotected void Application_BeginRequest(object sender, EventArgs e) { const string httpAddress = \"http/\"; if (Request.HttpMethod.ToLowerInvariant() == \"post\") { if (!Request.ContentType.ToLowerInvariant().Contains(\"xml\") \u0026\u0026 !Request.Url.AbsolutePath.ToLowerInvariant().Contains(httpAddress)) { List segments = Request.Url.Segments.ToList(); segments.Insert(segments.Count() - 1, httpAddress); var redirPath = String.Join(\"\",segments.ToArray()); Context.RewritePath(redirPath); } } } Above function, injects http in path based on Content-type of incoming request and then re-writes it.\nIdeally, i would have liked to do it via URL Rewrite module in web.config. However, i faced issues while setting up the rule that uses Content-type header.\nHowever, this approach still had issues wherein WCF run-time raised errors when ?singlewsdl url was accessed. It seems problem was due to multiple interfaces (one for SOAP and other for REST) and WCF not being able to generate WSDL for it. Additionally, REST handler is also deserves a look as it simply parses payload as Query String and populating properties of request DTO/class has to be done manually,\nResponseDTO IMyservice.Process(Stream input) { string body = new StreamReader(input).ReadToEnd(); NameValueCollection nvc = HttpUtility.ParseQueryString(body); return new ResponseDTO() { cnField = string.Format(\"NVCol --\u003e {0}|{1}\", nvc[\"prop1\"], nvc[\"prop2\"]) }; } Overall, WCF does not have great support for handling FORM POST requests. Hence, other alternative is to have ASP.NET MVC Web API handle the post requests. This approach is detailed here, check it out. Additionally, it takes changes to BeginRequest in global.asax to re-write incoming request so that Web API controller can process it, like below,\nprotected void Application_BeginRequest(object sender, EventArgs e) { if (Request.HttpMethod.ToLowerInvariant() == \"post\") { if (!Request.ContentType.ToLowerInvariant().Contains(\"xml\")) { List segments = Request.Url.Segments.ToList(); Context.RewritePath(string.Format(\"/controllers/{0}\",segments[segments.Count()-1])); } } } ASMX and SOAP 1.1 - It was noticed that though ASMX supports SOAP 1.1, it doesn’t enforces it when it comes to “SOAPAction” Header. As per the SOAP 1.1 specification, “SOAPAction” Http Header is mandatory and is used to determineWebmethod to be invoked. Since WCF is compliant with SOAP 1.1 specification, it required additional step to infer Webmethod by means of parsing the body. Luckily, Microsoft has sample for Dispatch by Body Element and same can be readily used. Overall, WCF Samples is fantastic set of samples that covers wide variety of such scenarios. Do Check it out.\nUseful References Comparing ASMX web services to WCF APM Pattern using Tasks Async in WCF Comparing ASMX with WCF Discussion on ASMX to WCF Happy Coding !!\n","wordCount":"1453","inLanguage":"en","image":"https://sachinsu.github.io/images/papermod-cover.png","datePublished":"2021-05-15T01:00:00+05:30","dateModified":"2021-05-15T01:00:00+05:30","author":{"@type":"Person","name":"Sachin Sunkle"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sachinsu.github.io/posts/apiupgrade/"},"publisher":{"@type":"Organization","name":"Learnings in IT","logo":{"@type":"ImageObject","url":"https://sachinsu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sachinsu.github.io/ accesskey=h title="Learnings in IT (Alt + H)">Learnings in IT</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sachinsu.github.io/about/ title=About><span>About</span></a></li><li><a href=https://sachinsu.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://gist.github.com/sachinsu title=Gists><span>Gists</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://sachinsu.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://sachinsu.github.io/links/home title="Useful Links"><span>Useful Links</span></a></li><li><a href=https://sachinsu.github.io/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sachinsu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sachinsu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Upgrading API: Learnings</h1><div class=post-meta><span title='2021-05-15 01:00:00 +0530 +0530'>May 15, 2021</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Sachin Sunkle</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#wcf-service-invoked-from-asmx-asynchronously aria-label="WCF service invoked from ASMX asynchronously">WCF service invoked from ASMX asynchronously</a></li><li><a href=#wcf-service-with-url-re-write aria-label="WCF service with URL re-write">WCF service with URL re-write</a></li><li><a href=#wcf-service-with-asmx-extension-mapped-to-wcf-handler aria-label="WCF service with .asmx extension mapped to WCF handler">WCF service with .asmx extension mapped to WCF handler</a><ul><li><a href=#useful-references aria-label="Useful References">Useful References</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>One of the design considerations stressed upon by Jeffrey richter about APIs (Read more <a href=/posts/restapiversioning/>here</a>) is that &ldquo;API is expected to be stable over long period of time&rdquo;. Recently,for a .NET based project, we decided to upgrade some of the ASMX (legacy SOAP based approach) based APIs and were immediately reminded by Customer(s) to avoid any kind of impact on existing users.</p><p>This means that upgrade must be done keeping in mind,</p><ul><li>No changes to API Contract (SOAP remains SOAP and so on)</li><li>No changes to URLs</li><li>Testing to ensure no impact</li></ul><p>Initial plan was to move away from SOAP to adopt REST based approach. This thinking was aided by fact that .NET core may not support WCF (framework that supports SOAP apart from ASMX Web Services) in addition to other aspects like simplicity and wide adoption of REST. However, even microsoft has now decided to support WCF in .NET Core via <a href=https://github.com/CoreWCF/CoreWCF target=_blank rel="noopener noreferrer">CoreWCF</a>.</p><p>With this constraints, below alternatives were considered to upgrade ASMX based services to WCF (the only other framework that supports SOAP based services),</p><table><thead><tr><th style=text-align:left>Approach</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left>Have existing ASMX Service call new WCF Service using Async/Await</td><td style=text-align:left>This involves hosting additional WCF Service and making HTTP requests to it. It also means maintaining both ASMX & WCF endpoints. Also to be mindful of latency introduced due to HTTP communication between the two.</td></tr><tr><td style=text-align:left>New WCF Service and URL Rewrite rules to handle requests to ASMX</td><td style=text-align:left>This involves developing new WCF Service, compatible to current service contract, and configuration to route/re-write incoming requests to new service. Existing ASMX end point can be sunset</td></tr><tr><td style=text-align:left>New WCF Service and mapping <code>.asmx</code> handler to WCF handler</td><td style=text-align:left>This involves developing new WCF Service,compatible to current service contract, and configuration so that requests to <code>.asmx</code> url will be served by WCF handler. Existing ASMX end point can be sunset.</td></tr></tbody></table><p>Lets go through above approaches in detail.</p><h2 id=wcf-service-invoked-from-asmx-asynchronously>WCF service invoked from ASMX asynchronously<a hidden class=anchor aria-hidden=true href=#wcf-service-invoked-from-asmx-asynchronously>#</a></h2><p>This involves developing new WCF Service. Existing ASMX based web service will be modified to invoke new WCF Service. Asynchronously invocation should help in this case since whole operation is I/O bound (<code>Asynchrony is a way to get concurrency without multithreading. E.g., freeing up the calling thread instead of blocking it while an I/O operation is in progress</code> Stephen Cleary). Since ASMX is legacy framework and only support Event-based asynchronous pattern (EAP), it is necessary to combine EAP with Task based asynchronous pattern (TAP) which is what async/await uses. Below is sample snippet,</p><pre tabindex=0><code> private async Task&lt;string&gt; FooAsync(int arg)
        {
            using (var resp = await client.GetAsync(string.Format(&#34;https://jsonplaceholder.typicode.com/todos/{0}&#34;, arg)).ConfigureAwait(false)) {
                resp.EnsureSuccessStatusCode();

                using (var contentStream = await resp.Content.ReadAsStreamAsync().ConfigureAwait(false)) { 

                    APIResponse obj = await JsonSerializer.DeserializeAsync&lt;APIResponse&gt;(contentStream).ConfigureAwait(false);

                   string output =  string.Format(&#34;{0} at {1}&#34;, obj.Title, DateTime.Now.Ticks);
                    System.Diagnostics.Debug.WriteLine(output);
                    return output;
                }
            }

        }

        [WebMethod]
        public IAsyncResult BeginFoo(int arg, AsyncCallback callback, object state)
        {
            return FooAsync(arg).ToApm(callback, state);           
        }

        [WebMethod]
        public string EndFoo(IAsyncResult result)
        {
            try
            {
                return ((Task&lt;string&gt;)result).Result;
            }
            catch (AggregateException ae) { throw ae.InnerException; }
        }
</code></pre><p>Where <code>ToApm</code> is extension function from Stephen Toub&rsquo;s excellent blog (link in code as comment),</p><pre tabindex=0><code>
        public static Task&lt;TResult&gt; ToApm&lt;TResult&gt;(this Task&lt;TResult&gt; task, AsyncCallback callback, object state)
        {
            if (task.AsyncState == state)
            {
                if (callback != null)
                {
                    task.ContinueWith(delegate { callback(task); },
                        CancellationToken.None, TaskContinuationOptions.None, TaskScheduler.Default);
                }
                return task;
            }

            var tcs = new TaskCompletionSource&lt;TResult&gt;(state);
            task.ContinueWith(delegate
            {
                if (task.IsFaulted) tcs.TrySetException(task.Exception.InnerExceptions);
                else if (task.IsCanceled) tcs.TrySetCanceled();
                else tcs.TrySetResult(task.Result);

                if (callback != null) callback(tcs.Task);

            }, CancellationToken.None, TaskContinuationOptions.None, TaskScheduler.Default);
            return tcs.Task;
        }
</code></pre><p>This approach involves,</p><ul><li>hosting and maintaining both (current and new) API end-points.</li><li>We also came across issues where async/await was not working properly in case code blocks.</li><li>Measuring and mitigating any latency induced due to this additional hop</li><li>Additional Monitoring and logging to track WCF end-point</li></ul><p>We decided to explore alternative approaches instead of this.</p><h2 id=wcf-service-with-url-re-write>WCF service with URL re-write<a hidden class=anchor aria-hidden=true href=#wcf-service-with-url-re-write>#</a></h2><p>This requires hosting WCF Service which is backward compatible with ASMX based SOAP implementation.</p><p>Typically this involves,</p><ul><li>supporting <code>basicHttpBinding</code></li><li>Adding namespaces and support for XML Serialization to Service contract like,</li></ul><pre tabindex=0><code>
  [ServiceContract(Name = &#34;RequestReplyService&#34;, Namespace = &#34;http://tempuri.org/&#34;),XmlSerializerFormat]
</code></pre><ul><li>Adding Action to OperationContract attribute like,</li></ul><pre tabindex=0><code>[OperationContract(IsOneWay = false, Action = &#34;http://tempuri.org/DoWork&#34;)]
</code></pre><p>Additional configuration to re-write incoming requests to <code>.asmx</code> to new service in <code>web.config</code> as below,</p><pre tabindex=0><code>
 &lt;system.webServer&gt;
    &lt;validation validateIntegratedModeConfiguration=&#34;false&#34; /&gt;    
    &lt;rewrite&gt;
      &lt;rules&gt;
        &lt;rule name=&#34;asmxtosvc&#34; stopProcessing=&#34;true&#34;&gt;
          &lt;match url=&#34;^service.asmx(.*)$&#34; /&gt;
          &lt;action type=&#34;Rewrite&#34; url=&#34;Service.svc{R:1}&#34;/&gt;
        &lt;/rule&gt;
      &lt;/rules&gt;
    &lt;/rewrite&gt;
  &lt;/system.webServer&gt;
</code></pre><p>One may want to test above re-write settings in IIS as older versions of it require installation of URL Rewrite module.</p><p>This is followed by testing new WCF service from existing client(s), be it .NET based clients or other ones with no changes. .NET based clients typically invoke service through generated proxy class. For other clients, we basically simulated it via Postman.</p><p>This approach provides cleaner implementation vis-a-vis earlier approach such that it is still new WCF based implementation with no ASMX in use.</p><h2 id=wcf-service-with-asmx-extension-mapped-to-wcf-handler>WCF service with .asmx extension mapped to WCF handler<a hidden class=anchor aria-hidden=true href=#wcf-service-with-asmx-extension-mapped-to-wcf-handler>#</a></h2><p>This approach is very similar to last one with only change being instead of using URL re-write module, we will map <code>.asmx</code> extension to WCF Handler. So the changes are only in web.config as below,</p><pre tabindex=0><code>
&lt;system.web&gt;
    &lt;httpHandlers&gt;
    &lt;remove path=&#34;.asmx&#34; verb=&#34;*&#34; /&gt;
    &lt;add path=&#34;*.asmx&#34; verb=&#34;*&#34; type=&#34;System.ServiceModel.Activation.HttpHandler, System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&#34; validate=&#34;false&#34; /&gt;
    &lt;/httpHandlers&gt;
    &lt;compilation debug=&#34;true&#34; targetFramework=&#34;4.8&#34;&gt;
    &lt;buildProviders&gt;
        &lt;remove extension=&#34;.asmx&#34;/&gt;
        &lt;add extension=&#34;.asmx&#34; type=&#34;System.ServiceModel.Activation.ServiceBuildProvider, System.ServiceModel, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&#34;/&gt;
      &lt;/buildProviders&gt;
    &lt;/compilation&gt;
    &lt;httpRuntime targetFramework=&#34;4.8&#34;/&gt;
  &lt;/system.web&gt;
....


&lt;system.webServer&gt;
  &lt;handlers&gt;
    &lt;remove name=&#34;WebServiceHandlerFactory-Integrated&#34;/&gt;
    &lt;add name=&#34;MyNewAsmxHandler&#34; path=&#34;*.asmx&#34; verb=&#34;*&#34; type=&#34;System.ServiceModel.Activation.HttpHandler, System.ServiceModel.Activation, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35&#34; /&gt;
  &lt;/handlers&gt;
  &lt;validation validateIntegratedModeConfiguration=&#34;false&#34; /&gt;
&lt;/system.webServer&gt;
</code></pre><p>This was tested in same way as earlier with existing .NET and other clients.</p><p>This feels like even more cleaner approach than using URL re-write as it doesn&rsquo;t involve using any additional module/library.</p><p>Finally, we went ahead with this approach.</p><p>Hopefully,this article will be helpful to anyone involved in legacy modernization initiatives.</p><p><strong>[Update on 21-May-2021]</strong></p><ul><li>ASMX supports both SOAP as well as Form POST (i.e. content type application/x-www-form-urlencoded). This implies that there would be consumers of this API who are using either of the two formats to interact with API. Hence, it is necessary that new WCF based API supports both the formats. One way (If you are aware of any other approach, do let me know via comments) is to,<ul><li><p>Expose both SOAP and HTTP End-points like below,</p><pre tabindex=0><code>  &lt;service name=&#34;wcf.Myservice&#34;&gt;
    &lt;endpoint address=&#34;&#34; binding=&#34;basicHttpBinding&#34; contract=&#34;wcf.IMyserviceSoap&#34; /&gt;
    &lt;endpoint address=&#34;http&#34; kind=&#34;webHttpEndpoint&#34; endpointConfiguration=&#34;webEndpointWithHelp&#34; contract=&#34;wcf.IMyservice&#34; /&gt;
    &lt;endpoint address=&#34;mex&#34; binding=&#34;mexHttpBinding&#34; contract=&#34;IMetadataExchange&#34; /&gt;
  &lt;/service&gt;
</code></pre><p>This exposes SOAP end point at root (<code>/</code>) and HTTP end-point at (<code>/http</code>).</p></li><li><p>Since clients are not aware of this new <code>http</code> end point, additional steps are needed to handle non soap requests seamlessly. This can be done in <code>Global.asax</code> as below,</p><pre tabindex=0><code>     protected void Application_BeginRequest(object sender, EventArgs e)
    {
        const string httpAddress = &#34;http/&#34;;

        if (Request.HttpMethod.ToLowerInvariant() == &#34;post&#34;)
        {
            if (!Request.ContentType.ToLowerInvariant().Contains(&#34;xml&#34;) &amp;&amp; !Request.Url.AbsolutePath.ToLowerInvariant().Contains(httpAddress))
            {
                List&lt;string&gt; segments = Request.Url.Segments.ToList();
                segments.Insert(segments.Count() - 1, httpAddress);

                var redirPath = String.Join(&#34;&#34;,segments.ToArray());

                Context.RewritePath(redirPath);
            }
        }
    }
</code></pre><p>Above function, injects <code>http</code> in path based on <code>Content-type</code> of incoming request and then re-writes it.</p><p>Ideally, i would have liked to do it via <a href=https://docs.microsoft.com/en-us/iis/extensions/url-rewrite-module/using-the-url-rewrite-module target=_blank rel="noopener noreferrer">URL Rewrite</a> module in web.config. However, i faced issues while setting up the rule that uses <code>Content-type</code> header.</p></li></ul></li></ul><p>However, this approach still had issues wherein WCF run-time raised errors when <code>?singlewsdl</code> url was accessed. It seems problem was due to multiple interfaces (one for SOAP and other for REST) and WCF not being able to generate WSDL for it. Additionally, REST handler is also deserves a look as it simply parses payload as Query String and populating properties of request DTO/class has to be done manually,</p><pre tabindex=0><code>
  ResponseDTO IMyservice.Process(Stream input)
      {
          string body = new StreamReader(input).ReadToEnd();
          NameValueCollection nvc = HttpUtility.ParseQueryString(body);

          return new ResponseDTO()
          {
              cnField = string.Format(&#34;NVCol --&gt; {0}|{1}&#34;, nvc[&#34;prop1&#34;], nvc[&#34;prop2&#34;])
          };
      }
</code></pre><p>Overall, WCF does not have great support for handling <code>FORM POST</code> requests. Hence, other alternative is to have ASP.NET MVC Web API handle the post requests. This approach is detailed <a href=https://stackoverflow.com/questions/18204365/setting-up-web-api-within-wcf-project target=_blank rel="noopener noreferrer">here</a>, check it out. Additionally, it takes changes to <code>BeginRequest</code> in <code>global.asax</code> to re-write incoming request so that Web API controller can process it, like below,</p><pre tabindex=0><code> protected void Application_BeginRequest(object sender, EventArgs e)
      {

          if (Request.HttpMethod.ToLowerInvariant() == &#34;post&#34;)
          {
              if (!Request.ContentType.ToLowerInvariant().Contains(&#34;xml&#34;))
              {
                  List&lt;string&gt; segments = Request.Url.Segments.ToList();

                  Context.RewritePath(string.Format(&#34;/controllers/{0}&#34;,segments[segments.Count()-1]));
              }
          }
      }
</code></pre><ul><li>ASMX and SOAP 1.1 - It was noticed that though ASMX supports SOAP 1.1, it doesn&rsquo;t enforces it when it comes to &ldquo;SOAPAction&rdquo; Header. As per the SOAP 1.1 specification, &ldquo;SOAPAction&rdquo; Http Header is mandatory and is used to determine<code>Webmethod</code> to be invoked. Since WCF is compliant with SOAP 1.1 specification, it required additional step to infer Webmethod by means of parsing the body. Luckily, Microsoft has sample for <a href=https://docs.microsoft.com/en-us/dotnet/framework/wcf/samples/dispatch-by-body-element target=_blank rel="noopener noreferrer">Dispatch by Body Element</a> and same can be readily used.</li></ul><p>Overall, <a href=https://docs.microsoft.com/en-us/dotnet/framework/wcf/samples/ target=_blank rel="noopener noreferrer">WCF Samples</a> is fantastic set of samples that covers wide variety of such scenarios. Do Check it out.</p><h3 id=useful-references>Useful References<a hidden class=anchor aria-hidden=true href=#useful-references>#</a></h3><ul><li><a href=https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/comparing-aspnet-web-services-to-wcf-based-on-development target=_blank rel="noopener noreferrer">Comparing ASMX web services to WCF</a></li><li><a href=https://devblogs.microsoft.com/pfxteam/using-tasks-to-implement-the-apm-pattern/ target=_blank rel="noopener noreferrer">APM Pattern using Tasks</a></li><li><a href=https://blog.stephencleary.com/2012/08/async-wcf-today-and-tomorrow.html target=_blank rel="noopener noreferrer">Async in WCF</a></li><li><a href=https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/comparing-aspnet-web-services-to-wcf-based-on-development target=_blank rel="noopener noreferrer">Comparing ASMX with WCF</a></li><li><a href=https://stackoverflow.com/questions/5686320/asmx-to-wcf-conversion target=_blank rel="noopener noreferrer">Discussion on ASMX to WCF</a></li></ul><p>Happy Coding !!</p><hr><script src=https://utteranc.es/client.js repo=sachinsu/sachinsu.github.io issue-term=title label=blogcomment theme=github-light crossorigin=anonymous async></script></div><footer class=post-footer><ul class=post-tags><li><a href=https://sachinsu.github.io/tags/http/>HTTP</a></li><li><a href=https://sachinsu.github.io/tags/soap/>SOAP</a></li><li><a href=https://sachinsu.github.io/tags/rest/>REST</a></li><li><a href=https://sachinsu.github.io/tags/.net/>.NET</a></li><li><a href=https://sachinsu.github.io/tags/wcf/>WCF</a></li><li><a href=https://sachinsu.github.io/tags/corewcf/>CoreWCF</a></li><li><a href=https://sachinsu.github.io/tags/asmx/>ASMX</a></li><li><a href=https://sachinsu.github.io/tags/c%23/>C#</a></li></ul><nav class=paginav><a class=prev href=https://sachinsu.github.io/posts/nrtanalysispostgresql/><span class=title>« Prev</span><br><span>Near real time API Monitoring with Grafana and PostgreSQL</span>
</a><a class=next href=https://sachinsu.github.io/posts/presto/><span class=title>Next »</span><br><span>Presto - A distributed SQL Engine for variety of data stores</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Upgrading API: Learnings on x" href="https://x.com/intent/tweet/?text=Upgrading%20API%3a%20Learnings&amp;url=https%3a%2f%2fsachinsu.github.io%2fposts%2fapiupgrade%2f&amp;hashtags=HTTP%2cSOAP%2cREST%2c.NET%2cWCF%2cCoreWCF%2cASMX%2cC%23"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Upgrading API: Learnings on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsachinsu.github.io%2fposts%2fapiupgrade%2f&amp;title=Upgrading%20API%3a%20Learnings&amp;summary=Upgrading%20API%3a%20Learnings&amp;source=https%3a%2f%2fsachinsu.github.io%2fposts%2fapiupgrade%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Upgrading API: Learnings on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsachinsu.github.io%2fposts%2fapiupgrade%2f&title=Upgrading%20API%3a%20Learnings"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Upgrading API: Learnings on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsachinsu.github.io%2fposts%2fapiupgrade%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Upgrading API: Learnings on whatsapp" href="https://api.whatsapp.com/send?text=Upgrading%20API%3a%20Learnings%20-%20https%3a%2f%2fsachinsu.github.io%2fposts%2fapiupgrade%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Upgrading API: Learnings on telegram" href="https://telegram.me/share/url?text=Upgrading%20API%3a%20Learnings&amp;url=https%3a%2f%2fsachinsu.github.io%2fposts%2fapiupgrade%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Upgrading API: Learnings on ycombinator" href="https://news.ycombinator.com/submitlink?t=Upgrading%20API%3a%20Learnings&u=https%3a%2f%2fsachinsu.github.io%2fposts%2fapiupgrade%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>©</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>