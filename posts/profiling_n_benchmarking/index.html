<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Profiling and benchmarking tools for Applications | Learnings in IT</title><meta name=keywords content="pyroscope,crank,flame graph,CPU"><meta name=description content="Introduction
We develop a piece of software with aim to fulfil specific business requirements in terms of resource usage, throughput, availability among others. Profiling and benchmarking are approaches that developer has in his/her arsenal to gain continuous feedback on whether a piece of code is behaving optimally and adhering to it&rsquo;s objectives.
Lets look at what they mean,

Profiling is defined as process aimed at  understanding the behavior of a program. A profile result might be a table of time taken per function, as per this and this)
Benchmarking  measures the time for some whole operation. e.g. I/O operations per second under some workload. So the result is typically a single number, in either seconds or operations per second. Or a data set with results for different parameters, so you can graph it.. Refer this for more information. Also do check Benchmarking correctly is hard by Julia Evans.

Typically, Profiling is supported by most of the environments (either via IDEs like Visual Studio or through language itself [Like Go] has buil-in provision for the same while Benchmarking is typically performed on dedicated testing infrastructure."><meta name=author content="Sachin Sunkle"><link rel=canonical href=https://sachinsu.github.io/posts/profiling_n_benchmarking/><link crossorigin=anonymous href=/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css integrity="sha256-IhHKMWS+eDACT2qtKzouUghDpk+PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as=style><link rel=icon href=https://sachinsu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sachinsu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sachinsu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://sachinsu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://sachinsu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sachinsu.github.io/posts/profiling_n_benchmarking/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sachinsu.github.io/posts/profiling_n_benchmarking/"><meta property="og:site_name" content="Learnings in IT"><meta property="og:title" content="Profiling and benchmarking tools for Applications"><meta property="og:description" content="Introduction We develop a piece of software with aim to fulfil specific business requirements in terms of resource usage, throughput, availability among others. Profiling and benchmarking are approaches that developer has in his/her arsenal to gain continuous feedback on whether a piece of code is behaving optimally and adhering to it’s objectives.
Lets look at what they mean,
Profiling is defined as process aimed at understanding the behavior of a program. A profile result might be a table of time taken per function, as per this and this) Benchmarking measures the time for some whole operation. e.g. I/O operations per second under some workload. So the result is typically a single number, in either seconds or operations per second. Or a data set with results for different parameters, so you can graph it.. Refer this for more information. Also do check Benchmarking correctly is hard by Julia Evans. Typically, Profiling is supported by most of the environments (either via IDEs like Visual Studio or through language itself [Like Go] has buil-in provision for the same while Benchmarking is typically performed on dedicated testing infrastructure."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-12T01:00:00+05:30"><meta property="article:modified_time" content="2021-12-12T01:00:00+05:30"><meta property="article:tag" content="Pyroscope"><meta property="article:tag" content="Crank"><meta property="article:tag" content="Flame Graph"><meta property="article:tag" content="CPU"><meta property="og:image" content="https://sachinsu.github.io/images/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sachinsu.github.io/images/papermod-cover.png"><meta name=twitter:title content="Profiling and benchmarking tools for Applications"><meta name=twitter:description content="Introduction
We develop a piece of software with aim to fulfil specific business requirements in terms of resource usage, throughput, availability among others. Profiling and benchmarking are approaches that developer has in his/her arsenal to gain continuous feedback on whether a piece of code is behaving optimally and adhering to it&rsquo;s objectives.
Lets look at what they mean,

Profiling is defined as process aimed at  understanding the behavior of a program. A profile result might be a table of time taken per function, as per this and this)
Benchmarking  measures the time for some whole operation. e.g. I/O operations per second under some workload. So the result is typically a single number, in either seconds or operations per second. Or a data set with results for different parameters, so you can graph it.. Refer this for more information. Also do check Benchmarking correctly is hard by Julia Evans.

Typically, Profiling is supported by most of the environments (either via IDEs like Visual Studio or through language itself [Like Go] has buil-in provision for the same while Benchmarking is typically performed on dedicated testing infrastructure."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sachinsu.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Profiling and benchmarking tools for Applications","item":"https://sachinsu.github.io/posts/profiling_n_benchmarking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Profiling and benchmarking tools for Applications","name":"Profiling and benchmarking tools for Applications","description":"Introduction We develop a piece of software with aim to fulfil specific business requirements in terms of resource usage, throughput, availability among others. Profiling and benchmarking are approaches that developer has in his/her arsenal to gain continuous feedback on whether a piece of code is behaving optimally and adhering to it\u0026rsquo;s objectives.\nLets look at what they mean,\nProfiling is defined as process aimed at understanding the behavior of a program. A profile result might be a table of time taken per function, as per this and this) Benchmarking measures the time for some whole operation. e.g. I/O operations per second under some workload. So the result is typically a single number, in either seconds or operations per second. Or a data set with results for different parameters, so you can graph it.. Refer this for more information. Also do check Benchmarking correctly is hard by Julia Evans. Typically, Profiling is supported by most of the environments (either via IDEs like Visual Studio or through language itself [Like Go] has buil-in provision for the same while Benchmarking is typically performed on dedicated testing infrastructure.\n","keywords":["pyroscope","crank","flame graph","CPU"],"articleBody":"Introduction We develop a piece of software with aim to fulfil specific business requirements in terms of resource usage, throughput, availability among others. Profiling and benchmarking are approaches that developer has in his/her arsenal to gain continuous feedback on whether a piece of code is behaving optimally and adhering to it’s objectives.\nLets look at what they mean,\nProfiling is defined as process aimed at understanding the behavior of a program. A profile result might be a table of time taken per function, as per this and this) Benchmarking measures the time for some whole operation. e.g. I/O operations per second under some workload. So the result is typically a single number, in either seconds or operations per second. Or a data set with results for different parameters, so you can graph it.. Refer this for more information. Also do check Benchmarking correctly is hard by Julia Evans. Typically, Profiling is supported by most of the environments (either via IDEs like Visual Studio or through language itself [Like Go] has buil-in provision for the same while Benchmarking is typically performed on dedicated testing infrastructure.\nIn this article, We will look at couple of tools in this space that can be easily integrated in developer’s workflow so as to get early feedback. Lets’ go.\nProfiling Pyroscope is Open Source Application for profiling Application. It is a cross-language tool i.e. programs in variety of languages can be profiled using it. It works in client server model where in, - Client - Pyroscope executable runs the intended code (in languages like C#, Ruby) etc. (in case of Go, it is available as dependency) and collects instrumentation details to be sent to server. - Server - Runs as a separate process (on Linux [Works in WSL if using Windows] or Mac), collects the data from client processes and renders them as table and/or flame graph via Web UI.A flamegraph is a way to visualize resources used by a program, like CPU usage or memory allocations, and see which parts of your code were responsible.\nLets see how a function in C# can be instrumented using PyroScope.\nDevelop function to be profiled Lets have ASP.NET Core 5.0 based Web API as below, Simple Web API handler in C# Setup Pyroscope\nInstall Pyroscope Application by following instructions here for Windows. Note that, Pyroscope server component won’t run on Windows in which case either Windows Subsystem for Linux (WSL) or Docker can be used. In case of Linux, instructions provided here are sufficient for both client and server components.\nI have setup the application on Windows 10 while using WSL for Pyroscope Server.\nConfigure Pyroscope client and run the Application\nBuild the application using dotnet build\nConfigure below environment variables (below is powershell format or you can use SET ... commands on command prompt),\n``` $env:PYROSCOPE_SPY_NAME=\"dotnetspy\"; $env:PYROSCOPE_APPLICATION_NAME=\"my.dotnet.app\"; $env:PYROSCOPE_SERVER_ADDRESS=\"http://localhost:4040\"; ``` Update path to include pyroscope installation folder using $env:Path += \";C:\\Program Files\\Pyroscope\\Pyroscope Agent\\\"\nRun the Application using pyroscope exec dotnet .\\bin\\Debug\\net5.0\\webapi.dll.\nRun Pyroscope Server\nStart Pyroscope server from WSL Linux prompt using, sudo pyroscope server. The output of this command should show Port on which server is running.\nEither use curl or hey tool to invoke the API. Below command shows how to generate load using hey, run .\\hey.exe -m GET -c 10 -q 2 http://localhost:5000/weatherforecast (Note: Modify the URL As appropriate) Observe the flame graph in Pyroscope Web UI.\nObserve the Table and/or flamegraph using Pyroscope Web interface. Below screenshot shows flamegraph for above code. Refer here and here for everything about flame graphs.\nTable and flamegraph for API Table and flamegraph for API Overall, Pyroscope provides easy way to observe Memory/CPU utilization as part of developer workflow on workstation itself. This is especially useful for development environments which do not provide profiling out of the box.\nBenchmarking Crank is tool used by Microsoft internally to benchmark applications. It is released as Nuget package and currently .NET based code or Docker Containers can be benchmarked using it. Lets see steps to benchmark .NET Application using Crank.\nWrite code, intended to be benchmarked. In this case, its very simple one as below,\nC# Code to be benchmarked Setup Crank\nFollow the instructions provided here to setup crank. Crank expects Configuration in YAML format which contains details like Job to be used. Crank has built-in jobs which are essentially wrappers around CLI load testing tools like bombardier and wrk and so on. Since i am using Windows to run crank, we will go with Bombardier which is cross platform. Below is how a basic configuration looks like,\nCrank YAML Configuration It allows for extensibility in terms of overriding the job configuration in terms of how load should be generated etc.\nRun Crank Agent - Next step is to run crank agent in a command prompt or powershell by simply running crank-agent\nRecord data for benchmarking using Crank CLI.\nNow run Crank from the application folder as crank --config crank.benchmarks.yml --scenario hello --profile local --application.options.displayOutput true\nThis command builds the code and launches job while recording the Utilization and other parameters and shows output like,\nApplication's CPU Utilization Observations during executing load testing Overall, i found Crank helpful for following,\nit helps quickly test effect of any code changes by means of quickly benchmarking the application. The overall benchmarking might not be similar to end state ie. when the application will be deployed on target infrastructure. However, it still gives insights to developer about impact of code changes Crank can be easily used for local applications as well as for docker containers. It can either be used locally or in distributed manner. Useful References Pyroscope Crank Performance Anti-patterns Happy Profiling and Benchmarking !!\n","wordCount":"943","inLanguage":"en","image":"https://sachinsu.github.io/images/papermod-cover.png","datePublished":"2021-12-12T01:00:00+05:30","dateModified":"2021-12-12T01:00:00+05:30","author":{"@type":"Person","name":"Sachin Sunkle"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sachinsu.github.io/posts/profiling_n_benchmarking/"},"publisher":{"@type":"Organization","name":"Learnings in IT","logo":{"@type":"ImageObject","url":"https://sachinsu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sachinsu.github.io/ accesskey=h title="Learnings in IT (Alt + H)">Learnings in IT</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sachinsu.github.io/about/ title=About><span>About</span></a></li><li><a href=https://sachinsu.github.io/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://gist.github.com/sachinsu title=Gists><span>Gists</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://sachinsu.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://sachinsu.github.io/links/home title="Useful Links"><span>Useful Links</span></a></li><li><a href=https://sachinsu.github.io/tags title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sachinsu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sachinsu.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Profiling and benchmarking tools for Applications</h1><div class=post-meta><span title='2021-12-12 01:00:00 +0530 +0530'>December 12, 2021</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Sachin Sunkle</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#profiling aria-label=Profiling>Profiling</a></li><li><a href=#benchmarking aria-label=Benchmarking>Benchmarking</a><ul><li><a href=#useful-references aria-label="Useful References">Useful References</a></li></ul></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>We develop a piece of software with aim to fulfil specific business requirements in terms of resource usage, throughput, availability among others. Profiling and benchmarking are approaches that developer has in his/her arsenal to gain continuous feedback on whether a piece of code is behaving optimally and adhering to it&rsquo;s objectives.</p><p>Lets look at what they mean,</p><ul><li>Profiling is defined as process <code>aimed at understanding the behavior of a program. A profile result might be a table of time taken per function,</code> as per <a href=https://stackoverflow.com/questions/34801622/difference-between-benchmarking-and-profiling target=_blank rel="noopener noreferrer">this</a> and <a href=https://en.wikipedia.org/wiki/Profiling_%28computer_programming%29 target=_blank rel="noopener noreferrer">this</a>)</li><li>Benchmarking <code>measures the time for some whole operation. e.g. I/O operations per second under some workload. So the result is typically a single number, in either seconds or operations per second. Or a data set with results for different parameters, so you can graph it.</code>. Refer <a href=https://en.wikipedia.org/wiki/Benchmark_%28computing%29 target=_blank rel="noopener noreferrer">this</a> for more information. Also do check <a href=https://jvns.ca/blog/2016/07/23/rigorous-benchmarking-in-reasonable-time/ target=_blank rel="noopener noreferrer">Benchmarking correctly is hard by Julia Evans</a>.</li></ul><p>Typically, Profiling is supported by most of the environments (either via IDEs like <a href="https://docs.microsoft.com/en-us/visualstudio/profiling/profiling-feature-tour?view=vs-2022" target=_blank rel="noopener noreferrer">Visual Studio</a> or through language itself [Like <a href=https://go.dev/blog/pprof target=_blank rel="noopener noreferrer">Go</a>] has buil-in provision for the same while Benchmarking is typically performed on dedicated testing infrastructure.</p><p>In this article, We will look at couple of tools in this space that can be easily integrated in developer&rsquo;s workflow so as to get early feedback. Lets&rsquo; go.</p><h2 id=profiling>Profiling<a hidden class=anchor aria-hidden=true href=#profiling>#</a></h2><p><a href=https://pyroscope.io target=_blank rel="noopener noreferrer">Pyroscope</a> is Open Source Application for profiling Application. It is a cross-language tool i.e. programs in variety of languages can be profiled using it. It works in client server model where in,
- Client - Pyroscope executable runs the intended code (in languages like C#, Ruby) etc. (in case of Go, it is available as dependency) and collects instrumentation details to be sent to server.
- Server - Runs as a separate process (on Linux [Works in WSL if using Windows] or Mac), collects the data from client processes and renders them as table and/or flame graph via Web UI.A flamegraph is a way to visualize resources used by a program, like CPU usage or memory allocations, and see which parts of your code were responsible.</p><p>Lets see how a function in C# can be instrumented using PyroScope.</p><ol><li>Develop function to be profiled
Lets have ASP.NET Core 5.0 based Web API as below,</li></ol><figure><img loading=lazy src=/images/profiling3.png><figcaption>Simple Web API handler in C#</figcaption></figure><ol start=2><li><p>Setup Pyroscope</p><p>Install Pyroscope Application by following instructions <a href=https://pyroscope.io/docs/agent-install-windows target=_blank rel="noopener noreferrer">here</a> for Windows. Note that, Pyroscope server component won&rsquo;t run on Windows in which case either <a href=https://docs.microsoft.com/en-us/windows/wsl/install target=_blank rel="noopener noreferrer">Windows Subsystem for Linux (WSL)</a> or <a href=https://pyroscope.io/docs/docker-guide target=_blank rel="noopener noreferrer">Docker</a> can be used. In case of Linux, instructions provided <a href=https://pyroscope.io/docs/server-install-linux target=_blank rel="noopener noreferrer">here</a> are sufficient for both client and server components.</p><p>I have setup the application on Windows 10 while using WSL for Pyroscope Server.</p></li><li><p>Configure Pyroscope client and run the Application</p><ul><li><p>Build the application using <code>dotnet build</code></p></li><li><p>Configure below environment variables (below is powershell format or you can use <code>SET ...</code> commands on command prompt),</p><pre><code>  ```
      $env:PYROSCOPE_SPY_NAME=&quot;dotnetspy&quot;;
      $env:PYROSCOPE_APPLICATION_NAME=&quot;my.dotnet.app&quot;;
      $env:PYROSCOPE_SERVER_ADDRESS=&quot;http://localhost:4040&quot;;

  ```
</code></pre></li><li><p>Update path to include pyroscope installation folder using <code>$env:Path += ";C:\Program Files\Pyroscope\Pyroscope Agent\"</code></p></li><li><p>Run the Application using <code>pyroscope exec dotnet .\bin\Debug\net5.0\webapi.dll</code>.</p></li></ul></li><li><p>Run Pyroscope Server</p><ul><li><p>Start Pyroscope server from WSL Linux prompt using, <code>sudo pyroscope server</code>. The output of this command should show Port on which server is running.</p><ul><li>Either use <a href=https://curl.se/ target=_blank rel="noopener noreferrer">curl</a> or <a href=https://github.com/rakyll/hey target=_blank rel="noopener noreferrer">hey</a> tool to invoke the API. Below command shows how to generate load using hey,<ul><li>run <code>.\hey.exe -m GET -c 10 -q 2 http://localhost:5000/weatherforecast</code> (Note: Modify the URL As appropriate)</li></ul></li></ul></li></ul></li><li><p>Observe the flame graph in Pyroscope Web UI.</p><ul><li><p>Observe the Table and/or flamegraph using Pyroscope Web interface. Below screenshot shows flamegraph for above code. Refer <a href=https://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html target=_blank rel="noopener noreferrer">here</a> and <a href=https://www.datadoghq.com/knowledge-center/distributed-tracing/flame-graph/ target=_blank rel="noopener noreferrer">here</a> for everything about flame graphs.</p><figure><img loading=lazy src=/images/profiling1.png><figcaption>Table and flamegraph for API</figcaption></figure><figure><img loading=lazy src=/images/profiling2.png><figcaption>Table and flamegraph for API</figcaption></figure></li></ul></li></ol><p>Overall, Pyroscope provides easy way to observe Memory/CPU utilization as part of developer workflow on workstation itself. This is especially useful for development environments which do not provide profiling out of the box.</p><h2 id=benchmarking>Benchmarking<a hidden class=anchor aria-hidden=true href=#benchmarking>#</a></h2><p>Crank is tool used by Microsoft internally to benchmark applications. It is released as <a href=https://nuget.org target=_blank rel="noopener noreferrer">Nuget</a> package and currently .NET based code or Docker Containers can be benchmarked using it. Lets see steps to benchmark .NET Application using Crank.</p><ol><li><p>Write code, intended to be benchmarked. In this case, its very simple one as below,</p><pre><code> <figure>
            <img loading=lazy src=/images/crank-prof4.png> <figcaption>
                    C# Code to be benchmarked
                </figcaption>
        </figure>

</code></pre></li><li><p>Setup Crank</p><p>Follow the instructions provided <a href=https://github.com/dotnet/crank/blob/main/docs/getting_started.md target=_blank rel="noopener noreferrer">here</a> to setup crank. Crank expects Configuration in YAML format which contains details like <em>Job</em> to be used. Crank has built-in jobs which are essentially wrappers around CLI load testing tools like <a href=https://github.com/codesenberg/bombardier target=_blank rel="noopener noreferrer">bombardier</a> and <a href=https://github.com/wg/wrk target=_blank rel="noopener noreferrer">wrk</a> and so on. Since i am using Windows to run crank, we will go with Bombardier which is cross platform. Below is how a basic configuration looks like,</p><figure><img loading=lazy src=/images/crank-prof3.png><figcaption>Crank YAML Configuration</figcaption></figure><p>It allows for extensibility in terms of overriding the job configuration in terms of how load should be generated etc.</p></li><li><p>Run Crank Agent - Next step is to run crank agent in a command prompt or powershell by simply running <code>crank-agent</code></p></li><li><p>Record data for benchmarking using Crank CLI.</p><p>Now run Crank from the application folder as <code>crank --config crank.benchmarks.yml --scenario hello --profile local --application.options.displayOutput true</code></p><p>This command builds the code and launches job while recording the Utilization and other parameters and shows output like,</p><figure><img loading=lazy src=/images/crank-prof1.png><figcaption>Application's CPU Utilization</figcaption></figure><figure><img loading=lazy src=/images/crank-prof2.png><figcaption>Observations during executing load testing</figcaption></figure></li></ol><p>Overall, i found Crank helpful for following,</p><ul><li>it helps quickly test effect of any code changes by means of quickly benchmarking the application. The overall benchmarking might not be similar to end state ie. when the application will be deployed on target infrastructure. However, it still gives insights to developer about impact of code changes</li><li>Crank can be easily used for local applications as well as for docker containers.</li><li>It can either be used locally or in distributed manner.</li></ul><h3 id=useful-references>Useful References<a hidden class=anchor aria-hidden=true href=#useful-references>#</a></h3><ul><li><a href=https://pyroscope.io target=_blank rel="noopener noreferrer">Pyroscope</a></li><li><a href=https://github.com/dotnet/crank target=_blank rel="noopener noreferrer">Crank</a></li><li><a href="https://queue.acm.org/detail.cfm?id=1117403" target=_blank rel="noopener noreferrer">Performance Anti-patterns</a></li></ul><p>Happy Profiling and Benchmarking !!</p><hr><script src=https://utteranc.es/client.js repo=sachinsu/sachinsu.github.io issue-term=title label=blogcomment theme=github-light crossorigin=anonymous async></script></div><footer class=post-footer><ul class=post-tags><li><a href=https://sachinsu.github.io/tags/pyroscope/>Pyroscope</a></li><li><a href=https://sachinsu.github.io/tags/crank/>Crank</a></li><li><a href=https://sachinsu.github.io/tags/flame-graph/>Flame Graph</a></li><li><a href=https://sachinsu.github.io/tags/cpu/>CPU</a></li></ul><nav class=paginav><a class=prev href=https://sachinsu.github.io/posts/is_sqlite_production_ready/><span class=title>« Prev</span><br><span>Can SQLite be considered for Server Applications?</span>
</a><a class=next href=https://sachinsu.github.io/posts/dbre/><span class=title>Next »</span><br><span>Database Reliability Engineering - My Notes</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling and benchmarking tools for Applications on x" href="https://x.com/intent/tweet/?text=Profiling%20and%20benchmarking%20tools%20for%20Applications&amp;url=https%3a%2f%2fsachinsu.github.io%2fposts%2fprofiling_n_benchmarking%2f&amp;hashtags=pyroscope%2ccrank%2cflamegraph%2cCPU"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling and benchmarking tools for Applications on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsachinsu.github.io%2fposts%2fprofiling_n_benchmarking%2f&amp;title=Profiling%20and%20benchmarking%20tools%20for%20Applications&amp;summary=Profiling%20and%20benchmarking%20tools%20for%20Applications&amp;source=https%3a%2f%2fsachinsu.github.io%2fposts%2fprofiling_n_benchmarking%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling and benchmarking tools for Applications on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsachinsu.github.io%2fposts%2fprofiling_n_benchmarking%2f&title=Profiling%20and%20benchmarking%20tools%20for%20Applications"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling and benchmarking tools for Applications on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsachinsu.github.io%2fposts%2fprofiling_n_benchmarking%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling and benchmarking tools for Applications on whatsapp" href="https://api.whatsapp.com/send?text=Profiling%20and%20benchmarking%20tools%20for%20Applications%20-%20https%3a%2f%2fsachinsu.github.io%2fposts%2fprofiling_n_benchmarking%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling and benchmarking tools for Applications on telegram" href="https://telegram.me/share/url?text=Profiling%20and%20benchmarking%20tools%20for%20Applications&amp;url=https%3a%2f%2fsachinsu.github.io%2fposts%2fprofiling_n_benchmarking%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Profiling and benchmarking tools for Applications on ycombinator" href="https://news.ycombinator.com/submitlink?t=Profiling%20and%20benchmarking%20tools%20for%20Applications&u=https%3a%2f%2fsachinsu.github.io%2fposts%2fprofiling_n_benchmarking%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>©</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>