<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Using Channels for High performance Producer consumer implementation - Learnings in IT</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta property="og:title" content="Using Channels for High performance Producer consumer implementation"><meta property="og:description" content="Background Recently, i got involved in assignment where in an application was facing issues with throughput. Expectation is to support more than 500 transactions per second while load testing results were indicating system was experiencing high latency beyond 100+ transactions per second.
This application is developed in .NET Framework + .NET Core and primarily uses Relational Database for persistence and has point to point integration (mainly over HTTP) with internal & external application(s)."><meta property="og:type" content="article"><meta property="og:url" content="https://sachinsu.github.io/posts/channelsforproducerconsumer/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-12T10:25:04+05:30"><meta property="article:modified_time" content="2020-02-12T10:25:04+05:30"><meta itemprop=name content="Using Channels for High performance Producer consumer implementation"><meta itemprop=description content="Background Recently, i got involved in assignment where in an application was facing issues with throughput. Expectation is to support more than 500 transactions per second while load testing results were indicating system was experiencing high latency beyond 100+ transactions per second.
This application is developed in .NET Framework + .NET Core and primarily uses Relational Database for persistence and has point to point integration (mainly over HTTP) with internal & external application(s)."><meta itemprop=datePublished content="2020-02-12T10:25:04+05:30"><meta itemprop=dateModified content="2020-02-12T10:25:04+05:30"><meta itemprop=wordCount content="586"><meta itemprop=keywords content=".net core,channels,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using Channels for High performance Producer consumer implementation"><meta name=twitter:description content="Background Recently, i got involved in assignment where in an application was facing issues with throughput. Expectation is to support more than 500 transactions per second while load testing results were indicating system was experiencing high latency beyond 100+ transactions per second.
This application is developed in .NET Framework + .NET Core and primarily uses Relational Database for persistence and has point to point integration (mainly over HTTP) with internal & external application(s)."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-169012216-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title="Learnings in IT" rel=home><div class="logo__item logo__text"><div class=logo__title>Learnings in IT</div><div class=logo__tagline>A Simple Technical Blog</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li><li class=menu__item><a class=menu__link href=/posts/><span class=menu__text>Blog</span></a></li><li class=menu__item><a class=menu__link href=/projects/><span class=menu__text>Projects</span></a></li><li class=menu__item><a class=menu__link href=https://gist.github.com/sachinsu><span class=menu__text>Gists</span></a></li><li class=menu__item><a class=menu__link href=/links/home><span class=menu__text>Useful Links</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Using Channels for High performance Producer consumer implementation</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>Sachin Sunkle</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-02-12T10:25:04+05:30>Feb 12 2020</time></div></div></header><div class="post__toc toc"><div class=toc__title>Page content</div><div class=toc__menu><nav id=TableOfContents><ul><li><a href=#background>Background</a></li><li><a href=#approach>Approach</a></li><li><a href=#summary>Summary</a><ul><li><a href=#useful-references>Useful References,</a></li></ul></li></ul></nav></div></div><div class="content post__content clearfix"><h2 id=background>Background</h2><p>Recently, i got involved in assignment where in an application was facing issues with throughput. Expectation is to support more than 500 transactions per second while load testing results were indicating system was experiencing high latency beyond 100+ transactions per second.</p><p>This application is developed in .NET Framework + .NET Core and primarily uses Relational Database for persistence and has point to point integration (mainly over HTTP) with internal & external application(s).</p><h2 id=approach>Approach</h2><p>The high level approach decided to perform diagnostics and subsequent corrective action(s) were,</p><ul><li>Benchmark code that involves Database and take corrective action</li><li>Identify tasks in hot code path that could potentially be decoupled or done in fire-n-forget mode.</li></ul><p>For point 2 from above, some of the tasks identified were,</p><ul><li>Sending Email/SMS on myriad of events</li><li>Integration with External Applications over HTTP</li></ul><p>Next task was to arrive at approach on how to perform them effectively outside of hot code path without incurring need of any additional resources (hardware or software)as far as possible. Accordingly, we had two options,</p><ul><li><em>Polling</em> - Periodically polling database to check for occurance of event and then performing the action.</li><li><em>Event Driven</em> - Using Event notification feature of database (e.g. <a href=https://www.postgresql.org/docs/current/sql-notify.html target=_blank rel="noopener noreferrer">Listen/Notify</a> in PostgreSQL or <a href=https://docs.oracle.com/cd/B28359_01/appdev.111/b28424/adfns_cqn.htm target=_blank rel="noopener noreferrer">Change Notification</a>/<a href=https://www.oracle.com/database/technologies/advanced-queuing.html target=_blank rel="noopener noreferrer">Advanced Queuing</a> in Oracle).</li></ul><p>We decided to go with <em>Event driven</em> as,</p><ul><li>Cleaner approach that doesn&rsquo;t require perodically checking for events thus consuming a database connection and more code.</li><li>We may have to have more than one such daemons to cater to different events in application.</li></ul><p>Post finalizing on event driven approach for gathering events, next task was to determine how to effectively send email/sms or any other HTTP requests considering that rate of arrival of events will not be matching rate of processing them. Also these</p><p>So what are the options available in .NET Ecosystem, Below are the ones i am aware of,</p><ul><li><a href=https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/ target=_blank rel="noopener noreferrer">Channels</a> - High performance implementation of In-memory producer/consumer pattern.</li><li><a href=https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library target=_blank rel="noopener noreferrer">TPL Dataflow</a> - Super set of Channels Library. Aimed at use cases where blocks of logic are to be linked together to same or different consumers and so on. Also all these features come with additional overheads.</li></ul><p>For the task at hand, functionality offered by Channels is sufficient to implement in-memory producer consumer pattern.</p><p>So we wrapped above event processing in a Windows service implemented as <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.1&amp;tabs=visual-studio" target=_blank rel="noopener noreferrer">.NET Core WorkerService</a></p><p>Generic Implementation is as follows,</p><ul><li><p>Event Generator - In practice, this class will be responsible for wiring up to receive events from database</p></li><li><p>Event Consumer which uses channels to process events in parallel</p></li></ul><iframe src=//carbon.now.sh/embed/6fcbc36e6e5cc58c7b5ba9007e276afc style=transform:scale(.9);width:1024px;height:473px;border:0;overflow:hidden sandbox="allow-scripts allow-same-origin"></iframe><p>Refer Gist <a href=https://gist.github.com/sachinsu/6fcbc36e6e5cc58c7b5ba9007e276afc target=_blank rel="noopener noreferrer">here</a></p><p>Additionally, one may want to process requests out of order or asynchronously without using message queues. One such use case could be service to send Notifications where this service is exposed as Web API and it uses external service to dispatch notifications. For such scenarios, one can use back ground job in conjunction with Channels to process requests.</p><p>Below code shows a Web API that handles HTTP Requests and delegates actual task to background worker which is deployed as hosted service.</p><iframe src=//carbon.now.sh/embed/d0d2672d002be670366d58394c1d6031 style=transform:scale(.9);width:1024px;height:473px;border:0;overflow:hidden sandbox="allow-scripts allow-same-origin"></iframe><p>Refer Gist <a href=https://gist.github.com/sachinsu/d0d2672d002be670366d58394c1d6031 target=_blank rel="noopener noreferrer">here</a></p><p>However, note that there are trade-offs vis-a-vis message queues with this approach. Notably, in case of Web server crash, the pending jobs in queue will be lost.</p><h2 id=summary>Summary</h2><p>Other languages (notably <a href=https://tour.golang.org/concurrency/2 target=_blank rel="noopener noreferrer">Channels in Go</a>) have been providing out of the box implementation for in-memory producer with concurrent, parallel consumers. With Channels, .NET Ecosystem finally has construct that can be effectively put to use for high performance, concurrent use cases.</p><h3 id=useful-references>Useful References,</h3><ul><li><a href=https://docs.microsoft.com/en-us/dotnet/csharp/event-pattern#defining-and-raising-field-like-events target=_blank rel="noopener noreferrer">Event Pattern in C#</a></li><li><a href=https://gist.github.com/AlgorithmsAreCool/b0960ce8a3400305e43fe8ffdf89b32c target=_blank rel="noopener noreferrer">Gist on using Channels</a></li></ul><p>Happy Coding !!</p><hr><script src=https://utteranc.es/client.js repo=sachinsu/sachinsu.github.io issue-term=title label=blogcomment theme=github-light crossorigin=anonymous async></script></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/.net-core/ rel=tag>.net core</a></li><li class=tags__item><a class="tags__link btn" href=/tags/channels/ rel=tag>channels</a></li></ul></div></footer></article></main><div class="authorbox clearfix"><div class=authorbox__header><span class=authorbox__name>About Sachin Sunkle</span></div><div class=authorbox__description>A Coder in IT</div></div><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/posts/dotnetstandard/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>Using .NET standard Assembly in .NET core and .NET Framework</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/posts/samesitecookies/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>ASP.NET Core - Mind the SameSite HTTP Cookie settings</p></a></div></nav></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 Sachin Sunkle.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>